{"meta":{"title":"欢迎参观小灰灰的网站哟 ヾ(◍°∇°◍)ﾉﾞ ~","subtitle":"My Personal blog website —— be founded on March 9, 2019","description":"My personal website ~","author":"黄宇辉","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-09T13:21:39.000Z","updated":"2019-03-09T13:22:21.386Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-09T13:12:14.000Z","updated":"2019-03-09T13:21:01.175Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring-Boot拥抱MyBatis及Redis ~","slug":"Spring-Boot拥抱MyBatis及Redis","date":"2019-07-01T02:26:26.000Z","updated":"2019-07-02T11:46:51.051Z","comments":true,"path":"2019/07/01/Spring-Boot拥抱MyBatis及Redis/","link":"","permalink":"http://yoursite.com/2019/07/01/Spring-Boot拥抱MyBatis及Redis/","excerpt":"","text":"学习笔记 : Spring Boot拥抱MyBatis及Redis ~Spring Boot集成MyBatis下面通过使用Spring Boot开发一个基于SSM的框架的应用,并通过一个简单的用户信息查询为例,记录如何在Spring Boot中使用MyBatis ~ tb_user.sql : 用户信息数据表 1234567create table tb_user( id int auto_increment primary key, name varchar(15) not null, gender char null, email varchar(50) null); pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;pers.huangyuhui&lt;/groupId&gt; &lt;artifactId&gt;redis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot_redis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- mvn package --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; SpringbootRedisApplication.java : Spring Boot启动类 12345678910111213package pers.huangyuhui.redis;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootRedisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootRedisApplication.class, args); &#125;&#125; application.properties : Spring Boot配置文件 1234567#JDBC-Connection Configuration Informationspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truespring.datasource.username=xxxxxxspring.datasource.password=xxxxxx#Logging Configuration Informationlogging.level.pers.huangyuhui.redis=debug User.java : 用户信息实体类 1234567891011121314151617181920package pers.huangyuhui.redis.bean;/** * @project: springboot_redis * @description: 用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:08 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class User &#123; private Integer id; private String name; private String gender; private String email; //getter and setter ······&#125; UserMapper.java : 操控用户数据表信息 123456789101112131415161718192021222324252627package pers.huangyuhui.redis.dao;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import pers.huangyuhui.redis.bean.User;import java.util.List;/** * @project: springboot_redis * @description: Dao层-操控用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:12 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Mapperpublic interface UserMapper &#123; // TODO: 7/1/2019 查询所有用户信息 @Select(\"select * from tb_user\") List&lt;User&gt; selectAll(); // TODO: 7/1/2019 根据id删除指定用户信息 @Delete(\"Delete from tb_user where id = #&#123;id&#125;\") void deleteById(Integer id);&#125; UserService.java : 操控用户信息 12345678910111213141516171819202122package pers.huangyuhui.redis.service;import pers.huangyuhui.redis.bean.User;import java.util.List;/** * @project: springboot_redis * @description: Service层-操控用户信息 * @author: 黄宇辉 * @date: 7/1/2019-7:25 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public interface UserService &#123; // TODO: 7/1/2019 获取或有用户信息 List&lt;User&gt; findAll(); // TODO: 7/1/2019 根据id删除指定用户信息 void delete(Integer id);&#125; UserServiceImpl.java : UserService.java的实现类 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.redis.service.impl;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import pers.huangyuhui.redis.bean.User;import pers.huangyuhui.redis.dao.UserMapper;import pers.huangyuhui.redis.service.UserService;import javax.annotation.Resource;import java.util.List;/** * @project: springboot_redis * @description: UserService的实现类 * @author: 黄宇辉 * @date: 7/1/2019-7:27 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; //注入Mapper对象 @Resource private UserMapper userMapper; @Override public List&lt;User&gt; findAll() &#123; return userMapper.selectAll(); &#125; @Override public void delete(Integer id) &#123; userMapper.deleteById(id); &#125;&#125; UserController.java : 用户信息控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.redis.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import pers.huangyuhui.redis.bean.User;import pers.huangyuhui.redis.service.UserService;import java.util.List;/** * @project: springboot_redis * @description: 用户控制器 * @author: 黄宇辉 * @date: 7/1/2019-7:28 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controller@RequestMapping(\"/user\")public class UserController &#123; //注入业务对象 @Autowired private UserService userService; /** * @description: 获取所有用户信息 * @date: 2019-07-01 8:16 AM * @return: java.util.List&lt;pers.huangyuhui.redis.bean.User&gt; */ @RequestMapping(\"/getUserList\") @ResponseBody public List&lt;User&gt; getUserList() &#123; return userService.findAll(); &#125; /** * @description: 删除指定id的好友信息 * @param: id * @date: 2019-07-01 12:51 PM * @return: void */ @RequestMapping(\"/deleteUser/&#123;id&#125;\") public void deleteUser(@PathVariable Integer id) &#123; userService.delete(id); &#125;&#125; userList.html : 用户信息列表页面 (将EasyUI框架的资源文件拷贝到src/main/resource下的static文件夹下,并在static文件夹中创建userList.html页面文件) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息列表页面&lt;/title&gt; &lt;!-- CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/metro/easyui.css\"/&gt; &lt;!-- JS --&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.easyui.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"easyui/themes/locale/easyui-lang-zh_CN.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; $('#graid').datagrid(&#123; url: 'user/getUserList', fit: true, columns: [[ &#123;field: 'id', title: '编号', width: 100&#125;, &#123;field: 'name', title: '姓名', width: 100&#125;, &#123;field: 'gender', title: '性别', width: 100&#125;, &#123;field: 'email', title: '邮箱', width: 200&#125; ]] &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 用户信息列表 --&gt;&lt;table id=\"graid\"&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 启动Spring Boot项目,在浏览器中输入访问地址 : http://localhost:8080/userList.html后,显示效果参考下图 : 紧接着刷新页面三次,其控制台打印的日志信息如下所示,发现每刷新一次页面都会执行一次查询数据库操作,但如果将列表数据缓冲到Redis后,会发现控制台只会出现一次查询数据库的日志信息哟 !123456789101112132019-07-01 11:41:49.868 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:49.869 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:49.871 DEBUG 7844 --- [nio-8080-exec-3] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 52019-07-01 11:41:54.250 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:54.250 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:54.253 DEBUG 7844 --- [nio-8080-exec-5] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 52019-07-01 11:41:57.251 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 11:41:57.251 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 11:41:57.256 DEBUG 7844 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 5Process finished with exit code -1 Spring Boot集成RedisRedis是一个完全开源的,遵守BSD协议的,内存中的数据结构存储,它既可以作为数据库,也可以作为缓存和消息代理. 通常在企业中常将其作为缓存使用哟~ 接下来在Spring Boot集成MyBatis示例程序基础上将列表数据缓存到Redis中,详细步骤如下 : 在pom.xml中添加Spring Boot支持Redis的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在SpringbootRedisApplication.java中添加@EnableCaching注解来开启缓存 12345@SpringBootApplication@EnableCachingpublic class SpringbootRedisApplication &#123; //······&#125; 在业务逻辑类UserServiceImpl.java的方法上添加@Cacheable注解来支持Redis缓存 12345@Override@Cacheable(value = \"UserCatch\", key = \"'user.selectAll'\")public List&lt;User&gt; findAll() &#123; return userMapper.selectAll();&#125; 为便于数据的传输,将实体类User.java实现序列化接口Serializable 123public class User implements Serializable &#123; //······&#125; 在application.properties中指定Redis缓存主机地址及端口号. 我使用的是Windows的Redis发行版哟,其学习笔记 : https://yubuntu0109.github.io/2019/06/25/Hi-Redis/ 123#Redis Configuration Infromationspring.redis.host=localhostspring.redis.port=6379 启动Redis服务,并启动Spring Boot项目,在浏览器地址栏中输入访问地址 : http://localhost:8080/userList.html后,不断刷新页面,其控制台打印的日志信息如下,结论 : 在没有使用Redis缓存之前,每刷新一次页面,都会执行一次查询数据库的操作,添加缓存后,会发现日志信息中只出现了一次查询语句,这也就说明所配置的Redis缓存已经生效啦 ~ 123456789101112131415161718192019-07-01 12:43:06.945 INFO 1984 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet &apos;dispatcherServlet&apos;2019-07-01 12:43:06.946 INFO 1984 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet &apos;dispatcherServlet&apos;2019-07-01 12:43:06.951 INFO 1984 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 5 ms2019-07-01 12:43:07.218 INFO 1984 --- [nio-8080-exec-7] io.lettuce.core.EpollProvider : Starting without optional epoll library2019-07-01 12:43:07.218 INFO 1984 --- [nio-8080-exec-7] io.lettuce.core.KqueueProvider : Starting without optional kqueue library2019-07-01 12:43:07.701 INFO 1984 --- [nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting...2019-07-01 12:43:07.791 INFO 1984 --- [nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed.2019-07-01 12:43:07.805 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: select * from tb_user 2019-07-01 12:43:07.815 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 12:43:07.836 DEBUG 1984 --- [nio-8080-exec-7] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 7Process finished with exit code -1 清除Redis缓存当执行添加,更新和删除操作后,数据库中的数据会发生变化,继而Redis缓存中的数据同样也需要进行相应的变化,为了保证Redis缓存中的数据与数据库中的一致,通常需要在执行添加,更新和删除操作之前清除缓存,然后再下一次执行查询操作时,将新的数据存储到Redis缓存中 . 若要实现清除缓存的功能,只需在相应的方法中使用@CacheEvict注解即可,下面以案例程序中的删除用户功能为例,在用户业务逻辑类的deleteUser()方法上添加@CacheEvict注解 :12345@Override@CacheEvict(value = \"UserCatch\", key = \"'user.selectAll'\")public void delete(Integer id) &#123; userMapper.deleteById(id);&#125; 重启Spring Boot项目,在浏览器地址栏中输入访问地址 : http://localhost:8080/user/deleteUser/5, ../6 , ../7删除id为5,6,7的用户信息后再查询用户列表信息 : http://localhost:8080/userList.html,其控制台打印的日志信息如下 :12345678910111213141516171819202019-07-01 18:13:45.143 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:13:45.160 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 5(Integer)2019-07-01 18:13:45.162 DEBUG 14764 --- [nio-8080-exec-1] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:13:45.331 INFO 14764 --- [nio-8080-exec-1] io.lettuce.core.EpollProvider : Starting without optional epoll library2019-07-01 18:13:45.332 INFO 14764 --- [nio-8080-exec-1] io.lettuce.core.KqueueProvider : Starting without optional kqueue library2019-07-01 18:15:16.033 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:15:16.033 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 6(Integer)2019-07-01 18:15:16.034 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:15:31.217 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : ==&gt; Preparing: Delete from tb_user where id = ? 2019-07-01 18:15:31.218 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : ==&gt; Parameters: 7(Integer)2019-07-01 18:15:31.219 DEBUG 14764 --- [nio-8080-exec-6] p.h.redis.dao.UserMapper.deleteById : &lt;== Updates: 12019-07-01 18:15:47.353 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : ==&gt; Preparing: Select * from tb_user 2019-07-01 18:15:47.353 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : ==&gt; Parameters: 2019-07-01 18:15:47.377 DEBUG 14764 --- [nio-8080-exec-4] p.h.redis.dao.UserMapper.selectAll : &lt;== Total: 4Process finished with exit code -1","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot之文件上传与下载","slug":"Spring-Boot之文件上传","date":"2019-06-30T13:22:23.000Z","updated":"2019-07-02T11:31:29.479Z","comments":true,"path":"2019/06/30/Spring-Boot之文件上传/","link":"","permalink":"http://yoursite.com/2019/06/30/Spring-Boot之文件上传/","excerpt":"","text":"学习笔记 : Spring Boot之文件上传关键字 : Servlet 3.0 、 SpringMVC 、 Spring Boot 简介前天使用Sprint Boot开发了一个基于SSM框架的项目,一个简单的好友备忘录,该项目地址 : https://github.com/YUbuntu0109/SpringBoot-CURD-Memo ,在该项目中除了基本的CURD,还添加了上传用户头像的功能哟~ 以至于在写此功能时发现了Spring Boot在上传文件时不同于Spring MVC的一个细节问题 : 头像被上传到非预期路径下! 注 : Spring Boot启动时会创建一个/tmp/tomcat.xxxxxx/work/Tomcat/localhost/ROOT的临时目录作为文件上传的临时目录,但是该目录会在10天之后被系统自动清理掉 !` 继而程序抛出如下异常信息 :12java.io.IOException: java.io.FileNotFoundException:/tmp/tomcat.273391201583741210.8080/work/Tomcat/localhost/ROOT/upload/portrait/myportrait.jpg (No such file or directory)... 异常分析upload/portrait是我用于存储头像的项目目录,而transferTo(File dest)方法预期写入的文件路径为/tmp/tomcat.273391201583741210.8080/work/Tomcat/localhost/ROOT/upload/portrait/,我们并没有创建该目录,因此会抛出此异常信息 ! 问题分析为什么会这样呢 ? 相对路径-预期路径应该是项目路径/tmp/source/,但是报错确是一个系统临时文件路径,由于是写入文件时报错,继而我们来查看一下transferTo(File dest)的源码吧 : 12345678910111213141516171819202122232425package org.apache.catalina.core;//....../** * Adaptor to allow &#123;@link FileItem&#125; objects generated by the package renamed * commons-upload to be used by the Servlet 3.0 upload API that expects * &#123;@link Part&#125;s. */public class ApplicationPart implements Part &#123; //...... @Override public void write(String fileName) throws IOException &#123; File file = new File(fileName); if (!file.isAbsolute()) &#123; file = new File(location, fileName); &#125; try &#123; fileItem.write(file); &#125; catch (Exception e) &#123; throw new IOException(e); &#125; &#125;&#125; 由源码可知,在使用Servlet3.0支持的上传文件功能时,若我们没有使用绝对路径,transferTo(File dest)方法会在相对路径前添加一个location路径 ! 继而影响了SpringMVC的MultipartFile的使用 . 解决方案使用绝对路径通过ResourceUtils.getURL(&quot;classpath:&quot;).getPath()获取项目的绝对路径,为防止项目路径中含有空格等特殊字符继而乱码,可以通过URLDecoder.decode(String s, Charset charset)对其进行解码.1234//项目下存储头像的目录private final String uploadPath = \"/static/upload/friend_portrait/\";//指定存储头像目录的完整路径(项目发布路径):若不使用绝对路径,则Spring boot会默认将上传的文件存储到临时目录中String dirPath = URLDecoder.decode(ResourceUtils.getURL(\"classpath:\").getPath(), StandardCharsets.UTF_8) + uploadPath; 注 : 当我们使用ClassLoader()的getResource()方法获取路径时,获取到的路径是已被URLEncoder.encode(path,&quot;utf-8&quot;)编码了的,当路径中存在中文和空格时,它会对这些字符进行转换,继而得到的往往不是我们想要的真实路径,所以我们可以调用URLDecoder.decode(String s, Charset charset)方法进行解码,以便得到原始的中文及空格路径. 发送的时候使用encode(String s, Charset charset)编码,接收的时候使用URLDecoder.decode(String s, Charset charset)解码,按指定的编码格式进行编码、解码,可以保证不会出现乱码哟 ~12345//使用指定的编码机制将字符串转换为 application/x-www-form-urlencoded 格式URLEncoder.encode(String s, Charset charset)//使用指定的编码机制对 application/x-www-form-urlencoded 字符串解码URLDecoder.decode(String s, Charset charset) 修改location的值location可以理解为临时文件目录,可以通过配置location的值,使其指向我们的项目路径,继而来解决此问题. 只需在Spring Boot启动类中添如下代码 :123456 @Bean MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); factory.setLocation(\"/app/pttms/tmp\"); return factory.createMultipartConfig();&#125; 示例程序该上传文件的示例程序摘自我的Sping Boot-好友备忘录小项目,程序中使用绝对路径方案来解决上述问题,该程序具有参考与学习价值哟~ FriendController.java : 好友信息控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.haungyuhui.memo.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.stereotype.Controller;import org.springframework.util.ResourceUtils;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import pers.haungyuhui.memo.bean.Friend;import pers.haungyuhui.memo.service.FriendService;import pers.haungyuhui.memo.util.UploadFile;import javax.annotation.Resource;import java.io.FileNotFoundException;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @project: memo * @description: 控制器-管理好友信息页面 * @author: 黄宇辉 * @date: 6/28/2019-8:25 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controller@RequestMapping(\"/memo\")public class StudentController &#123; //...... //项目下存储头像的目录,需放在静态资源'static'目录下哟 private final String uploadPath = \"/static/upload/friend_portrait/\"; /** * @description: 上传头像-原理:将头像上传到项目发布目录中,通过读取数据库中的头像路径来显示头像 * @param: photo * @param: request * @date: 2019-06-29 4:20 PM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ @PostMapping(\"/uploadPhoto\") @ResponseBody public Map&lt;String, Object&gt; uploadPhoto(MultipartFile photo) throws FileNotFoundException &#123; //指定存储头像目录的完整路径(项目发布路径): 若不使用绝对路径,则Spring boot会默认将上传的文件存储到临时目录中 String dirPath = URLDecoder.decode(ResourceUtils.getURL(\"classpath:\").getPath(), StandardCharsets.UTF_8) + uploadPath; //返回头像的上传结果 return UploadFile.getUploadResult(photo, dirPath, uploadPath); &#125;&#125; UploadFile.java : 上传文件的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package pers.haungyuhui.memo.util;import org.apache.commons.io.filefilter.SuffixFileFilter;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.UUID;/** * @project: memo * @description: 上传文件工具类 * @author: 黄宇辉 * @date: 6/29/2019-9:38 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class UploadFile &#123; //限制头像大小最大为20M private static final int MAX_SIZE = 20971520; //存储文件上传失败的错误信息 private static Map&lt;String, Object&gt; error_result = new HashMap&lt;&gt;(); //存储头像的上传结果信息 private static Map&lt;String, Object&gt; upload_result = new HashMap&lt;&gt;(); //指定上传文件的类型 private static final String[] suffixs = new String[]&#123;\".png\", \".PNG\", \".jpg\", \".JPG\", \".jpeg\", \".JPEG\", \".gif\", \".GIF\", \".bmp\", \".BMP\"&#125;; /** * @description: 效验所上传图片的大小及格式等信息... * @param: photo * @param: path * @date: 2019-06-29 9:40 AM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ private static Map&lt;String, Object&gt; uploadPhoto(MultipartFile photo, String path) &#123; //若存储文件的目录路径不存在,则创建该目录 File filePath = new File(path); if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; //限制上传文件的大小 if (photo.getSize() &gt; MAX_SIZE) &#123; error_result.put(\"success\", false); error_result.put(\"msg\", \"上传的图片大小不能超过20M哟!\"); return error_result; &#125; // 限制上传的文件类型 SuffixFileFilter suffixFileFilter = new SuffixFileFilter(suffixs); if (!suffixFileFilter.accept(new File(path + photo.getOriginalFilename()))) &#123; error_result.put(\"success\", false); error_result.put(\"msg\", \"禁止上传此类型文件! 请上传图片哟!\"); return error_result; &#125; return null; &#125; /** * @description: 获取头像的上传结果信息 * @param: photo * @param: dirPaht * @param: portraitPath * @date: 2019-06-29 9:44 AM * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */ public static Map&lt;String, Object&gt; getUploadResult(MultipartFile photo, String dirPath, String uploadPath) &#123; if (!photo.isEmpty() &amp;&amp; photo.getSize() &gt; 0) &#123; //效验图片-error_result: 存储头像上传失败的错误信息 Map&lt;String, Object&gt; error_result = uploadPhoto(photo, dirPath); if (error_result != null) &#123; return error_result; &#125; //使用UUID重命名图片名称(uuid__原始图片名称) String newPhotoName = UUID.randomUUID() + \"__\" + photo.getOriginalFilename(); //将上传的图片保存到目标目录下 try &#123; photo.transferTo(new File(dirPath + newPhotoName)); //将存储头像的目录路径返回给页面 upload_result.put(\"success\", true); upload_result.put(\"portrait_path\", uploadPath + newPhotoName); &#125; catch (IOException e) &#123; e.printStackTrace(); upload_result.put(\"success\", false); upload_result.put(\"msg\", \"上传文件失败! 服务器端发生异常!\"); return upload_result; &#125; &#125; else &#123; upload_result.put(\"success\", false); upload_result.put(\"msg\", \"头像上传失败! 未找到指定图片!\"); &#125; return upload_result; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot项目:好友备忘录","slug":"Spring-Boot项目-好友备忘录","date":"2019-06-30T12:53:09.000Z","updated":"2019-06-30T13:10:06.140Z","comments":true,"path":"2019/06/30/Spring-Boot项目-好友备忘录/","link":"","permalink":"http://yoursite.com/2019/06/30/Spring-Boot项目-好友备忘录/","excerpt":"","text":"A simple project for Spring Boot ~ 我的第一个Spring Boot小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址 : https://github.com/YUbuntu0109/SpringBoot-CURD-Memo 项目概述👍一个简单的,基于Spring Boot的好友备忘录小项目,通过本项目可以学习Spring Boot与MyBatis的整合及CURD操作的基本思路,同时也可以帮助你学习Thylemeaf模板引擎使用哟 ! 该项目的代码注释详细,逻辑结构清晰,非常具有参考,学习价值哟 ! 可以说非常适合初学Sping Boot的同学啦(っ•̀ω•́)っ✎⁾⁾~ 💗为了让更多同学快速地体验该项目,已通过mvn package将其打包,并将其作为v1.0上传到了release中~ 项目截图 项目主页面 好友信息管理页面 项目结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374│ .gitattributes│ LICENSE│ README.md│├─database file│ memo.sql│├─demonstration_picture│ SpringBoot-CURD-Memo_FriendListView.PNG│ SpringBoot-CURD-Memo_FriendListView2.PNG│ SpringBoot-CURD-Memo_MainView.PNG│└─memo │ .gitignore │ mvnw │ mvnw.cmd │ pom.xml │ │ └─src └─main ├─java │ └─pers │ └─haungyuhui │ └─memo │ │ MemoApplication.java │ │ │ ├─bean │ │ Friend.java │ │ │ ├─controller │ │ StudentController.java │ │ │ ├─dao │ │ FriendMapper.java │ │ FriendMapper.xml │ │ │ ├─service │ │ │ FriendService.java │ │ │ │ │ └─impl │ │ FriendServiceImpl.java │ │ │ └─util │ UploadFile.java │ └─resources │ application.properties │ ├─static │ ├─easyui │ │ │ jquery.easyui.min.js │ │ │ jquery.min.js │ │ │ │ │ ├─css │ │ │ default.css │ │ │ demo.css │ │ │ │ │ ├─js │ │ │ outlook2.js │ │ │ validateExtends.js │ │ │ │ │ └─themes │ │ │(略..) │ │ │ │ │ │ │ └─image │ default_portrait.png │ └─templates friendList.html intro.html main.html 项目文件说明-Spring boot启动类1MemoApplication.java 项目文件说明-数据库文件1memo.sql 项目文件说明-EasyUI 前端框架1easyui/ 项目文件说明-默认头像1default_portrait.png 🙂 Look forward to your contribution ! If you need any help, please contact me ~ QQ : 3083968068","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"Spring Boot之Thymeleaf","slug":"Spring-Boot之Thymeleaf","date":"2019-06-27T03:34:09.000Z","updated":"2019-06-27T09:22:01.077Z","comments":true,"path":"2019/06/27/Spring-Boot之Thymeleaf/","link":"","permalink":"http://yoursite.com/2019/06/27/Spring-Boot之Thymeleaf/","excerpt":"","text":"学习笔记 : Thymeleaf的常用语法简介 : Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎. Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中,并将HTML在浏览器中正确显示,并且可以作为静态原型,让开发团队能更容易地协作. Thymeleaf能够处理HTML,XML,JavaScript,CSS甚至纯文本 . 基础语法变量表达式 ${}使用方法 : 直接使用th:xx = &quot;${}&quot;获取对象属性12345678&lt;form id=\"userForm\"&gt; &lt;input id=\"id\" name=\"id\" th:value=\"$&#123;user.id&#125;\"/&gt; &lt;input id=\"username\" name=\"username\" th:value=\"$&#123;user.username&#125;\"/&gt; &lt;input id=\"password\" name=\"password\" th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/form&gt;&lt;div th:text=\"hello\"&gt;&lt;/div&gt;&lt;div th:text=\"$&#123;user.username&#125;\"&gt;&lt;/div&gt; 选择变量表达式 *{}使用方法 : 首先通过th:object获取对象,然后使用`th:xx = “{}”`获取对象属性*12345&lt;form id=\"userForm\" th:object=\"$&#123;user&#125;\"&gt; &lt;input id=\"id\" name=\"id\" th:value=\"*&#123;id&#125;\"/&gt; &lt;input id=\"username\" name=\"username\" th:value=\"*&#123;username&#125;\"/&gt; &lt;input id=\"password\" name=\"password\" th:value=\"*&#123;password&#125;\"/&gt;&lt;/form&gt; 链接表达式 @{}使用方法 : 通过链接表达式@{}直接拿到应用路径,然后拼接静态资源路径12345&lt;!-- 访问项目路径下的user并传递id,name等参数 --&gt;&lt;a th:href=\"@&#123;~/user(id=1,name=demo)&#125;\"&gt;demo&lt;/a&gt; &lt;script th:src=\"@&#123;/webjars/jquery/jquery.js&#125;\"&gt;&lt;/script&gt;&lt;link th:href=\"@&#123;/webjars/bootstrap/css/bootstrap.css&#125;\" rel=\"stylesheet\" type=\"text/css\"&gt; 片段表达式 ~{} ~{viewName} : 表示引入完整页面 ~{viewName ::selector} : 表示在指定页面寻找片段,其中selector可为片段名、jquery选择器等 ~{::selector} : 表示在当前页寻找 使用方法 : 首先通过th:fragment定制片段,然后通过th:replace填写片段路径和片段名123456&lt;!-- /views/common/head.html--&gt;&lt;head th:fragment=\"static\"&gt; &lt;script th:src=\"@&#123;/webjars/jquery/3.3.1/jquery.js&#125;\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;!-- /views/your.html --&gt;&lt;div th:replace=\"~&#123;common/head::static&#125;\"&gt;&lt;/div&gt; 注意 : 由于默认拼接的路径为spring.thymeleaf.prefix = classpath:/templates/,所以在使用替换路径th:replace开头请勿添加斜杠,避免部署运行的时候出现路径报错 ! 消息表达式 &amp;#35;{}即通常的国际化属性 : &amp;#35;{msg},用于获取国际化语言翻译值1&lt;title th:text=\"#&#123;user.title&#125;\"&gt;&lt;/title&gt; 其它表达式在基础语法中,默认支持字符串连接、数学运算、布尔逻辑和三目运算等..1&lt;input name=\"name\" th:value=\"$&#123;'I am '+(user.name!=null?user.name:'NoBody')&#125;\"/&gt; 常用语法迭代循环想要遍历List集合很简单,配合th:each即可快速完成迭代1234&lt;div th:each=\"user:$&#123;userList&#125;\"&gt; 账号: &lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码: &lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 在集合的迭代过程还可以获取状态变量,只需在变量后面指定状态变量名即可,状态变量可用于获取集合的下标/序号、总数、是否为单数/偶数行、是否为第一个/最后一个123456&lt;div th:each=\"user,stat:$&#123;userList&#125;\" th:class=\"$&#123;stat.even&#125;?'even':'odd'\"&gt; 下标: &lt;input th:value=\"$&#123;stat.index&#125;\"/&gt; 序号: &lt;input th:value=\"$&#123;stat.count&#125;\"/&gt; 账号: &lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码: &lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 如果缺省状态变量名,则迭代器会默认帮我们生成以变量名开头的状态变量 xxStat123456&lt;div th:each=\"user:$&#123;userList&#125;\" th:class=\"$&#123;userStat.even&#125;?'even':'odd'\"&gt; 下标：&lt;input th:value=\"$&#123;userStat.index&#125;\"/&gt; 序号：&lt;input th:value=\"$&#123;userStat.count&#125;\"/&gt; 账号：&lt;input th:value=\"$&#123;user.username&#125;\"/&gt; 密码：&lt;input th:value=\"$&#123;user.password&#125;\"/&gt;&lt;/div&gt; 条件判断if语句其语法为 : th:if,通常用于动态页面的初始化123&lt;div th:if=\"$&#123;userList&#125;\"&gt; &lt;div&gt;exist...&lt;/div&gt;&lt;/div&gt; 如果想取反则可以使用unless123&lt;div th:unless=\"$&#123;userList&#125;\"&gt; &lt;div&gt;not exist...&lt;/div&gt;&lt;/div&gt; switch语句其语法中需要th:switch与th:case结合使用,通常用于动态页面的初始化12345&lt;div th:switch=\"$&#123;num&#125;\"&gt; &lt;span th:case=\"1\"&gt;num=1&lt;/span&gt; &lt;span th:case=\"2\"&gt;num=2&lt;/span&gt; &lt;span th:case=\"3\"&gt;num=3&lt;/span&gt;&lt;/div 日期格式化使用默认的日期格式(toString方法)并不是我们预期的格式 : Mon Dec 03 23:16:50 CST 20181&lt;input type=\"text\" th:value=\"$&#123;user.createTime&#125;\"/&gt; 此时可以通过时间工具类&amp;#35;dates来将日期进行格式化为 : 2018-12-03 23:16:501&lt;input type=\"text\" th:value=\"$&#123;#dates.format(user.createTime,'yyyy-MM-dd HH:mm:ss')&#125;\"/&gt; 内联写法 内联写法 : 解决 JS无法获取服务端返回的变量的尴尬 ~ 使用方法 : 标准格式为: [[${xx}]],其可以读取服务端变量,也可以调用内置对象的方法.例如获取用户变量和应用路径:12345&lt;script th:inline=\"javascript\"&gt; var user = [[$&#123;user&#125;]];` var APP_PATH = [[$&#123;#request.getContextPath()&#125;]]; var LANG_COUNTRY = [[$&#123;#locale.getLanguage()+'_'+#locale.getCountry()&#125;]];&lt;/script&gt; 内置对象七大基础对象 ${&amp;#35;ctx} : 上下文对象,可用于获取其它内置对象 ${&amp;#35;vars} : 上下文变量 ${&amp;#35;locale} : 上下文区域设置 ${&amp;#35;request} : HttpServletRequest对象 ${&amp;#35;response} : HttpServletResponse对象 ${&amp;#35;session} : HttpSession对象 ${&amp;#35;servletContext} : ServletContext对象 常用的工具类 &amp;#35;strings :字符串工具类 &amp;#35;lists : List工具类 &amp;#35;arrays : 数组工具类 &amp;#35;sets : Set工具类 &amp;#35;maps : 常用Map方法 &amp;#35;objects : 一般对象类,通常用来判断非空 &amp;#35;bools : 常用的布尔方法 &amp;#35;execInfo : 获取页面模板的处理信息 &amp;#35;messages : 在变量表达式中获取外部消息的方法,与使用&amp;#35;{...}语法获取的方法相同 &amp;#35;uris : 转义部分URL / URI的方法 &amp;#35;conversions : 用于执行已配置的转换服务的方法 &amp;#35;dates : 时间操作和时间格式化等 &amp;#35;calendars : 用于更复杂时间的格式化 &amp;#35;numbers : 格式化数字对象的方法 &amp;#35;aggregates : 在数组或集合上创建聚合的方法 &amp;#35;ids : 处理可能重复的id属性的方法 🙂thanks a lot : https://www.jianshu.com/p/908b48b10702","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot之整合视图层技术","slug":"Spring-Boot之整合视图层技术","date":"2019-06-26T14:33:47.000Z","updated":"2019-06-27T03:07:13.789Z","comments":true,"path":"2019/06/26/Spring-Boot之整合视图层技术/","link":"","permalink":"http://yoursite.com/2019/06/26/Spring-Boot之整合视图层技术/","excerpt":"","text":"学习笔记 : Spring Boot之整合视图层技术简介 : 在目前的企业级应用开发中,前后端分离是趋势,但是视图技术还有一席之地. Spring Boot对视图层技术提供了很好的支持,官方推荐使用的模板引擎是Thymeleaf,也支持FreeMarker哟,需要注意的是Spring Boot官方并不推荐使用JSP技术 ! 整合ThymeleafThymeleaf是新一代模板引擎,类似于Velocity,FreeMarker等传统Java模板引擎.与其不同的是: Thymeleaf支持HTML原型,同时Spring Boot也提供了Thymeleaf自动化配置解决方案. 更多资料见 : https://www.thymeleaf.org/ 配置ThymeleafSpring Boot为Thymeleaf提供了自动化配置类ThymeleafAutoConfiguration,相关的配置信息在ThymeleafProperties类中,其部分源码如下所示 :1234567891011121314@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; ······ 如果需要对默认的Thymeleaf配置参数进行自定义,那么可以直接在application.properties中进行配置哟,常见配置如下:1234567891011121314#是否开启缓存,开发时可设置为false,默认为truespring.thymeleaf.cache=true#检查模板是否存在,默认为truespring.thymeleaf.check-template=true#检查模板位置是否存在,默认为truespring.thymeleaf.check-template-location=true#模板文件编码spring.thymeleaf.encoding=UTF-8#模板文件位置spring.thymeleaf.prefix=classpath:/templates/#Content-Type配置spring.thymeleaf.servlet.content-type=text/html#模板文件后缀spring.thymeleaf.suffix=.html 示例程序 pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;pers.huangyuhui&lt;/groupId&gt; &lt;artifactId&gt;view&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;view&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Book.java : 图书信息 123456789101112131415161718192021222324package pers.huangyuhui.view.bean;/** * @project: view * @description: 图书信息 * @author: 黄宇辉 * @date: 6/26/2019-9:24 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class Book &#123; private Integer id; private String name; private String author; public Book(Integer id, String name, String author) &#123; this.id = id; this.name = name; this.author = author; &#125; //getter and setter ...&#125; BookDao.java : 获取并存储图书信息 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.view.dao;import pers.huangyuhui.view.bean.Book;import java.util.ArrayList;import java.util.List;/** * @project: view * @description: 操控图书信息 * @author: 黄宇辉 * @date: 6/26/2019-9:41 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */public class BookDao &#123; //存储图书信息 private static List&lt;Book&gt; books = new ArrayList&lt;&gt;(); public static List&lt;Book&gt; getBooks() &#123; Book book1 = new Book(1, \"Spring\", \"spring-author\"); Book book2 = new Book(2, \"Spring MVC\", \"springmvc-author\"); Book book3 = new Book(3, \"MyBatis\", \"mybatis-author\"); Book book4 = new Book(4, \"Spring Boot\", \"springboot-author\"); books.add(book1); books.add(book2); books.add(book3); books.add(book4); return books; &#125;&#125; BookController.java : 操控图书信息的控制器 123456789101112131415161718192021222324252627package pers.huangyuhui.view.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;import pers.huangyuhui.view.dao.BookDao;/** * @project: view * @description: 操控图书信息的控制器 * @author: 黄宇辉 * @date: 6/26/2019-9:26 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class BookController &#123; @GetMapping(\"/getBookList\") public ModelAndView books() &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"books\", BookDao.getBooks()); modelAndView.setViewName(\"bookList\"); return modelAndView; &#125;&#125; bookList.html : 展示图书列表信息的页面 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;!-- 导入Thymeleaf的名称空间 --&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图书信息列表页面-Thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"book:$&#123;books&#125;\"&gt; &lt;td th:text=\"$&#123;book.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;book.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;book.author&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 整合FreeMarkerFreeMarker是一个非常古老的模板引擎,可以用在Web环境或者非Web环境中. 与Thymeleaf不同的是FreeMarker需要经过解析才能够在浏览器中展示出来. 更多资料见 : https://freemarker.apache.org/ 配置FreeMarkerSpring Boot对FreeMarker也提供了配置类FreeMarkerAutoConfiguration,相关的配置属性在FreeMarkerProperties中,其部分源码如下所示 :123456789101112@ConfigurationProperties( prefix = \"spring.freemarker\")public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties &#123; public static final String DEFAULT_TEMPLATE_LOADER_PATH = \"classpath:/templates/\"; public static final String DEFAULT_PREFIX = \"\"; public static final String DEFAULT_SUFFIX = \".ftl\"; private Map&lt;String, String&gt; settings = new HashMap(); private String[] templateLoaderPath = new String[]&#123;\"classpath:/templates/\"&#125;; private boolean preferFileSystemAccess = true; ······ 如果需要对默认的FreeMarker配置参数进行自定义,那么可以直接在application.properties中进行配置哟,常见配置如下:1234567891011121314151617181920#HttpServletRequest的属性是否可以覆盖controller中model的同名项spring.freemarker.allow-request-override=false#HttpSession的属性是否可以覆盖controller中的model的同名项spring.freemarker.allow-session-override=false#是否开启缓存spring.freemarker.cache=false#模板文件编码spring.freemarker.charset=UTF-8#是否检查模板位置spring.freemarker.check-template-location=true#Content-type的值spring.freemarker.content-type=text/html#是否将HttpServletRequest中的属性添加到Model中spring.freemarker.expose-request-attributes=false#是否将HttpSession中的属性添加到Model中spring.freemarker.expose-session-attributes=false#模板文件后缀spring.freemarker.suffix=.ftl#模板文件位置spring.freemarker.template-loader-path=classpath:/templates/ 示例程序 Book.java,BookDao.java,BookController.java程序与Thymeleaf示例程序相同,此处略写 … 在pom.xml中需添加FreeMarker依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; bookList.html : 展示图书列表的页面 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图书列表信息页面-FreeMarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;!-- 若model中的books不为空并且books中有数据,则遍历books集合 --&gt; &lt;#if books ??&amp;&amp;(books?size&gt;0)&gt; &lt;#list books as book&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/#if&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 整合JSPSpring Boot官方并不推荐使用JSP技术! 但是小哥是个念旧的孩纸,来学习一波呗😁 ~ Book.java,BookDao.java,BookController.java程序与Thymeleaf示例程序相同,此处略写 … 在pom.xml中需添加使用JSP所需的依赖 1234567891011&lt;!-- JSTL --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 用于编译JSP --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; application.properties配置文件中用于解析视图的代码 12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp bookList.jsp : 展示图书列表信息的页面 12345678910111213141516171819202122&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;图书列表信息页面-JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;books&#125;\" var=\"book\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 程序运行结果(以上三个示例程序运行结果大同小异哟)","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot之基本Web开发","slug":"Spring-Boot之基本Web开发","date":"2019-06-26T02:11:58.000Z","updated":"2019-06-26T11:12:39.362Z","comments":true,"path":"2019/06/26/Spring-Boot之基本Web开发/","link":"","permalink":"http://yoursite.com/2019/06/26/Spring-Boot之基本Web开发/","excerpt":"","text":"学习笔记 : Spring Boot之基本Web开发@ServletComponentScan的使用在SpringBootApplication上使用@ServletComponentScan注解后,Servlet、Filter、Listener可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册,无需其他代码哟 ! 开发Servlet pom.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- lookup parent from repository --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;io.github.yubuntu0109&lt;/groupId&gt; &lt;artifactId&gt;web-servlet&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;web-servlet&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MyServlet.java : 自定义Servlet 1234567891011121314151617181920212223package pers.huangyuhui.web.servlet;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @project: web-servlet * @description: learn to use the annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-9:49 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebServlet(name = \"MyServlet\", urlPatterns = \"/helloServlet\")public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println(\"this's my servlet ~\"); &#125;&#125; WebServletApplication.java : Spring Boot启动类 123456789101112131415package pers.huangyuhui.webservlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@SpringBootApplication@ServletComponentScanpublic class WebServletApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebServletApplication.class, args); &#125;&#125; 程序运行结果 1this&apos;s my servlet ~ 开发Filter MyFilter.java : 自定义过滤器 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @project: web-servlet * @description: learn to user annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-10:30 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebFilter(filterName = \"MyFile\", urlPatterns = \"/helloServlet\")public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"this's my filetr !\"); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 程序运行结果 12this&apos;s my filetr !this&apos;s my servlet ~ 开发Listener MyListener.java : 自定义监听器 12345678910111213141516171819202122232425262728package pers.huangyuhui.web.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * @project: web-servlet * @description: learn to user annotation: @ServletComponentScan * @author: 黄宇辉 * @date: 6/26/2019-10:54 AM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@WebListener(value = \"MyListenre\")public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"this's contextInitialized ~\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"this's contextDestroyed ~\"); &#125;&#125; 程序运行结果 1234this&apos;s requestInitialized ~this&apos;s my filetr !this&apos;s my servlet ~this&apos;s requestDestroyed ~ 使用Bean注解注册Servlet等组件WebServletApplication.java : Spring Boot启动类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package pers.huangyuhui.web;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import pers.huangyuhui.web.filter.MyFilter;import pers.huangyuhui.web.listener.MyListener;import pers.huangyuhui.web.servlet.MyServlet;@SpringBootApplicationpublic class WebServletApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebServletApplication.class, args); &#125; @Bean //使用@Bean注解注册Servlet public ServletRegistrationBean getServletRegistration() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet()); servletRegistrationBean.addUrlMappings(\"/Bean-helloServlet\"); return servletRegistrationBean; &#125; /*the result: this's my servlet ~ */ @Bean //使用@Bean注解注册Filter public FilterRegistrationBean getFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); filterRegistrationBean.addUrlPatterns(\"/Bean-helloServlet\"); return filterRegistrationBean; &#125; /*the result: this's my filetr ! this's my servlet ~ */ @Bean //使用@Bean注解注册Listener public ServletListenerRegistrationBean getServletListenerRegistrationBean() &#123; return new ServletListenerRegistrationBean(new MyListener()); &#125; /*the result: this's contextInitialized ~ */&#125; 静态资源访问默认策略简介 : Spring Boot默认会过滤所有的静态资源,而静态资源的位置一共有5个,如下所示. 注意: 按照定义的顺序,5个静态资源位置的优先级依次降低! 但是一般情况下,Spring Boot项目不需要webapp目录,所以在第5个”/“可以暂时不考虑哟 ~ classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/pulic/ / 扩 : 如果你使用的是Intellij IDEA开发工具,记得设置目录类型哟 ! 自定义策略如果默认的静态资源过滤策略不能满足开发需求,也可以自定义资源过滤策略,自定义静态资源过滤策略有如下两种方式 : 在配置文件中定义 Java编码定义 第一种方式示例 : 可以在application.properties中直接定义过滤规则(第一行)和静态资源位置(第二行),示例代码如下 :12spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/ 文件的上传简介 : 多数文件上传都是通过表单形式提交给服务器的,因此,要实现文件上传功能就需要提供一个上传文件的表单,而此表单必须满足以下三个条件. form表单的method的属性设置为post form表单的enctype属性设置为multipart/form-data 提供&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;的文件上传输入框 在Spring Boot中可以根据需要在application.properties中对上传的文件进行详细的配置,示例代码如下 :123456spring.servlet.multipart.enabled=truespring.servlet.multipart.file-size-threshold=0spring.servlet.multipart.location=D://upload//photospring.servlet.multipart.max-file-size=5MBspring.servlet.multipart.max-request-size=10MBspring.servlet.multipart.resolve-lazily=false 第一行: 设置是否开启文件上传支持,默认为true 第二行: 设置文件写入磁盘的阈值,默认为0 第三行: 指定上传文件的临时保存位置 第四行: 设置上传的单个文件的最大大小,默认为1MB 第五行: 设置多文件上传时文件的总大小,默认为10MB 第六行: 设置文件是否延迟解析,默认为false 示例程序upload.html : 上传文件页面123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 验证表单信息 --&gt; &lt;script type=\"text/javascript\"&gt; function check() &#123; var file = document.getElementById(\"file\").value; if (file.length === 0 || file === \"\") &#123; alert(\"请选择需要上传的文件 !\"); return false; &#125; return true; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"../fileUpload\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return check()\"&gt; 请选择文件 &lt;input id=\"file\" type=\"file\" name=\"uploadfile\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 操控文件的控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pers.huangyuhui.web.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.UUID;/** * @project: web-servlet * @description: 操控文件的控制器 * @author: 黄宇辉 * @date: 6/26/2019-4:34 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@RestControllerpublic class FileController &#123; /** * @description: 上传文件 * @param: uploadfile * @param: request * @date: 2019-06-26 5:00 PM * @return: java.lang.String */ @RequestMapping(\"/fileUpload\") public String handleFormUpload(MultipartFile uploadfile, HttpServletRequest request) &#123; if (!uploadfile.isEmpty() &amp;&amp; uploadfile.getSize() &gt; 0) &#123; //获取上传文件的原始名称 final String originFileName = uploadfile.getOriginalFilename(); //指定上传文件的保存目录 final String dirPath = request.getServletContext().getRealPath(\"/upload/photo/\"); //若保存文件的目录不存在,则创建该目录 File file = new File(dirPath); if (!file.exists()) &#123; file.mkdirs(); &#125; //使用UUID重命名文件名称(uuid__原始文件名称) final String newFileName = UUID.randomUUID() + \"__\" + originFileName; try &#123; //将上传的文件保存到目标目录下 uploadfile.transferTo(new File(dirPath + newFileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"success to upload the file !\"; &#125; return \"fail to upload the file !\"; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Hi Redis ~","slug":"Hi-Redis","date":"2019-06-25T08:13:48.000Z","updated":"2019-06-25T10:44:06.840Z","comments":true,"path":"2019/06/25/Hi-Redis/","link":"","permalink":"http://yoursite.com/2019/06/25/Hi-Redis/","excerpt":"","text":"学习笔记 : 拥抱Redis ~简介 : Redis(REmote DIctionary Server)是一个非常流行的基于内存的轻量级键值数据库(key-value database). 严格的说与其把Redis称为一种数据库,不如把它称为一种数据服务器更为恰当(https://matt.sh/thinking-in-redis-part-one). Redis原生地在内存中实现了多种类型的数据结构,并提供了操作这些数据结构的多种API. 更加重要的是,作为一个需要长期运行的数据库存储服务,Redis还提供了高性能命令处理,高可靠性/扩展性的架构及数据持久化等特性 . 微软开源技术小组(Microsoft Open Technologies group)曾经维护了一个Windows的Redis发行版(😅小哥的联想小新潮中Ubuntu系统好久没玩过了啊,要不先在Windows系统下学习Redis吧, (#→⌒→)都是借口,大懒蛋 ~) : https://github.com/microsoftarchive/redis/releases Windows-Redis安装文件说明 redis.windows.conf —redis的配置文件:将redis作为普通软件使用的配置 redis.windows-service.conf —redis的配置文件:将redis作为系统服务的配置 redis-benchmark.exe —测试工具:测试redis的读写性能情况 redis-check-aof.exe —aof 修复检查日志 redis-cli.exe —redis客户端程序 redis-server.exe —redis服务器程序 Redis临时服务 进入Redis安装包目录,启动Redis临时服务的命令为 : redis-server redis.windows.conf ,通过该命令可以创建Redis临时服务,既Services列表中不会出现Redis的服务名及其状态,关闭从此窗口既关闭Redis服务. 1234567891011121314151617181920212223E:\\MS-Redis\\Redisλ redis-server.exe redis.windows.conf _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.100 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 3796 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos;[3796] 25 Jun 17:20:55.403 # Server started, Redis version 3.2.100[3796] 25 Jun 17:20:55.403 * DB loaded from disk: 0.000 seconds[3796] 25 Jun 17:20:55.403 * The server is now ready to accept connections on port 6379 启动Redis服务后再开启一个cmder窗口,运行客户端程序 123456E:\\MS-Redis\\Redisλ redis-cli.exe # 运行客户端程序的命令127.0.0.1:6379&gt; set firstKey HelloRedis~OK127.0.0.1:6379&gt; get firstKey&quot;HelloRedis~&quot; Redis默认服务安装进入Redis安装包目录,执行将Redis注册为服务的命令,执行该命令后Services列表中将出现Redis服务,但此时该服务并非启动状态,需要执行Redis启动命令来启动服务,启动服务后,即可运行客户端程序哟 ~12345678910111213141516171819202122E:\\MS-Redis\\Redis λ redis-server --service-install redis.windows.conf # 将Redis注册为服务的命令E:\\MS-Redis\\Redisλ redis-server --service-start # 启动服务命令[18704] 25 Jun 17:55:33.957 # Redis service successfully started.E:\\MS-Redis\\Redisλ redis-cli.exe # 运行客户端程序的命令127.0.0.1:6379&gt; set firstKey helloRedis~OK127.0.0.1:6379&gt; get firstKey&quot;helloRedis~&quot;127.0.0.1:6379&gt; exit # 退出E:\\MS-Redis\\Redisλ redis-server --service-stop # 停止命令命令[7784] 25 Jun 18:09:43.467 # Redis service successfully stopped.E:\\MS-Redis\\Redisλ redis-server --service-uninstall # 卸载服务命令[11968] 25 Jun 18:13:44.417 # Redis service successfully uninstalled. 参考书籍 : Redis 4.x CookBook ——黄鹏程,王左非 · 著","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Hi Spring Boot ~","slug":"Hi-Spring-Boot","date":"2019-06-23T14:18:06.000Z","updated":"2019-06-24T14:51:53.363Z","comments":true,"path":"2019/06/23/Hi-Spring-Boot/","link":"","permalink":"http://yoursite.com/2019/06/23/Hi-Spring-Boot/","excerpt":"","text":"学习笔记 : 拥抱Spring Boot简介 : 随着注解的功能增强,尤其是Servlet 3.0规范的提出,Web容器可以脱离web.xml的部署,使得Web容器完全可以基于注解开发,对于Spring 3.x和Spring 4.x的版本注解功能越来越强大,对于XML的依赖越来越少,到了4.x的版本后甚至可以完全脱离XML,因此在Spring中使用注解开发占据了主流的地位. 于此同时,Pivotal团队在原有Spring基础上主要通过注解的方式继续简化了Spring框架的开发,他们基于Spring框架开发了Spring Boot,所以Spring Boot并非是代替Spring框架,而是让Spring框架更加容易使用哟 ~ Spring Boot的优点 创建独立的Spring应用程序 嵌入的Tomcat,Jetty或Undertow,无须部署WAR文件 允许通过Maven来根据需要获取starter 尽可能地自动配置Spring 提供生产就绪型功能,如指标,健康检查和外部配置 绝对没有代码生成,对XML没有要求配置 第一个Spring Boot程序 DemoApplication.java : Spring boot启动类 12345678910111213package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; MyController.java : Spring mvc控制器 123456789101112131415161718192021package com.example.demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @project: first-spring-boot * @description: 自定义控制器 * @author: 黄宇辉 * @date: 6/23/2019-9:59 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@RestControllerpublic class MyController &#123; @GetMapping(\"/hello\") public String hello() &#123; return \"Hi Spring Boot! it's so simple ~\"; &#125;&#125; 启动项目的方式有三种,如下所示. 启动成功后在浏览器中输入:http://localhost:8080/hello即可看到如下图的运行结果. 使用Maven命令运行项目 : mvn spring-boot:run 直接运行DemoApplication.java中的main方法 打包运行 : 将Spring boot打成jar包后使用mvn package运行 推荐书籍 深入浅出Spring Boot 2.x ——杨开振 · 著 Spring Boot+Vue全栈开发实战 ——王松 · 著","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"How to support full Unicode in MySQL databases","slug":"How-to-support-full-Unicode-in-MySQL-databases","date":"2019-06-23T00:28:41.000Z","updated":"2019-06-23T01:05:01.356Z","comments":true,"path":"2019/06/23/How-to-support-full-Unicode-in-MySQL-databases/","link":"","permalink":"http://yoursite.com/2019/06/23/How-to-support-full-Unicode-in-MySQL-databases/","excerpt":"","text":"How to support full Unicode in MySQL databases · Mathias Bynens😂Alternative title: The things we do to store U+1F4A9 PILE OF POO (💩) correctly. Are you using MySQL’s utf8 charset in your databases? In this write-up I’ll explain why you should switch to utf8mb4 instead, and how to do it. UTF-8The UTF-8 encoding can represent every symbol in the Unicode character set, which ranges from U+000000 to U+10FFFF. That’s 1,114,112 possible symbols. (Not all of these Unicode code points have been assigned characters yet, but that doesn’t stop UTF-8 from being able to encode them.) UTF-8 is a variable-width encoding; it encodes each symbol using one to four 8-bit bytes. Symbols with lower numerical code point values are encoded using fewer bytes. This way, UTF-8 is optimized for the common case where ASCII characters and other BMP symbols (whose code points range from U+000000 to U+00FFFF) are used — while still allowing astral symbols (whose code points range from U+010000 to U+10FFFF) to be stored. MySQL’s utf8For a long time, I was using MySQL’s utf8 charset for databases, tables, and columns, assuming it mapped to the UTF-8 encoding described above. By using utf8, I’d be able to store any symbol I want in my database — or so I thought. While writing about JavaScript’s internal character encoding, I noticed that there was no way to insert the U+1D306 TETRAGRAM FOR CENTRE (𝌆) symbol into the MySQL database behind this site. The column I was trying to update had the utf8_unicode_ci collation, and the connection charset was set to utf8. 123456789101112131415# just to emphasize that the connection charset is set to `utf8`mysql&gt; SET NAMES utf8; Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE database_name.table_name SET column_name = &apos;foo𝌆bar&apos; WHERE id = 9001;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; SELECT column_name FROM database_name.table_name WHERE id = 9001;+-------------+| column_name |+-------------+| foo |+-------------+1 row in set (0.00 sec) The content got truncated at the first astral Unicode symbol, in this case 𝌆 — so, attempting to insert foo𝌆bar actually inserted foo instead, resulting in data loss (and possibly introducing security issues; see below). MySQL returned a warning message, too: 1234567mysql&gt; SHOW WARNINGS;+---------+------+------------------------------------------------------------------------------+| Level | Code | Message |+---------+------+------------------------------------------------------------------------------+| Warning | 1366 | Incorrect string value: &apos;\\xF0\\x9D\\x8C\\x86&apos; for column &apos;column_name&apos; at row 1 |+---------+------+------------------------------------------------------------------------------+1 row in set (0.00 sec) Turns out MySQL’s utf8 charset only partially implements proper UTF-8 encoding. It can only store UTF-8-encoded symbols that consist of one to three bytes; encoded symbols that take up four bytes aren’t supported. Since astral symbols (whose code points range from U+010000 to U+10FFFF) each consist of four bytes in UTF-8, you cannot store them using MySQL’s utf8 implementation. This doesn’t just affect the 𝌆 character, but more important symbols like U+01F4A9 PILE OF POO (💩) as well. In total, that’s 1,048,575 possible code points you can’t use. In fact, MySQL’s utf8 only allows you to store 5.88% ((0x00FFFF + 1) / (0x10FFFF + 1)) of all possible Unicode code points. Proper UTF-8 can encode 100% of all Unicode code points. As shown above, this behavior can lead to data loss, but it gets worse — it can result in security vulnerabilities.MySQL’s utf8 encoding is awkwardly named, as it’s different from proper UTF-8 encoding. It doesn’t offer full Unicode support, which can lead to data loss or security vulnerabilities. MySQL’s utf8mb4Luckily, MySQL 5.5.3 (released in early 2010) introduced a new encoding called utf8mb4 which maps to proper UTF-8 and thus fully supports Unicode, including astral symbols. Switching from MySQL’s utf8 to utf8mb4 Step 1: Create a backupCreate a backup of all the databases on the server you want to upgrade. Safety first! Step 2: Upgrade the MySQL serverUpgrade the MySQL server to v5.5.3+, or ask your server administrator to do it for you. Step 3: Modify databases, tables, and columnsChange the character set and collation properties of the databases, tables, and columns to use utf8mb4 instead of utf8. For each database :ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; For each table :ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; For each column :ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; (Don’t blindly copy-paste this! The exact statement depends on the column type, maximum length, and other properties. The above line is just an example for a VARCHAR column.)Since utf8mb4 is fully backwards compatible with utf8, no mojibake or other forms of data loss should occur. (But you have a backup, right?) Step 4: Check the maximum length of columns and index keysThis is probably the most tedious part of the whole upgrading process. When converting from utf8 to utf8mb4, the maximum length of a column or index key is unchanged in terms of bytes. Therefore, it is smaller in terms of characters, because the maximum length of a character is now four bytes instead of three. For example, a TINYTEXT column can hold up to 255 bytes, which correlates to 85 three-byte or 63 four-byte characters. Let’s say you have a TINYTEXT column that uses utf8 but must be able to contain more than 63 characters. Given this requirement, you can’t convert this column to utf8mb4 unless you also change the data type to a longer type such as TEXT — because if you’d try to fill it with four-byte characters, you’d only be able to enter 63 characters, but not more. The same goes for index keys. The InnoDB storage engine has a maximum index length of 767 bytes, so for utf8 or utf8mb4 columns, you can index a maximum of 255 or 191 characters, respectively. If you currently have utf8 columns with indexes longer than 191 characters,you will need to index a smaller number of characters when using utf8mb4. (Because of this, I had to change some indexed VARCHAR(255) columns to VARCHAR(191).) Section 10.1.11 of the MySQL 5.5 Reference Manual has some more information on this. Step 5: Modify connection, client, and server character setsIn your application code, set the connection character set to utf8mb4. This can be done by simply replacing any variants of SET NAMES utf8 with SET NAMES utf8mb4. If your old SET NAMES statement specified the collation, make sure to change that as well, e.g. SET NAMES utf8 COLLATE utf8_unicode_ci becomes SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci. Make sure to set the client and server character set as well. I have the following in my MySQL configuration file (/etc/my.cnf):12345678910[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci You can easily confirm these settings work correctly:12345678910111213141516mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE &apos;character\\_set\\_%&apos; OR Variable_name LIKE &apos;collation%&apos;;+--------------------------+--------------------+| Variable_name | Value |+--------------------------+--------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || collation_connection | utf8mb4_unicode_ci || collation_database | utf8mb4_unicode_ci || collation_server | utf8mb4_unicode_ci |+--------------------------+--------------------+10 rows in set (0.00 sec) As you can see, all the relevant options are set to utf8mb4, except for character_set_filesystem which should be binary unless you’re on a file system that supports multi-byte UTF-8-encoded characters in file names, and character_set_system which is always utf8 and can’t be overridden. Note: The default character set and collation can be configured at some other levels as well. Step 6: Repair and optimize all tablesAfter upgrading the MySQL server and making the necessary changes explained above, make sure to repair and optimize all databases and tables. I didn’t do this right away after upgrading (I didn’t think it was necessary, as everything seemed to work fine at first glance), and ran into some weird bugs where UPDATE statements didn’t have any effect, even though no errors were thrown. You could run the following MySQL queries for each table you want to repair and optimize:123# For each tableREPAIR TABLE table_name;OPTIMIZE TABLE table_name; Luckily, this can easily be done in one go using the command-line mysqlcheck utility:1$ mysqlcheck -u root -p --auto-repair --optimize --all-databases This will prompt for the root user’s password, after which all tables in all databases will be repaired and optimized. SummaryNever use utf8 in MySQL — always use utf8mb4 instead. Updating your databases and code might take some time, but it’s definitely worth the effort. Why would you arbitrarily limit the set of symbols that can be used in your database? Why would you lose data every time a user enters an astral symbol as part of a comment or message or whatever it is you store in your database? There’s no reason not to strive for full Unicode support everywhere. Do the right thing, and use utf8mb4. 🍻 ヾ(￣▽￣)Bye~Bye~ 🙂expressing thanks : https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"SSM项目:学生管理系统","slug":"SSM项目-学生管理系统","date":"2019-06-22T13:48:14.000Z","updated":"2019-06-30T12:57:17.846Z","comments":true,"path":"2019/06/22/SSM项目-学生管理系统/","link":"","permalink":"http://yoursite.com/2019/06/22/SSM项目-学生管理系统/","excerpt":"","text":"a simple student management system , created by SSM framework ~ 我的第二个SSM小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址 : https://github.com/YUbuntu0109/SSM-SMS 项目概述一个基于SSM的学生管理系统 : 代码注释详细,逻辑结构清晰,非常具有参考,学习价值哟 !数据库中默认的管理员身份信息 : 账户名 : 黄宇辉 , 密码 demo0109 用户权限介绍 管理员 : 具有所有管理模块的操控权限 教师 : 仅具有学生信息管理模块的所有权限,且在教师信息管理模块中只具有查询及添加信息的权限 学生 : 仅具有学生信息管理模块的查询及添加信息的权限 项目截图 (管理员身份登录) 用户登录页面 系统主页面 管理员信息管理页面 学生信息管理页面 教师信息管理页面 年级信息管理页面 班级信息管理页面 个人信息管理页面 项目截图 (教师身份登录) 教师仅具有学生信息管理模块的所有权限,且在教师信息管理模块中只具有查询及添加信息的权限 项目截图 (学生身份登录) 学生仅具有学生信息管理模块的查询及添加信息的权限 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149│ .gitattributes│ LICENSE│ README.md│├─database file│ ssm_sms.sql│├─demonstration_picture│ SMS-ClassInfo-view.PNG│ SMS-GradeInfo-view.PNG│ SMS-Login-view.PNG│ SMS-ModifyPwd-view.PNG│ SMS-Student-permission.PNG│ SMS-StudentInfo-view.PNG│ SMS-Teacher-permission.PNG│ SMS-TeacherInfo-view.PNG│ SSM-AdminInfo-view.PNG│ SSM-Main-view.PNG│└─sms │ pom.xml │ ├─.idea │ │(略..) │ │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─sms │ ├─bean │ │ Admin.java │ │ Clazz.java │ │ Grade.java │ │ LoginForm.java │ │ Student.java │ │ Teacher.java │ │ │ ├─controller │ │ AdminController.java │ │ ClazzController.java │ │ CommonController.java │ │ GradeController.java │ │ StudentController.java │ │ SystemController.java │ │ TeacherController.java │ │ │ ├─dao │ │ AdminMapper.java │ │ ClazzMapper.java │ │ GradeMapper.java │ │ StudentMapper.java │ │ TeacherMapper.java │ │ │ ├─interceptor │ │ LoginInterceptor.java │ │ │ ├─service │ │ │ AdminService.java │ │ │ ClazzService.java │ │ │ GradeService.java │ │ │ StudentService.java │ │ │ TeacherService.java │ │ │ │ │ └─impl │ │ AdminServiceImpl.java │ │ ClazzServiceImpl.java │ │ GradeServiceImpl.java │ │ StudentServiceImpl.java │ │ TeacherServiceImpl.java │ │ │ └─util │ CreateVerifiCodeImage.java │ UploadFile.java │ ├─resource │ ├─database-conf │ │ c3p0.properties │ │ │ ├─mapper │ │ AdminMapper.xml │ │ ClazzMapper.xml │ │ GradeMapper.xml │ │ StudentMapper.xml │ │ TeacherMapper.xml │ │ │ ├─mybatis-conf │ │ mybatis-config.xml │ │ │ └─spring-conf │ applicationContext.xml │ springmvc-config.xml │ └─webapp │ index.jsp │ ├─image │ └─portrait │ default_admin_portrait.png │ default_student_portrait.png │ default_teacher_portrait.png │ ├─static │ ├─easyui │ │ │ │ │ ├─css │ │ │ │ │ ├─js │ │ │ │ │ └─themes │ │ │ │ │ └─h-ui │ │(略..) │ │ │ └─WEB-INF │ web.xml │ └─view ├─admin │ adminList.jsp │ ├─clazz │ clazzList.jsp │ ├─common │ settings.jsp │ ├─error │ 404.jsp │ 500.jsp │ ├─grade │ gradeList.jsp │ ├─student │ studentList.jsp │ ├─system │ intro.jsp │ login.jsp │ main.jsp │ └─teacher teacherList.jsp 项目文件说明-数据库文件1ssm_sms.sql 项目文件说明-数据库配置信息1c3p0.properties 项目文件说明-H-ui 前端框架1h-ui/ 项目文件说明-EasyUI 前端框架1easyui/ 项目文件说明-Spring 核心配置文件1applicationContext.xml 项目文件说明-Spring MVC 核心配置文件1springmvc-config.xml 项目文件说明-MyBatis 核心配置文件1mybatis-config.xml 项目文件说明-Mapper 接口映射文件1mapper/ 项目文件说明-用户默认头像1portrait/ 数据库ER图:sweat_smile: 数据库设计待优化 : 数据表之间的并没有设置约束关系哟,好尴尬呢··· Jar包依赖关系图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"SSM整合项目:简易同学录","slug":"SSM整合项目-简易同学录","date":"2019-06-12T11:06:17.000Z","updated":"2019-06-12T11:37:57.027Z","comments":true,"path":"2019/06/12/SSM整合项目-简易同学录/","link":"","permalink":"http://yoursite.com/2019/06/12/SSM整合项目-简易同学录/","excerpt":"","text":"A Simple Alumnn Book 我的第一个SSM小项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址 : https://github.com/YUbuntu0109/SSM-CURD-Alumni 项目概述 一个简单的,基于SSM的同学录小项目,通过本项目可以学习SSM的整合及CURD操作的基本思路,同时也可以帮助你学习Intellij IEAD开发利器的使用哟,可以说非常适合初学SSM的同学啦~ 代码注释非常详细,思路也很清晰 :12345678910111213141516171819202122232425262728293031323334 @Autowired //注入业务对象 private FriendService friendService; //存储预返回给页面的对象数据 private Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); /** * @description: 分页查询: 获取所有好友信息,分页后返回给页面 * @param: page 当前页数 * @param: rows 每页行数 * @date: 2019-06-06 10:10 AM * @return: java.util.List&lt;pers.huangyuhui.ssm.crud.bean.Friend&gt; */ @RequestMapping(\"/getFriendList\") @ResponseBody //将Map转化为JSON数据 public Map&lt;String, Object&gt; getFriendlist(Integer page, Integer rows) &#123; //设置每页的记录数 PageHelper.startPage(page, rows); //获取所有好友信息 List&lt;Friend&gt; list = friendService.selectAll(); //封装查询结果 PageInfo&lt;Friend&gt; pageInfo = new PageInfo&lt;&gt;(list); //获取总记录数 long total = pageInfo.getTotal(); //获取当前页数据列表 List&lt;Friend&gt; friendList = pageInfo.getList(); //存储对象数据 result.put(\"total\", total); result.put(\"rows\", friendList); return result; &#125; 项目截图 欢迎页面 好友列表 IDEA截图 目录结构 目录类型(重点呦:IDEA可不同与Eclipse !) Jar包依赖关系 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869└─SSM-CURD-Alumni │ LICENSE │ README.md │ ├─database │ ssm.sql │ ├─demonstration_picture │ Intellij-IDEA-Folder-Alumni.PNG │ Intellij-IDEA-Project-Alumni.PNG │ SSM-CRUD-Alumni-Jar.png │ SSM-CURD-Alumni01.PNG │ SSM-CURD-Alumni02.PNG │ └─ssm_crud2 │ pom.xml │ ssm_crud_alumni.iml │ ├─.idea │ │(略..) │ │ └─src └─main ├─java │ └─pers │ └─huangyuhui │ └─ssm │ └─crud │ ├─bean │ │ Friend.java │ │ │ ├─controller │ │ FriendController.java │ │ │ ├─dao │ │ FriendMapper.java │ │ │ └─service │ │ FriendService.java │ │ │ └─impl │ FriendServiceImpl.java │ ├─resource │ ├─database-conf │ │ c3p0.properties │ │ │ ├─mapper │ │ FriendMapper.xml │ │ │ ├─mybatis-conf │ │ mybatis-config.xml │ │ │ └─spring-conf │ applicationContext.xml │ springmvc-config.xml │ └─webapp │ friendInfo.jsp │ index.jsp │ ├─static │ └─easyui │ │(略..) │ │ └─WEB-INF web.xml 项目结构说明-数据库文件1database/ssm.sql 项目结构说明-数据库配置信息1ssm_crud2/src/main/resource/database-conf/c3p0.properties 项目结构说明-EasyUI Framework1ssm_crud2/src/main/webapp/static/easyui/ 项目结构说明-Spring 核心配置文件1ssm_crud2/src/main/resource/spring-conf/applicationContext.xml 项目结构说明-Spring MVC 核心配置文件1ssm_crud2/src/main/resource/spring-conf/springmvc-config.xml 项目结构说明-MyBatis 核心配置文件1ssm_crud2/src/main/resource/mybatis-conf/mybatis-config.xml 项目结构说明-Mapper 接口映射文件1ssm_crud2/src/main/resource/mapper/FriendMapper.xml","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"Java web项目:学生管理系统","slug":"Java-web项目-学生管理系统","date":"2019-06-12T11:04:40.000Z","updated":"2019-06-12T11:37:37.006Z","comments":true,"path":"2019/06/12/Java-web项目-学生管理系统/","link":"","permalink":"http://yoursite.com/2019/06/12/Java-web项目-学生管理系统/","excerpt":"","text":"Student Information Management System 我的第一个Java web项目 （づ￣3￣）づ╭❤～ 赶紧来学习吧 ! 期待你的issues哟(っ•̀ω•́)っ✎⁾⁾~ 该项目地址, : https://github.com/YUbuntu0109/Student-Information-Management-System 项目概述项目阶段介绍 第一阶段：+信息管理功能 :white_check_mark: 第二阶段：+成绩管理功能 :x: 用户权限介绍 管理员 : 具有所有管理模块的权限 教师 : 具有学生管理信息模块的所有权限,但在教师信息管理模块中只具有查询并修改个人信息的权限 学生 : 只具有查询并修改个人信息的权限 设置权限的核心示例代码如下 :12345678// 用户权限设置: 如果当前用户类型为教师,则将其权限设置为仅能查询个人信息if (userType == 3) &#123; TeacherInfo currentTeacherInfo = (TeacherInfo) request.getSession().getAttribute(\"userInfo\"); teacherInfo.setId(currentTeacherInfo.getId());&#125;// 获取分页后的教师列表信息List&lt;TeacherInfo&gt; teacherList = teacherDao.getTeacherList(teacherInfo, new Paging(currentPage, pageSize)); 系统截图 登录页面 系统主页 学生信息管理页面 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124│└─student_information_management_system │ │ ├─build │ └─classes │ │ databaseConfig.properties │ │ ├─database │ SMS.sql │ ├─src │ │ databaseConfig.properties │ │ │ └─pers │ └─huangyuhui │ └─sms │ ├─dao │ │ AdminDao.java │ │ BasicDao.java │ │ ClazzDao.java │ │ StudentDao.java │ │ TeacherDao.java │ │ │ ├─filter │ │ LoginFilter.java │ │ │ ├─model │ │ AdminInfo.java │ │ ClazzInfo.java │ │ Paging.java │ │ StudentInfo.java │ │ TeacherInfo.java │ │ │ ├─servlet │ │ ClazzManagementServlet.java │ │ LoginServlet.java │ │ OutVerifiCodeServlet.java │ │ PersonalManagementServlet.java │ │ PhotoServlet.java │ │ StuManagementServlet.java │ │ SysMainInterfaceServlet.java │ │ TeacherManagementServlet.java │ │ │ └─util │ CreateVerifiCodeImage.java │ DbConfig.java │ DbUtil.java │ StringUtil.java │ └─WebContent │ index.jsp │ refresh.jsp │ ├─easyui │ │ │ ├─css │ │ │ ├─js │ │ │ └─themes │ │ ├─h-ui │ │ │ ├─css │ │ │ ├─images │ │ │ ├─js │ │ │ ├─lib │ │ │ └─skin │ │ ├─META-INF │ MANIFEST.MF │ ├─resource │ └─image │ default_portrait.jpg │ └─WEB-INF │ web.xml │ ├─lib │ commons-beanutils-1.8.3.jar │ commons-collections-3.2.1.jar │ commons-fileupload-1.2.1.jar │ commons-io-1.4.jar │ commons-lang-2.5.jar │ commons-logging-1.1.1.jar │ ezmorph-1.0.6.jar │ FilelLoad.jar │ json-lib-2.3-jdk15.jar │ jsonplugin-0.34.jar │ jstl.jar │ mysql-connector-java-8.0.11.jar │ standard.jar │ └─view │ login.jsp │ ├─class │ classList.jsp │ ├─error │ 404.jsp │ 500.jsp │ ├─management │ personalView.jsp │ ├─student │ studentList.jsp │ ├─system │ main.jsp │ welcome.jsp │ └─teacher teacherList.jsp 项目文件说明-数据库文件1SMS.sql 项目文件说明-数据库配置信息1databaseConfig.properties 项目文件说明-H-ui 前端框架1h-ui/ 项目文件说明-EasyUI 前端框架1easyui/ 数据库ER图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://yoursite.com/tags/EasyUI/"}]},{"title":"DBUtils","slug":"DBUtils","date":"2019-05-30T09:28:41.000Z","updated":"2019-06-08T07:21:43.087Z","comments":true,"path":"2019/05/30/DBUtils/","link":"","permalink":"http://yoursite.com/2019/05/30/DBUtils/","excerpt":"","text":"学习笔记 : DBUtils工具简介 : 为了更加简单地使用JDBC,Apache组织提供了一个工具类库commons-dbutils,它是操作数据库的一个组件,实现了对JDBC的简单封装,可以在不影响性能的情况下极大地简化JDBC的编码工作量. API 介绍简介 : commons-dbutils的核心是两个类为DbUtils,QueryRunner,和一个接口ResultSetHandler. org.apache.commons.dbutils.DbUtils : 该类主要为如何关闭数据库连接,装载JDBC驱动程序之类的常规工作提供静态方法. org.apache.commons.dbutils.QueryRunner : 该类简化了执行SQL语句的代码,它与ResultSetHandler组合在一起就能完成大部分的数据库操作,大大减少编码量. org.apache.commons.dbutils.ResultSetHandler : 该接口用于处理ResultSet结果集,它可以将结果集中的数据转换为不同的形式. CURE 案例 数据表信息 1234567-- auto-generated definition by Intellij IDEAcreate table user( id int auto_increment primary key, name varchar(15) null, password varchar(20) null) C3P0配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置: 在没有指定配置时默认使用该配置创建c3p0数据源对象 --&gt; &lt;default-config&gt; &lt;property name=\"user\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"password\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/test?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;30000&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxIdleTime\"&gt;600&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;1&lt;/property&gt; &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 自定义配置 --&gt; &lt;named-config name=\"yu\"&gt; &lt;property name=\"user\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"password\"&gt;xxxxxx&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/test?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"initiaPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 数据源工具类 1234567891011121314151617181920212223242526272829package pers.huangyuhui.dbutils.utils;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;/** * @project: dbutils * @package: pers.huangyuhui.dbutils.utils * @description: 创建数据源 * @author: HuangYuhui * @date: 5/31/2019-7:00 PM * @version: 1.0 */public class C3P0Utils &#123; private static DataSource dataSource; //创建数据源 static &#123; dataSource = new ComboPooledDataSource(\"yu\"); &#125; //获取数据源 public static DataSource getDataSource() &#123; return dataSource; &#125;&#125; Java Bean : 存储用户信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.huangyuhui.dbutils.bean;/** * @project: dbutils * @package: pers.huangyuhui.dbutils.bean * @description: 用户信息 * @author: HuangYuhui * @date: 5/31/2019-7:13 PM * @version: 1.0 */public class User &#123; private Integer id; private String name; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; DAO层 : 封装数据库的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package pers.huangyuhui.dbutils.dao;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import pers.huangyuhui.dbutils.bean.User;import pers.huangyuhui.dbutils.utils.C3P0Utils;import javax.sql.DataSource;import java.sql.SQLException;import java.util.List;/** * @project: dbutils * @package: pers.huangyuhui.dbutils * @description: 数据库的基本操作 * @author: HuangYuhui * @date: 5/31/2019-7:07 PM * @version: 1.0 */public class DBUtilsDao &#123; //获取数据源 private static DataSource dataSource = C3P0Utils.getDataSource(); //创建queryRunner对象 private static QueryRunner queryRunner = new QueryRunner(dataSource); //sql private String SQL_SELECT = \"select id,name,password from user where id = ?\"; private String SQL_UPDATE = \"update user set name=?,password=? where id=?\"; private String SQL_INSERT = \"insert into user(name,password) values(?,?)\"; private String SQL_SELECTALL = \"select id,name,password from user\"; private String SQL_DELETE = \"delete from user where id=?\"; // TODO: 6/8/2019 查询所有用户信息 public List selectAll() throws SQLException &#123; //获取用户列表 List&lt;User&gt; list = queryRunner.query(SQL_SELECTALL, new BeanListHandler&lt;User&gt;(User.class)); return list; &#125; // TODO: 6/8/2019 查询单个用户信息 public User select(int id) throws SQLException &#123; //获取用户信息 User user = queryRunner.query(SQL_SELECT, new BeanHandler&lt;&gt;(User.class), new Object[]&#123;id&#125;); return user; &#125; // TODO: 6/8/2019 添加用户信息 public boolean insert(User user) throws SQLException &#123; //判断是否添加成功 int num = queryRunner.update(SQL_INSERT, new Object[]&#123;user.getName(), user.getPassword()&#125;); if (num &gt; 0) &#123; return true; &#125; return false; &#125; // TODO: 6/8/2019 修改用户信息 public boolean update(User user) throws SQLException &#123; int num = queryRunner.update(SQL_UPDATE, new Object[]&#123;user.getName(), user.getPassword(), user.getId()&#125;); if (num &gt; 0) &#123; return true; &#125; return false; &#125; // TODO: 6/8/2019 删除用户信息 public boolean delete(int id) throws SQLException &#123; int num = queryRunner.update(SQL_DELETE, id); if (num &gt; 0) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package pers.huangyuhui.dbutils.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.dbutils.bean.User;import pers.huangyuhui.dbutils.dao.DBUtilsDao;import java.sql.SQLException;import java.util.List;/** * @project: dbutils * @description: 测试数据库的基本操作 * @author: HuangYuhui * @date: 5/31/2019-7:45 PM * @version: 1.0 */public class DBUtilsDaoTest &#123; private static User user; private static DBUtilsDao dbUtilsDao; @BeforeClass public static void init() &#123; user = new User(); dbUtilsDao = new DBUtilsDao(); &#125; @Ignore @Test // TODO: 6/8/2019 测试添加用户操作 public void insertTest() throws SQLException &#123; user.setName(\"YUbuntu0109\"); user.setPassword(\"MyPassword\"); if (dbUtilsDao.insert(user)) &#123; System.out.println(\"success to insert a user information !\"); &#125; else &#123; System.out.println(\"fail to insert a new user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试修改用户信息操作 public void updateTest() throws SQLException &#123; user.setId(1); user.setName(\"YUbuntu0109-1\"); user.setPassword(\"MyPassword-1\"); if (dbUtilsDao.update(user)) &#123; System.out.println(\"success to update the user information !\"); &#125; else &#123; System.out.println(\"fail to update the user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试删除用户操作 public void deleteTest() throws SQLException &#123; if (dbUtilsDao.delete(1)) &#123; System.out.println(\"success to delete the user information !\"); &#125; else &#123; System.out.println(\"fail to delete the user information !\"); &#125; &#125; @Ignore @Test // TODO: 6/8/2019 测试查询单个用户信息操作 public void selectTest() throws SQLException &#123; System.out.println(dbUtilsDao.select(1)); &#125; @Ignore @Test // TODO: 6/8/2019 测试查询所有用户信息操作 public void selectAllTest() throws SQLException &#123; List users = dbUtilsDao.selectAll(); System.out.println(users); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"Spring MVC之JSON数据交互","slug":"Spring-MVC之JSON数据交互和RESTful支持","date":"2019-05-28T13:03:53.000Z","updated":"2019-06-08T10:02:12.251Z","comments":true,"path":"2019/05/28/Spring-MVC之JSON数据交互和RESTful支持/","link":"","permalink":"http://yoursite.com/2019/05/28/Spring-MVC之JSON数据交互和RESTful支持/","excerpt":"","text":"学习笔记 : Spring MVC之JSON数据交互JSON 数据交互简介 : JSON(JavaScript Object Notation,JS对象标记) 是一种轻量级的数据交换格式. 它基于JavaScript的一个子集,使用了C,C++,C#,Java,JavaScript,Perl,Python等其它语言的约定,采用完全独立于编程语言的文本格式来存储和表示数据. 这些特性使JSON称为理性的数据交互语言 ! JSON 数据转换简介 : 为了实现浏览器与控制器Controller之间的数据交互,Spring提供了一个HttpMessageConverter&lt;T&gt;接口来完成此项工作. 该接口主要用于将请求消息中的数据转换为一个T的对象,并将类型为T的对象绑定到请求方法的参数中,或者将对象转换为响应消息传递给浏览器显示. Spring为HttpMessageConverter&lt;T&gt;接口提供了很多实现类,这些实现类可以对不同的类型的数据进行信息转换,其中MappingJackson2HttpMessageConverter是Spring MVC默认处理JSON格式请求响应的实现类. 该实现类利用Jackson开源包读写JSON数据,将Java对象转换为JSON对象和XML文档,同时也可以将JSON对象和XML文档转换为Java对象 ! 示例程序 web.xml : 对Spring mvc的前端控制器等信息进行配置 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Spring MVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定Spring MVC配置文件的路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 服务器启动后立即加载Spring MVC配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-config.xml : Spring mvc配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 定义Spring组件扫描器,指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.controller\"/&gt; &lt;!-- 配置注解驱动 该配置会自动注册RequestMappingHandlerMapping和RequestMappingHandlerAdapter两个Bean, 并提供对读写XML和读写JSON等功能的支持. --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置静态资源的访问路径,此配置中的文件将不被前端控制器所拦截(该目录存放jquery-1.12.4.js) --&gt; &lt;mvc:resources mapping=\"/js/\" location=\"/js/**\"/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; User.java : 用户信息 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.springmvc.bean;/** * @project: springmvc_json * @package: pers.huangyuhui.springmvc.bean * @description: User information * @author: HuangYuhui * @date: 5/31/2019-1:44 PM * @version: 1.0 */public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; index.jsp : 用于测试JSON交互的页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 5/31/2019 Time: 1:46 PM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC&lt;/title&gt; &lt;script src=\"js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function testJson() &#123; //用户表单信息 var username = $(\"#username\").val(); var password = $(\"#password\").val(); $.ajax(&#123; url: \"$&#123;pageContext.request.contextPath&#125;/testJson\", type: \"post\", //data:发送的数据 data: JSON.stringify(&#123;username: username, password: password&#125;), //定义发送请求的数据格式为JSON字符串 contentType: \"application/json;charset=UTF-8\", //定义回调响应的数据格式为JSON字符串 dataType: \"json\", //成功响应的结果 success: function (data) &#123; if (data != null) &#123; alert(\"你输入的用户名:\" + username + \"\\n密码:\" + password); &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; 用户名 &lt;input type=\"text\" name=\"username\" id=\"username\"/&gt;&lt;br&gt; 密码&lt;input type=\"password\" name=\"password\" id=\"password\"&gt;&lt;br&gt; &lt;input type=\"button\" value=\"Test\" onclick=\"testJson()\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; UserController.java : 控制器 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import pers.huangyuhui.springmvc.bean.User;/** * @project: springmvc_json * @package: pers.huangyuhui.springmvc.controller * @description: Controller * @author: HuangYuhui * @date: 5/31/2019-1:39 PM * @version: 1.0 */@Controllerpublic class MyController &#123; /** * @description: 接收页面请求的JSON数据, 并返回JSON格式结果 * @param: user * @date: 2019-06-08 5:34 PM * @return: pers.huangyuhui.springmvc.bean.User */ //@ResponseBody 用于直接返回retrun对象(将Java对象转换为JSON格式的响应数据) //@RequestBody 用于将请求体中的数据绑定到方法的形参上(将JSON格式的请求数据转换为Java对象) @RequestMapping(\"/testJson\") @ResponseBody public User testJson(@RequestBody User user) &#123; //输出接收的JSON格式数据 System.out.println(user); //返回JSON格式的响应 return user; &#125;&#125; 由程序运行的结果(略..)可知,JSON格式的请求数据成功转换为方法中的Java对象,Java对象也成功地转换为了JSON格式的响应数据. RESTful(っ•̀ω•́)っ✎⁾⁾ 略写…(会单独写一个关于RESTful风格的编程笔记哟 ~)","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之文件上传与下载","slug":"Spring-MVC之文件上传与下载","date":"2019-05-28T13:01:46.000Z","updated":"2019-06-17T01:24:10.956Z","comments":true,"path":"2019/05/28/Spring-MVC之文件上传与下载/","link":"","permalink":"http://yoursite.com/2019/05/28/Spring-MVC之文件上传与下载/","excerpt":"","text":"学习笔记 : Spring MVC之文件的上传与下载文件上传简介 : 多数文件上传都是通过表单形式提交给服务器的,因此,要实现文件长传功能后,就需要提供一个文件上传的表单,而表单必须满足以下三个条件. form表单的method的属性设置为post form表单的enctype属性设置为multipart/form-data 提供&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;的文件上传输入框 当客户端form表单的enctype属性为multipart/form-data时,浏览器就会采用二进制流的方式来处理表单数据,服务器端就会对文件上传的请求进行解析处理. Spring MVC为文件上传提供了支持,这种支持是通过MultipartResolver(多部件解析器)对象实现的. MultipartResolver是一个接口对象,需要通过它的实现类CommonsMultipartResolver来完成文件的上传工作,在需要在spring mvc配置文件中定义MultipartResolver接口的Bean即可,其配置方式如下 : springmvc-config.xml 1234567&lt;!-- 配置文件上传解析器:MultipartResolver --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置请求编码格式 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 设置允许上传文件的最大值(10MB),单位为字节 --&gt; &lt;property name=\"maxUploadSize\" value=\"20971520\"/&gt;&lt;/bean&gt; 注意: 因为MultipartResolver接口的实现类CommonsMultipartResolver内部是引用multipartResolver字符串获取该实现类对象并完成文件解析的,所以在配置CommonsMultipartResolver时必须指定该Bean的id为multipartResolver 文件上传案例 web.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Spring MVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定Spring MVC核心配置文件路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使服务器启动后立即加载Spring MVC核心配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springmvc-config.xml : Spring MVC核心配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 定义组件扫描器,指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.file.controller\"/&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 配置文件上传解析器:MultipartResolver --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置请求编码格式 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 设置允许上传文件的最大值(10MB),单位为字节 --&gt; &lt;property name=\"maxUploadSize\" value=\"20971520\"/&gt; &lt;/bean&gt;&lt;/beans&gt; upload.jsp : 文件上传页面 12345678910111213141516171819202122232425262728293031323334353637&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 6/1/2019 Time: 4:01 PM--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;!-- 验证表单信息 --&gt; &lt;script type=\"text/javascript\"&gt; function check() &#123; var name = document.getElementById(\"name\").value; var file = document.getElementById(\"file\").value; if (name === \"\") &#123; alert(\"请填写上传人 !\"); return false; &#125; if (file.length === 0 || file === \"\") &#123; alert(\"请选择上传文件 !\"); return false; &#125; return true; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/fileUpload\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return check()\"&gt; 上传人 &lt;input id=\"name\" type=\"text\" name=\"name\" multiple=\"multiple\"/&gt;&lt;br&gt; 请选择文件 &lt;input id=\"file\" type=\"file\" name=\"uploadfile\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 文件上传控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package pers.huangyuhui.file.controller;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.UUID;/** * @project: file * @description: 文件控制器 * @author: HuangYuhui * @date: 6/1/2019-5:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class FileController &#123; /** * @description: upload the specified file * @param: name 上传人姓名 * @param: uploadfile 上传文件 * @param: request * @date: 2019-06-08 6:20 PM * @return: java.lang.String */ @RequestMapping(\"/fileUpload\") public String handleFormUpload(String name, List&lt;MultipartFile&gt; uploadfile, HttpServletRequest request) &#123; //判断文件是否存在 if (!uploadfile.isEmpty() &amp;&amp; uploadfile.size() &gt; 0) &#123; //遍历文件 for (MultipartFile files : uploadfile) &#123; //获取上传文件的原始名称 String originFileName = files.getOriginalFilename(); //设置上传文件的保存地址目录 String dirPath = request.getServletContext().getRealPath(\"/upload/\"); System.out.println(dirPath); //如果保存文件的地址不存在,则创建该目录 File file = new File(dirPath); if (!file.exists()) &#123; file.mkdirs(); &#125; //使用UUID重新命名上传的文件名称(上传人_uuid_原始文件名称) String newFileName = name + \"_\" + UUID.randomUUID() + \"_\" + originFileName; try &#123; //使用MultipartFile接口的方法将文件上传保存到目标目录下 files.transferTo(new File(dirPath + newFileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return \"success\"; &#125; return \"error\"; &#125;&#125; 注意: upload文件夹是在项目的发布路径中,而非创建的项目所在路径哟 ! 文件下载简介 : Spring MVC提供了一个ResponseEntity类型的对象,使用它可以很方便地定义返回的HttpHeaders与HttpStatus对象,通过对这两个对象的设置,既可完成下载文件时所需对的配置信息. download.jsp : 文件下载页面 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 6/1/2019 Time: 7:18 PM--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;%@ page import=\"java.net.URLEncoder\" %&gt;&lt;%@ page import=\"java.nio.charset.StandardCharsets\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/fileDownload?filename=&lt;%=URLEncoder.encode(\"黄宇辉好可耐.jpg\",StandardCharsets.UTF_8)%&gt;\"&gt; 点击下载图片哟!&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; FileController.java : 文件下载控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package pers.huangyuhui.file.controller;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.UUID;/** * @project: file * @description: 文件操作控制器 * @author: HuangYuhui * @date: 6/1/2019-5:17 PM * @version: 1.0 * @website: https://yubuntu0109.github.io/ */@Controllerpublic class FileController &#123; /** * @description: download the specified file * @param: request * @param: filename * @date: 2019-06-08 6:23 PM * @return: org.springframework.http.ResponseEntity&lt;byte [ ]&gt; */ @RequestMapping(\"/fileDownload\") public ResponseEntity&lt;byte[]&gt; fileDownload(HttpServletRequest request, String filename) throws IOException &#123; //指定要下载的文件的所在路径 String path = request.getServletContext().getRealPath(\"/upload/\"); //创建该文件对象 File file = new File(path + File.separator + filename); //对文件名进行编码,防止中文文件乱码 filename = this.getFileName(request, filename); //设置响应头 HttpHeaders httpHeaders = new HttpHeaders(); //通知浏览器以下载的方式打开文件 httpHeaders.setContentDispositionFormData(\"attachment\", filename); //定义以流的形式下载返回文件数据 //MediaType.APPLICATION_OCTET_STREAM的值为application/octet-stream,既表示以二进制流的形式下载数据 httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM); //使用Spring MVC框架的ResponseEntity对象封装返回的下载数据 //HttpStatus类型代表Http协议中的状态,HttpStatus.OK表示200,既服务器已成功处理了请求 return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), httpHeaders, HttpStatus.OK); &#125; /** * @description: 根据浏览器的不同进行编码设置, 返回编码后的文件名 * @param: request * @param: filename * @date: 2019-06-08 6:24 PM * @return: java.lang.String */ public String getFileName(HttpServletRequest request, String filename) throws UnsupportedEncodingException &#123; //IE不同版本的User-Agent中出现的关键字 String[] IEBrowserkeyWords = &#123;\"MSIE\", \"Trident\", \"Edge\"&#125;; //获取请求头代理信息 String userAgent = request.getHeader(\"User-Agent\"); for (String keyWork : IEBrowserkeyWords) &#123; if (userAgent.contains(keyWork)) &#123; //IE内核浏览器,统一设置为UTF-8编码显示 return URLEncoder.encode(filename, StandardCharsets.UTF_8.name()); &#125; &#125; //火狐等其它浏览器统一设置为ISO-8859-1编码显示 return new String(filename.getBytes(StandardCharsets.UTF_8.name()), StandardCharsets.ISO_8859_1.name()); &#125;&#125;","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Database Connection Pool","slug":"Database-Connection-Pool","date":"2019-05-28T12:57:13.000Z","updated":"2019-05-30T08:40:06.917Z","comments":true,"path":"2019/05/28/Database-Connection-Pool/","link":"","permalink":"http://yoursite.com/2019/05/28/Database-Connection-Pool/","excerpt":"","text":"学习笔记 : 数据库连接池简介 : 在JDBC编程中,每次创建和断开Connection对象都会消耗一定的时间和IO资源.为了避免频繁地创建数据库连接,工程师们提出了数据库连接池技术,其负责分配,管理和释放数据库连接,它允许应用程序重复使用现有的数据库连接,而不是重新建立连接 ! DataSource 接口简介 : 为了获取数据库连接对象(Connection),JDBC提供了javax.sql.DataSource接口,它负责与数据库建立连接,并定义了返回值为Connection对象的方法. 人们习惯性地把实现了该接口的类称为数据源,在数据源中存储了所有建立数据库连接的信息. 数据源中包含数据库库连接池,如果数据是水,数据库就是水库,数据源就是连接水库的管道,终端用户看到的数据集是管道里流出来的水. DBCP 数据源简介 : DBCP是数据库连接池(DataBase Connection Pool)的简称,是Apache组织下的开源连接池实现.其jar包中包含两个核心的类,分别是BasicDataSourceFactory和BasicDataSource. BasicDataSource : 为DataSource的实现类,主要包含设置数据源对象的方法. BasicDataSourceFactory : 为创建BasicDataSource对象的工厂类,它主要包含一个返回值为BasicDataSource对象的方法createDataSource(),该方法通过读取配置文件的信息生成数据源对象并返回给调用者. 使用BasicDataSource类创建数据源对象 示例程序如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.dbcp.test;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSource;/** * @ClassName: DBCPTest * @Description: 通过BasicDataSource类直接创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 9:25:36 PM * */public class DBCPTest &#123; private static DataSource dataSource = null; static &#123; // 获取DBCP数据源实现类对象 BasicDataSource basicDataSource = new BasicDataSource(); // 设置连接数据库需要的配置信息 basicDataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); basicDataSource.setUrl(\"jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\"); basicDataSource.setUsername(\"xxxxxx\"); basicDataSource.setPassword(\"xxxxxx\"); // 设置连接池的参数 basicDataSource.setInitialSize(5); dataSource = basicDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 打印数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\n\"); &#125;&#125; 程序运行结果如下 123URL : jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/J 通过读取配置文件创建数据源对象 db.properties : 数据源文件12345678#database configuration informationdriverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueusername=xxxxxxpassword=xxxxxx#DBCP configuration informationinitialSize=5maxIdle=10 DBCPTest2.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.dbcp.test;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;/** * @ClassName: DBCPTest2 * @Description: 通过读取配置文件创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 9:45:15 PM * */public class DBCPTest2 &#123; public static DataSource dataSource = null; static &#123; // 新建一个配置文件对象 Properties properties = new Properties(); // 通过类加载器找到文件路径并读取配置文件 InputStream inputStream = new DBCPTest2().getClass().getClassLoader().getResourceAsStream(\"db.properties\"); try &#123; // 把文件以输入流的形式加载到配置对象中 properties.load(inputStream); // 创建数据源对象 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 打印数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果如下 1234URL : jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf) C3P0 数据源简介 : C3P0实现了DataSource数据源接口,支持JDBC2,JDBC3的标准规范,易于扩展并且性能优越,著名的开源框架Hibernate和Spring使用的都是该数据源. C3P0中DataSource接口的实现类为ComboPooledDataSource,它是C3P0的核心类. 使用ComboPooledDataSource类创建数据库源对象 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.c3p0.test;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * @ClassName: ComboPooledDataSourceTest * @Description: 通过ComboPooledDataSource类直接创建数据源对象 * @author: HuangYuhui * @date: May 29, 2019 10:04:46 PM * */public class ComboPooledDataSourceTest &#123; private static DataSource dataSource = null; // 初始化c3p0数据源 static &#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); try &#123; comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; comboPooledDataSource.setJdbcUrl( \"jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\"); comboPooledDataSource.setUser(\"xxxxxx\"); comboPooledDataSource.setPassword(\"xxxxxx\"); // 设置连接池的参数 comboPooledDataSource.setInitialPoolSize(5); comboPooledDataSource.setMaxPoolSize(15); dataSource = comboPooledDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 输出数据库连接信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果如下 1234URL : jdbc:mysql://localhost/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf) 通过配置文件创建数据源对象 c3p0-config.xml : 数据源配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置:在没有指定配置时默认使用该配置创建c3p0数据源对象 --&gt; &lt;default-config&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;GoodTime&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;30000&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"maxIdleTime\"&gt;100&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"maxStatements\"&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 自定义配置 --&gt; &lt;named-config name=\"yu\"&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;GoodTime&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true &lt;/property&gt; &lt;property name=\"initiaPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; ComboPooledDataSourceTest2.java : 测试类 12345678910111213141516171819202122232425262728293031323334package pers.huangyuhui.c3p0.test;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class ComboPooledDataSourceTest2 &#123; public static DataSource dataSource = null; // 初始化C3P0数据源 static &#123; // 使用c3p0-config.xml配置文件中的named-config节点中name属性的值 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"yu\"); dataSource = comboPooledDataSource; &#125; public static void main(String[] args) throws SQLException &#123; // 获取数据库对象 Connection connection = dataSource.getConnection(); // 获取数据库连接信息 DatabaseMetaData databaseMetaData = connection.getMetaData(); // 输出数据库配置信息 System.out.println(\"URL: \" + databaseMetaData.getURL() + \"\\nUser name: \" + databaseMetaData.getUserName() + \"\\nDirver name: \" + databaseMetaData.getDriverName() + \"\\nDriver version: \" + databaseMetaData.getDriverVersion()); &#125;&#125; 程序运行结果 1234URL : jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=trueUser name : xxxxxx@localhostDirver name : MySQL Connector/JDriver version : mysql-connector-java-8.0.11 (Revision: 6d4eaa273bc181b4cf1c8ad0821a2227f116fedf)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2019-05-23T14:05:49.000Z","updated":"2019-05-29T11:36:51.320Z","comments":true,"path":"2019/05/23/SSM框架整合/","link":"","permalink":"http://yoursite.com/2019/05/23/SSM框架整合/","excerpt":"","text":"学习笔记 : SSM整合整合环境搭建简介 : 由于Spring MVC是Spring框架中的一个模块,所以Spring MVC与Spring之间不存在整合问题,因此SSM整合主要只涉及Spring与MyBatis的整合.下面通过客户id查询数据表中指定的客户信息的简单案例来演示SSM整合思路 ~ 编写配置文件 db.properties : 数据库配置文件 12345678910111213##database configuration information#jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql:xxxxxx?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx##DBCP configuration#jdbc.maxTotal=30 #最大连接数jdbc.maxIdle=10 #最大空闲连接数jdbc.initialSize=5 #初始化连接数 applicationContext.xml : Spring核心配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"$&#123;jdbc.maxTotal&#125;\"/&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 事务管理器,依赖于数据源 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;!-- 配置MyBatis工厂: 构建SqlSessionFactory --&gt; &lt;!-- 指定数据源和配置文件: 使得Spring IOC容器在初始化id为sqlSessionFactory的Bean时解析MyBatis的配置文件,并与数据源一同保存到Spring的Bean中 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定MyBatis核心配置文件位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 配置mapper扫描器 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.huangyuhui.ssm.dao\"/&gt; &lt;/bean&gt; &lt;!-- 扫描Service --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.ssm.service\"/&gt; &lt;/beans&gt; mybatis-config.xml : MyBatis核心配置文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 通过扫描包的形式定义别名: mybatis会将所有该包中的POJO类以首字母小写的非限定类名来作为它的别名 --&gt; &lt;package name=\"pers.huangyuhui.ssm.po\" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置Mapper --&gt; &lt;mappers&gt; &lt;!-- 使用Mapper接口动态代理开发时,如果完全遵循了编写规范,那么该配置文件中无需以下映射文件 --&gt; &lt;!-- &lt;mapper resource=\"pers/huangyuhui/ssm/dao/CustomerDao.xml\"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;ssm_01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置加载Spring文件的监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置Spring MVC前端核心过滤器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置服务器启动后立即加载Spring MVC配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;!-- 拦截除了jsp外的所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Spring-context.jar包中提供了通过JMX来实时查看Spring放在applicationContext里的bean列表功能, 其会在项目配置文件里找一个叫`spring.liveBeansView.mbeanDomain`的环境变量,如果没找到, 就会抛出异常:[spring.liveBeansView.mbeanDomain] threw NamingException ... 解决方案: 在项目中的web.xml中添加如下配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;spring.liveBeansView.mbeanDomain&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 整合应用测试上述已经了SSM框架整合环境的搭建工作,接下来开始整合开发工作 ~ t_customer.sql : 客户信息表 12345678create table t_customer ( id INT(20) PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) NOT NULL, job VARCHAR(10) NOT NULL, phone VARCHAR(12) NOT NULL ) Customer.java : 持久化类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.ssm.po;/** * @ClassName: Customer * @Description: 客户信息 * @author: HuangYuhui * @date: May 25, 2019 11:07:37 AM * */public class Customer &#123; private Integer id; private String name; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", name=\" + name + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerDao.java : Dao层 123456789101112131415161718192021package pers.huangyuhui.ssm.dao;import pers.huangyuhui.ssm.po.Customer;/** * @ClassName: CustomerDao * @Description: TODO * @author: HuangYuhui * @date: May 25, 2019 11:09:22 AM * */public interface CustomerDao &#123; /** * @Title: findCustomerById * @Description: 根据客户id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerDao.xml : 接口对应的映射文件 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.ssm.dao.CustomerDao\"&gt; &lt;!-- 根据客户id查找客户信息 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"customer\"&gt; select id,name,job,phone from t_customer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; CustomerService.java : Service层 12345678910111213141516171819202122package pers.huangyuhui.ssm.service;import pers.huangyuhui.ssm.po.Customer;/** * @ClassName: CustomerService * @Description: TODO * @author: HuangYuhui * @date: May 25, 2019 11:15:26 AM * */public interface CustomerService &#123; /** * * @Title: findCustomerById * @Description: 通过id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerServiceImpl.java : CustomerService的实现类 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.ssm.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import pers.huangyuhui.ssm.dao.CustomerDao;import pers.huangyuhui.ssm.po.Customer;import pers.huangyuhui.ssm.service.CustomerService;/** * @ClassName: CustomerServiceImpl * @Description: CustomerService的实现类 * @author: HuangYuhui * @date: May 25, 2019 11:17:12 AM * */@Service // 标识为业务层的实现类@Transactional // 将类中所有方法都纳入Spring的事物管理public class CustomerServiceImpl implements CustomerService &#123; @Autowired // 将CustomerDao接口对象注入到本类 private CustomerDao customerDao; @Override // 查询客户信息 public Customer findCustomerById(Integer id) &#123; return this.customerDao.findCustomerById(id); &#125;&#125; CustomerController.java : 控制器 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.ssm.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import pers.huangyuhui.ssm.po.Customer;import pers.huangyuhui.ssm.service.CustomerService;/** * @ClassName: CustomerController * @Description: 用于处理页面请求的控制器 * @author: HuangYuhui * @date: May 25, 2019 11:21:39 AM * */@Controller // 标识为控制器public class CustomerController &#123; @Autowired // 将CustomerService接口对象注入到本类 private CustomerService customerService; /** * @Title: findCustomerById * @Description: 通过id查询客户信息 * @param: id * @param: model * @return: String */ @RequestMapping(\"/findCustomerById\") public String findCustomerById(Integer id, Model model) &#123; Customer customer = customerService.findCustomerById(id); model.addAttribute(\"customer\", customer); // 返回客户信息展示页面 return \"customerInfo\"; &#125;&#125; WebContent/WEB-INF/view/customerInfo.jsp : 展示客户信息页面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;SSM整合案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;客户信息&lt;/h2&gt;&lt;hr/&gt; &lt;table align=\"center\" border=\"1\" &gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;职业&lt;/td&gt; &lt;td&gt;电话&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;$&#123;customer.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.job &#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.phone &#125;&lt;/td&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; log4j.properties : 日志文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.ssm.controller=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 将项目发布到Tomcat并启动,在浏览器中访问地址: http://localhost:8080/ssm_01/findCustomerById?id=1,其页面显示效果如下图所示. 由图可知,通过浏览器成功查出了t_customer表中id为1的客户信息.继而证明SSM框架整合成功!ヾ(◍°∇°◍)ﾉﾞ Console输出的主要日志信息如下 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DispatcherServlet with name &apos;spring_mvc&apos; processing GET request for [/ssm_01/findCustomerById]Looking up handler method for path /findCustomerByIdReturning handler method [public java.lang.String pers.huangyuhui.ssm.controller.CustomerController.findCustomerById(java.lang.Integer,org.springframework.ui.Model)]Returning cached instance of singleton bean &apos;customerController&apos;Last-Modified value for [/ssm_01/findCustomerById] is: -1Creating new transaction with name [pers.huangyuhui.ssm.service.impl.CustomerServiceImpl.findCustomerById]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos;Acquired Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] for JDBC transactionSwitching JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] to manual commitCreating a new SqlSessionRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] will be managed by Spring==&gt; Preparing: select id,name,job,phone from t_customer where id = ? ==&gt; Parameters: 2(Integer)&lt;== Total: 1Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61b17833]Initiating transaction commitCommitting JDBC transaction on Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J]Releasing JDBC Connection [636338281, URL=jdbc:mysql://LOCALHOST/mybatis_spring?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true, UserName=root@localhost, MySQL Connector/J] after transactionReturning JDBC Connection to DataSourceInvoking afterPropertiesSet() on bean with name &apos;customerInfo&apos;Rendering view [org.springframework.web.servlet.view.InternalResourceView: name &apos;customerInfo&apos;; URL [/WEB-INF/view/customerInfo.jsp]] in DispatcherServlet with name &apos;spring_mvc&apos;Added model object &apos;customer&apos; of type [pers.huangyuhui.ssm.po.Customer] to request in view with name &apos;customerInfo&apos;Added model object &apos;org.springframework.validation.BindingResult.customer&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;customerInfo&apos;Forwarding to resource [/WEB-INF/view/customerInfo.jsp] in InternalResourceView &apos;customerInfo&apos;Successfully completed request","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之拦截器","slug":"Spring-MVC之拦截器","date":"2019-05-23T14:05:26.000Z","updated":"2019-05-29T08:49:25.483Z","comments":true,"path":"2019/05/23/Spring-MVC之拦截器/","link":"","permalink":"http://yoursite.com/2019/05/23/Spring-MVC之拦截器/","excerpt":"","text":"学习笔记 : Spring MVC之拦截器简介 : Spring MVC中的拦截器(Interceptor)类似于Servlet中的过滤器(Filter),主要用于拦截用户请求并做相应的处理,例如通过拦截器可以进行权限验证,记录请求信息的日志,判断用户是否登录等..要使用Spring MVC中的拦截器,就需要对拦截器类进行定义和配置,通常拦截器类可以通过两种方式来定义,如下所示 : 实现HandlerInterceptor接口,或继承HandlerInterceptor接口的实现类,如HandlerInterceptorAdapter. 实现WebRequestInterceptor接口,或继承WebRequestInterceptor接口的实现类. 拦截器的执行流程单个拦截器的执行流程 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;springmvc_filter&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 设置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 容器启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; CustomInterceptor.java : 自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor * @Description: 拦截器 * @author: HuangYuhui * @date: May 23, 2019 9:23:19 PM * */public class CustomInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle1 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle1 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion1 ------\"); &#125;&#125; springmvc-config.xml : Spring MVC配置文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.filter.controller\" /&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\" /&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 拦截所有请求 --&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor\" /&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; MyController.java : 控制器 1234567891011121314151617181920212223242526272829package pers.huangyuhui.springmvc.filter.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: MyController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 9:20:31 PM * */@Controller@RequestMapping(\"/myFilter\")public class MyController &#123; /** * @Title: singleFilter * @Description: 测试单个拦截器的执行流程 * @return: String */ @RequestMapping(\"/singleFilter\") public String singleFilter() &#123; System.out.println(\"test my filter ~\"); return \"index\"; &#125;&#125; 新建WebContent/WEB-INF/view/index.jsp(仅测试) 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/myFilter/singleFilter 即可得到程序运行结果,如下所示 : 1234------ this is preHandle1 ------test my filter ~------ this is postHandle1 ------------ this is afterCompletion1 ------ 多个拦截器的执行流程 web.xml(同上..) CustomInterceptor.java : 第一个自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor * @Description: 自定义拦截器 * @author: HuangYuhui * @date: May 23, 2019 9:23:19 PM * */public class CustomInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle1 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle1 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion1 ------\"); &#125;&#125; CustomInterceptor2.java : 第二个自定义拦截器 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * @ClassName: CustomInterceptor2 * @Description: 自定义拦截器 * @author: HuangYuhui * @date: May 29, 2019 3:46:30 PM * */public class CustomInterceptor2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"------ this is preHandle2 ------\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"------ this is postHandle2 ------\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"------ this is afterCompletion2------\"); &#125;&#125; springmvc-config.xml : Spring MVC配置文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.filter.controller\" /&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\" /&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器1 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有路径下的请求 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!-- 拦截指定路径的请求 --&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor\" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 配置拦截器2 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"pers.huangyuhui.springmvc.filter.interceptor.CustomInterceptor2\" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; MyController.java : 控制器 12345678910111213141516171819202122232425262728package pers.huangyuhui.springmvc.filter.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: MyController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 9:20:31 PM * */@Controller@RequestMapping(\"/myFilter\")public class MyController &#123; /** * @Title: doubleFilter * @Description: 测试多个拦截器的执行流程 * @return: String */ @RequestMapping(\"/doubleFilter\") public String doubleFilter() &#123; System.out.println(\"test my filter ~\"); return \"index\"; &#125;&#125; 新建WebContent/WEB-INF/view/index.jsp(仅测试) 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/myFilter/doubleFilter 即可得到程序运行结果,如下所示 : 1234567------ this is preHandle1 ------------ this is preHandle2 ------test my filter ~------ this is postHandle2 ------------ this is postHandle1 ------------ this is afterCompletion2------------ this is afterCompletion1 ------ 应用案例简介 : 通过拦截器来完成一个用户登录权限验证案例.在本案例中,要求如下 : 只有登录后的用户才能访问系统主页面,如果没有登录系统而直接访问主页面,则其请求会被拦截器所拦截,并转发到登录页面,同时在登录页面提出提示信息. 如果用户名或密码错误,会在登录页面给出相应的提示信息. 当已登录的用户在系统主页中单击”退出”按钮时,系统将会退回到登录页面. web.xml : 略.. User.java : 用户信息 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.springmvc.filter.bean;/** * @ClassName: User * @Description: 用户信息 * @author: HuangYuhui * @date: May 24, 2019 8:43:49 AM * */public class User &#123; private Integer id; private String name; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; login.jsp : 用户登录页面 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;应用案例-实现用户登录权限验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;用户登录页面 ($&#123;msg &#125;)&lt;/h2&gt;&lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"$&#123;pageContext.request.contextPath &#125;/login\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"50px\"&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div align=\"center\"&gt; &lt;input style=\"margin-left:33px\" type=\"submit\" value=\"登录\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; main.jsp : 系统主页面 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;应用案例-实现用户登录权限验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;用户主页面&lt;/h2&gt;&lt;hr/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;当前用户 $&#123;USER_SESSION.name &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/logout\"&gt;退出&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; UserController.java : 控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package pers.huangyuhui.springmvc.filter.controller;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import pers.huangyuhui.springmvc.filter.bean.User;/** * @ClassName: UserController * @Description: 控制器 * @author: HuangYuhui * @date: May 24, 2019 8:45:24 AM * */@Controllerpublic class UserController &#123; /** * @Title: toLogin * @Description: 跳转到用户登录页面 * @param: null * @return: String */ // @RequestMapping(value = \"/login\", method = RequestMethod.GET) @GetMapping(value = \"/login\") // 组合注解 public String toLogin() &#123; return \"login\"; &#125; /** * @Title: login * @Description: 用户登录 * @param: user * @param: model * @param: session * @return: String */ // @RequestMapping(value = \"/login\", method = RequestMethod.POST) @PostMapping(value = \"/login\") public String login(User user, Model model, HttpSession session) &#123; // 获取用户名及密码 String username = user.getName(); String password = user.getPassword(); // 此处模拟从数据库中获取用户名和密码后进行判断 if ((username != null &amp;&amp; username.equals(\"YUbuntu0109\")) &amp;&amp; (password != null &amp;&amp; password.equals(\"demo\"))) &#123; // 将用户对象添加到Sessoin session.setAttribute(\"USER_SESSION\", user); // 重定向到主页面 return \"redirect:main\"; &#125; model.addAttribute(\"msg\", \"用户名或密码错误,请重新登录哟 !\"); return \"login\"; &#125; /** * @Title: toMain * @Description: 跳转到用户主页 * @param: null * @return: String */ @RequestMapping(value = \"/main\") public String toMain() &#123; return \"main\"; &#125; /** * @Title: logout * @Description: 退出登录 * @param: session * @return: String */ @RequestMapping(value = \"/logout\") public String logout(HttpSession session) &#123; // 清除Session session.invalidate(); // 重定向到登录页面 return \"redirect:login\"; &#125;&#125; LoginInterceptor.java : 自定义拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pers.huangyuhui.springmvc.filter.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import pers.huangyuhui.springmvc.filter.bean.User;/** * @ClassName: MyInterceptor * @Description: 用户登录拦截器 * @author: HuangYuhui * @date: May 24, 2019 8:59:20 AM * */public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求的URL String url = request.getRequestURI(); // 除了login.jsp可以公开访问外,其它URL都进行拦截控制 if (url.indexOf(\"/login\") &gt;= 0) &#123; return true; &#125; // 获取Session HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"USER_SESSION\"); // 判断Session中是否有用户数据 if (user != null) &#123; return true; &#125; // 对不符合条件的给出提示信息并转发到登录页面 request.setAttribute(\"msg\", \"你尚未登录,请先登录哟 !\"); request.getRequestDispatcher(\"/WEB-INF/view/login.jsp\").forward(request, response); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"this is postHandle\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"this is afterCompletion\"); &#125;&#125; 将项目发布到Tomcat服务器并启动,在浏览器中访问地址: http://localhost:8080/springmvc_filter/main 其页面如下: 登录成功后,其页面如下 :","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring MVC之数据绑定","slug":"Spring-MVC之数据绑定","date":"2019-05-22T13:25:32.000Z","updated":"2019-05-29T03:05:48.892Z","comments":true,"path":"2019/05/22/Spring-MVC之数据绑定/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-MVC之数据绑定/","excerpt":"","text":"学习笔记 : Spring MVC之数据绑定简介 : 在执行程序时,Spring MVC会根据客户端请求参数的不同,将请求消息中的信息以一定的方式转换并绑定到控制器类的方法参数中.这种将请求消息与后台方法参数建立连接的过程就是Sping MVC中的数据绑定. 数据绑定介绍在数据绑定过程中,Spring MVC框架会通过数据绑定组件(DataBinder)将请求参数串的内容进行类型转换,然后将和转换后的值赋给控制器类中方法的形参,这样后台就可以正确绑定并获取客户端请求携带的参数了.整个数据绑定过程如下图所示 : 上图信息处理过程的步骤如下 : Spring MVC将ServletsRequest对象传递给DataBinder. 将处理方法的入参对象传递给DataBinder. DataBinder调用ConversionService组件进行数据类型转换,数据格式化等工作,并将ServletRequest对象中的消息填充到参数对象中. 调用Validator组件对已经绑定了请求消息数据的参数对象进行数据合法性效验. 效验完成后生成数据绑定结果BindingResult对象,Spring MVC会将BindingResult对象中的内容赋给处理方法的相应形参.","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"MyBatis与Spring的整合","slug":"MyBatis与Spring的整合","date":"2019-05-22T13:23:28.000Z","updated":"2019-05-29T10:04:55.364Z","comments":true,"path":"2019/05/22/MyBatis与Spring的整合/","link":"","permalink":"http://yoursite.com/2019/05/22/MyBatis与Spring的整合/","excerpt":"","text":"学习笔记 : Spring与MyBatis整合传统DAO方式的开发整合简介 : 采用传统DAO开发方式进行MyBatis与Spring框架的整合时,需要编写DAO接口以及接口的实现类,并且需要向DAO实现类中注入SqlSessionFactory,然后通过SqlSessionFactory创建SqlSession. 下面通过一个使用客户id查询数据表中客户信息的案例来演示该开发方式. customer.sql : 客户信息表 123456789# 客户信息表create table t_customer ( id INT(20) PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) NOT NULL, job VARCHAR(10) NOT NULL, phone VARCHAR(12) NOT NULL ) db.properties : 数据库配置文件 12345678910111213##database configuration information#jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql:xxxxxx?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx##DBCP configuration#jdbc.maxTotal=30 #最大连接数jdbc.maxIdle=10 #最大空闲连接数jdbc.initialSize=5 #初始化连接数 applicationContext.xml : Spring核心配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"$&#123;jdbc.maxTotal&#125;\"/&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=\"maxIdle\" value=\"$&#123;jdbc.maxIdle&#125;\"/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 事务管理器,依赖于数据源 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;!-- 配置MyBatis工厂: 构建SqlSessionFactory --&gt; &lt;!-- 指定数据源和配置文件: 使得Spring IOC容器在初始化id为sqlSessionFactory的Bean时解析MyBatis的配置文件,并与数据源一同保存到Spring的Bean中 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定核心配置文件位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 实例化Dao: 为SqlSessionDaoSupport类的子类对象注入一个SqlSessionFactory --&gt; &lt;bean id=\"customerDao\" class=\"pers.huangyuhui.sm.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml : MyBaits核心配置文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 通过扫描包的形式定义别名: mybatis会将所有该包中的POJO类以首字母小写的非限定类名来作为它的别名 --&gt; &lt;package name=\"pers.huangyuhui.sm.po\" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置Mapper配置 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/sm/po/CustomerMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Customer.java : 持久层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.sm.po;/** * @ClassName: Customer * @Description: 客户信息 * @author: HuangYuhui * @date: May 24, 2019 6:38:18 PM * */public class Customer &#123; private Integer id; private String name; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", name=\" + name + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerMapper.xml : 映射文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.sm.po.CustomerMapper\"&gt; &lt;!-- 根据id查询客户信息,其中`customer`为Customer类的别名 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"customer\"&gt; select id,name,job,phone from t_customer where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; CustomerDao.java : DAO层 123456789101112131415161718192021package pers.huangyuhui.sm.dao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: CustomerDao * @Description: TODO * @author: HuangYuhui * @date: May 24, 2019 6:52:30 PM * */public interface CustomerDao &#123; /** * @Title: findCustomerById * @Description: 根据id查找客户信息 * @param: id * @return: Customer */ public Customer findCustomerById(Integer id);&#125; CustomerDaoImpl.java : CustomerDao的实现类 12345678910111213141516171819202122232425262728package pers.huangyuhui.sm.dao.impl;import org.mybatis.spring.support.SqlSessionDaoSupport;import pers.huangyuhui.sm.dao.CustomerDao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: CustomerDaoImpl * @Description: 实现操作客户信息接口 * @author: HuangYuhui * @date: May 24, 2019 6:54:24 PM *///注意:SqlSessionDaoSupport类在使用时需要一个SqlSessionFactory或一个SqlSessionTemplate对象,所以需要通过//Spring给SqlSessionDaoSupport类的子类对象注入一个SqlSessionFactory或SqlSessionTemplate.这样,在子类中就//能够调用SqlSessionDaoSupport类的getSqlSession()方法来获取SqlSession对象,并使用SqlSession对象中的方法!public class CustomerDaoImpl extends SqlSessionDaoSupport implements CustomerDao &#123; private String mapperNamespace = \"pers.huangyuhui.sm.po.CustomerMapper.\"; @Override // 通过id查找客户信息 public Customer findCustomerById(Integer id) &#123; // 调用SqlSessionDaoSupport类的getSqlSession()方法来获取SqlSession对象,并使用SqlSession对象中的方法! return this.getSqlSession().selectOne(mapperNamespace + \"findCustomerById\", id); &#125;&#125; 在此步骤需要在Spring配置文件applicationContext.xml中编写实例化CustomerDaoImpl的配置(已添加),代码如下所示 :123&lt;bean id=\"customerDao\" class=\"pers.huangyuhui.sm.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; SMTest.java : 整合测试类 1234567891011121314151617181920212223242526272829303132333435package pers.huangyuhui.sm.test;import org.junit.BeforeClass;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.sm.dao.CustomerDao;import pers.huangyuhui.sm.po.Customer;/** * @ClassName: SMTest * @Description: MyBatis+Spring整合测试 * @author: HuangYuhui * @date: May 24, 2019 7:02:26 PM * */public class SMTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void findCustomerByIdTest() &#123; // CustomerDao customerDao = (CustomerDao) applicationContext.getBean(\"customerDao\"); CustomerDao customerDao = (CustomerDao) applicationContext.getBean(CustomerDao.class); Customer customer = customerDao.findCustomerById(1); System.out.println(customer); &#125;&#125; log4j.properties : 日志文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.sm.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 程序运行结果 12345678910Fetching JDBC Connection from DataSourceJDBC Connection [1334618867, URL=xxxxxx, MySQL Connector/J] will not be managed by Spring==&gt; Preparing: select id,name,job,phone from t_customer where id = ? ==&gt; Parameters: 1(Integer)&lt;== Total: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15c25153]Returning JDBC Connection to DataSourceCustomer [id=1, name=YUbuntu0109, job=student, phone=15111111111] Mapper接口方式的开发整合. . .","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring MVC的核心类和注解","slug":"Spring-MVC的核心类和注解","date":"2019-05-22T13:22:50.000Z","updated":"2019-05-29T02:17:03.587Z","comments":true,"path":"2019/05/22/Spring-MVC的核心类和注解/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-MVC的核心类和注解/","excerpt":"","text":"学习笔记 : Spring MVC核心类与注解Controller 注解类型简介 : org.springframework.stereotype.Controller注解类型用于指示Spring类的实例是一个控制器,其注解形式为@Controller,使用该注解时只需要通过Spring的扫描机制找到标注了该注解的控制器即可,其操作如下 : 在配置文件的声明中引入spring-context. 使用&lt;context:component-scan&gt;元素指定需要扫描的类包. RequestMapping 注解类型简介 : Spring通过@Controller注解找到相应的控制器类后,还需要知道控制器内部对每一个请求是如何处理的,这时就需要使用org.springframework.web.bind.annotation.RequestMapping注解类型,该注解类型用于映射一个请求或一个方法,其注解形式为@RequestMapping,可以使用该注解标注在一个类或方法上. 标注在方法上 : 该方法将成为一个请求处理方法,它会在程序接收到对应的URL请求时被调用. 标注在类上 : 该类中的所有方法都将映射为相对于类级别的请求,表示该控制器所处理的所有请求都被映射到value属性值所指的路径下. ViewResolver 视图解析器简介 : Spring MVC中视图解析器负责解析视图,可以通过在配置文件中定义一个ViewResolver来配置视图解析器.其配置如下 :1234567&lt;!-- 定义视图解析器 --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 应用案例 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;springmvc_core&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 设置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 容器启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-config.xml : Spring MVC配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 指定需要扫描的包 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.springmvc.controller\"/&gt; &lt;!-- 定义视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;!-- 设置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; MyController.java : 控制器 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.springmvc.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * @ClassName: FirstController * @Description: 控制器 * @author: HuangYuhui * @date: May 23, 2019 7:16:18 PM * */@Controller // 标注为控制器类@RequestMapping(value = \"/springmvc\") // 映射请求方法public class MyController &#123; @RequestMapping(value = \"/myController\") public String handleRequest(HttpServletRequest request, HttpServletResponse response, Model model) &#123; // 向模型对象中添加数据 model.addAttribute(\"msg\", \"Hi Spring MVC ~\"); // 返回视图页面 return \"hi-springmvc\"; &#125;&#125; 在WebContent/WEB-INF/目录下新建view文件,并在其中新建hi-springmvc.jsp. 将项目发布到Tomcat服务器并启动,在浏览器中访问: http://localhost:8080/springmvc_core/springmvc/myController 即可发现页面显示运行结果 : Hi Sping MVC ~","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring的事务管理","slug":"Spring的事务管理","date":"2019-05-22T13:22:12.000Z","updated":"2019-06-08T11:09:44.126Z","comments":true,"path":"2019/05/22/Spring的事务管理/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring的事务管理/","excerpt":"","text":"学习笔记 : Spring的事务管理","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring-AOP","date":"2019-05-22T13:21:32.000Z","updated":"2019-06-08T11:09:14.227Z","comments":true,"path":"2019/05/22/Spring-AOP/","link":"","permalink":"http://yoursite.com/2019/05/22/Spring-AOP/","excerpt":"","text":"学习笔记 : Spring AOP","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"MyBatis的关联映射","slug":"MyBatis的关联映射","date":"2019-05-17T02:21:48.000Z","updated":"2019-06-08T09:08:11.669Z","comments":true,"path":"2019/05/17/MyBatis的关联映射/","link":"","permalink":"http://yoursite.com/2019/05/17/MyBatis的关联映射/","excerpt":"","text":"学习笔记 : MyBatis关联映射简介 : 在实际的开发中,对数据库的操作常常会涉及多张表,这在面向对象中就涉及了对象与对象之间对的关联关系. 针对多表之间的操作,MyBatis提供了关联映射,通过关联映射就可以很好地处理对象与对象之间的关联关系. MyBatis在映射文件中加载关联关系对象主要通过两种方式 : 嵌套查询 : 指通过执行另一条SQL映射语句来返回预期的复杂类型. 嵌套结果 : 使用嵌套结果映射来处理复杂的联合结果的子集. 配置文件(为下面程序示例做准备) db.properties : 连接数据库的配置文件 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=xxxxxxjdbc.password=xxxxxx mybatis-config.xml : MyBatis核心配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 将积极加载改为延迟加载,既按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;/settings&gt; &lt;!-- 使用扫描包的形式定义别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"pers.huangyuhui.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册SQL映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/IdCardMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/PersonMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/OrderMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/ProductMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=DEBUG#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 一对一以人与身份证之间的一对一关联关系为例,为简化代码使用嵌套结果方式加载关联关系对象,程序示例如下 : SQL 数据表文件 1234567891011121314151617-- auto-generated definition by Intellij IDEAcreate table tb_idcard( id int auto_increment primary key, code varchar(18) null);create table tb_person( id int auto_increment primary key, name varchar(10) null, age int null, sex char(1) null, card_id int null, constraint tb_person_card_id_uindex unique (card_id), constraint tb_person_tb_idcard_id_fk foreign key (card_id) references tb_idcard (id)); IdCard.java : 存储身份证信息, Person.java : 存储个人信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package pers.huangyuhui.mybatis.bean;/** * @project: mybatis_associated_mapping * @description: 身份证信息 * @author: HuangYuhui * @date: 6/1/2019-8:28 AM * @version: 1.0 */public class IdCard &#123; private Integer id; private String code; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; @Override public String toString() &#123; return \"IdCard&#123;\" + \"id=\" + id + \", code='\" + code + '&#125;'; &#125;&#125;package pers.huangyuhui.mybatis.bean;/** * @project: mybatis_associated_mapping * @description: 个人信息 * @author: HuangYuhui * @date: 6/1/2019-8:30 AM * @version: 1.0 */public class Person &#123; private Integer id; private String name; private Integer age; private String sex; private IdCard card; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public IdCard getCard() &#123; return card; &#125; public void setCard(IdCard card) &#123; this.card = card; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"id=\" + id + \", name='\" + name + \", age=\" + age + \", sex='\" + sex + \", card=\" + card + '&#125;'; &#125;&#125; PersonMapper.xml : SQL映射文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.PersonMapper\"&gt; &lt;!-- 嵌套查询：通过执行另一个SQL映射语句来返回预期的特殊类型 --&gt; &lt;select id=\"findPersonById\" parameterType=\"integer\" resultMap=\"PersonInfo\"&gt; SELECT * FROM tb_person WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"PersonInfo\" type=\"person\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;!-- 一对一: association使用select属性引入另一条SQL语句 --&gt; &lt;association property=\"card\" column=\"card_id\" javaType=\"idCard\" select=\"pers.huangyuhui.mybatis.mapper.IdCardMapper.findCodeById\"/&gt; &lt;/resultMap&gt; &lt;!-- 嵌套结果查询: 使用嵌套结果映射来处理重复的联合结果的子集 --&gt; &lt;select id=\"findPersonById2\" parameterType=\"integer\" resultMap=\"PersonInfo2\"&gt; SELECT p.*,c.code FROM tb_person p,tb_idcard c WHERE p.card_id=c.id AND p.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"PersonInfo2\" type=\"person\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;association property=\"card\" javaType=\"idCard\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"code\" column=\"code\"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 一对一: 嵌套查询方式 public void findPersonById() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); Person info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.PersonMapper.findPersonById2\", 1); System.out.println(info); sqlSession.close(); &#125;&#125; 一对多以一个用户对应多个订单为例,示例程序如下 : SQL 数据表文件 123456789101112131415-- auto-generated definition by Intellij IDEAcreate table user( id int auto_increment primary key, name varchar(15) null, address varchar(50) null);create table tb_order( id int auto_increment primary key, number varchar(20) not null, user_id int(2) not null, constraint orders_user_id_fk foreign key (user_id) references user (id)); Java Bean : User.java and Order.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package pers.huangyuhui.mybatis.bean;import java.util.List;/** * @project: mybatis_associated_mapping * @description: 用户信息 * @author: HuangYuhui * @date: 6/1/2019-11:04 AM * @version: 1.0 */public class User &#123; private Integer id; private String name; private String address; private List&lt;Order&gt; orders; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;Order&gt; getOrders() &#123; return orders; &#125; public void setOrders(List&lt;Order&gt; orders) &#123; this.orders = orders; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", orders=\" + orders + '&#125;'; &#125;&#125;package pers.huangyuhui.mybatis.bean;import java.util.List;/** * @project: mybatis_associated_mapping * @description: 订单信息 * @author: HuangYuhui * @date: 6/1/2019-11:02 AM * @version: 1.0 */public class Order &#123; private Integer id; private String number; private List&lt;Product&gt; products; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public List&lt;Product&gt; getProducts() &#123; return products; &#125; public void setProducts(List&lt;Product&gt; products) &#123; this.products = products; &#125; @Override public String toString() &#123; return \"Order&#123;\" + \"id=\" + id + \", number='\" + number + '\\'' + \", products=\" + products + '&#125;'; &#125;&#125; UserMapper.xml : SQL映射文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.UserMapper\"&gt; &lt;!-- 一对多:查看某一用户及其关联的订单信息 注意:当关联查询出的列名相同时,需要使用别名区分 --&gt; &lt;select id=\"findUserWithOrders\" parameterType=\"integer\" resultMap=\"UserWithOrdersResult\"&gt; SELECT u.*, o.id as order_id, o.number FROM user u,tb_order o WHERE u.id = o.user_id AND u.id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"UserWithOrdersResult\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;!-- ofType:属性集合中的元素类型 --&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;!-- 'order_id':tb_order.id的字段别名 --&gt; &lt;id property=\"id\" column=\"order_id\"/&gt; &lt;result property=\"number\" column=\"number\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 一对多:测试查询客户及其订单信息操作 public void findUserWithOrders() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); User info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.UserMapper.findUserWithOrders\", 1); System.out.println(info); sqlSession.close(); &#125;&#125; 多对多以订单与商品的关系为例(一个订单可以包含多个商品),示例程序如下 : SQL 数据表文件 123456789101112131415161718192021222324252627-- auto-generated definition by Intellij IDEA-- 商品表create table tb_product( id int auto_increment primary key, name varchar(25) null, price double null);-- 订单表create table tb_order( id int auto_increment primary key, number varchar(20) not null, user_id int(2) not null, constraint orders_user_id_fk foreign key (user_id) references user (id));-- 商品与订单表的中间表create table tb_order_product( id int auto_increment primary key, order_id int null, product_id int null, constraint tb_order_product_tb_order_id_fk foreign key (order_id) references tb_order (id), constraint tb_order_product_tb_product_id_fk foreign key (product_id) references tb_product (id)); ProductMapper.xml : SQL映射文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.ProductMapper\"&gt; &lt;!-- 根据商品id查询指定商品及其对应的订单信息,注意:当关联查询出的列名相同时,需要使用别名区分 --&gt; &lt;select id=\"findProductWithOrder\" resultMap=\"ProductWithOrder\"&gt; SELECT p.*, o.id as oid, o.number FROM tb_product p,tb_order o,tb_order_product op WHERE o.id = op.order_id AND p.id = op.product_id AND p.id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 自定义手动映射类型 --&gt; &lt;resultMap id=\"ProductWithOrder\" type=\"product\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"price\" column=\"price\"/&gt; &lt;!-- 多对多关联映射 --&gt; &lt;collection property=\"orders\" ofType=\"order\"&gt; &lt;!-- 'oid':tb_order.id的别名 --&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"number\" column=\"number\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; MyBatisTest.java : 测试类 12345678910111213141516171819202122232425262728package pers.huangyuhui.mybatis.test;import org.apache.ibatis.session.SqlSession;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Order;import pers.huangyuhui.mybatis.bean.Person;import pers.huangyuhui.mybatis.bean.Product;import pers.huangyuhui.mybatis.bean.User;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @project: mybatis_associated_mapping * @description: 测试 * @author: HuangYuhui * @date: 6/1/2019-9:43 AM * @version: 1.0 */public class MyBatisTest &#123; @Test // TODO: 6/8/2019 多对多:根据商品id查询指定商品及其对应的订单信息 public void findProductWithOrder() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); Product info = sqlSession.selectOne(\"pers.huangyuhui.mybatis.mapper.ProductMapper.findProductWithOrder\", 3); System.out.println(info); &#125;&#125; 程序运行结果 123456==&gt; Preparing: SELECT p.*, o.id as oid, o.number FROM tb_product p,tb_order o,tb_order_product op WHERE o.id = op.order_id AND p.id = op.product_id AND p.id = ? ==&gt; Parameters: 3(Integer)&lt;== Total: 3Product&#123;id=3, name=&apos;&lt;book:Spring MVC&gt;&apos;, price=33.3, orders=[Order&#123;id=3, number=&apos;10000001&apos;, products=null&#125;, Order&#123;id=3, number=&apos;10000003&apos;, products=null&#125;, Order&#123;id=3, number=&apos;10000002&apos;, products=null&#125;]&#125;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Hi SpringMVC ~","slug":"Hi-SpringMVC","date":"2019-05-16T07:01:48.000Z","updated":"2019-05-22T07:59:10.339Z","comments":true,"path":"2019/05/16/Hi-SpringMVC/","link":"","permalink":"http://yoursite.com/2019/05/16/Hi-SpringMVC/","excerpt":"","text":"学习笔记 : Spring MVC入门Spring MVC概述Spring MVC是Spring提供的一个实现了Web MVC设计模式的轻量级Web框架. Spring MVC具有如下特点 : 支持国际化. 支持多种视图技术. 灵活性强,易于与其它框架集成. 内置常见效验器,可以效验用户输入. 可自动绑定用户输入,并正确的转换数据类型. 使用基于XML的配置文件,编写后无需重新编译应用程序. 提供了一个前端控制器DispatcherServlet,使开发人员无须额外开发控制器对象. Spring MVC的工作流程Spring MVC的工作原理图如下所示. 第一个Spring MVC应用程序 第一步: 配置前端控制器 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Hi_SpringMVC&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;!-- 配置前端过滤器 --&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使容器在启动时立即加载Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第二步: 创建Controller类 12345678910111213141516171819202122232425262728293031package pers.huangyuhui.springmvc.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;/** * @ClassName: FirstController * @Description: 控制器 * @author: HuangYuhui * @date: May 22, 2019 2:51:16 PM * */public class FirstController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; // 创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 向模型中添加数据 modelAndView.addObject(\"msg\", \"This is my first Spring MVC program ~\"); // 设置了逻辑视图名 modelAndView.setViewName(\"/WEB-INF/view/HiSpringMVC.jsp\"); return modelAndView; &#125;&#125; 第三步: 创建Spring MVC的配置文件,配置控制器映射信息 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置处理器Handle,映射 `/firstController`请求 --&gt; &lt;bean name=\"/FirstController\" class=\"pers.huangyuhui.springmvc.controller.FirstController\" /&gt; &lt;!-- 处理器映射器:将处理器Handle的name作为url进行查找 --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" /&gt; &lt;!-- 处理器适配器:配置对处理器中handleRequest()方法的调用 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;!-- 截图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" /&gt;&lt;/beans&gt; 注意: 在Spring 4.0以后,如果不配置处理器映射器,处理器适配器和视图解析器,也会使用Spring内部默认的配置来完成相应的工作呦~ 这里没有省略是为了更清晰地展示Spring MVC的工作流程. 第四步: 创建视图页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Hi SpringMVC ~&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=\"center\"&gt;$&#123;msg &#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 第五步: 启动Tomcat服务器,在浏览器中访问地址: http://localhost:8080/Hi_SpringMVC/FirstController 其效果图如下.","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"MyBatis:动态SQL","slug":"MyBatis-动态SQL","date":"2019-05-16T07:01:11.000Z","updated":"2019-05-22T09:25:15.065Z","comments":true,"path":"2019/05/16/MyBatis-动态SQL/","link":"","permalink":"http://yoursite.com/2019/05/16/MyBatis-动态SQL/","excerpt":"","text":"学习笔记 : MyBatis之动态SQL简介 : MyBatis提供的对SQL语句动态组装的功能解决了开发人员在使用JDBC或其他的框架进行数据库开发时,需要手动拼装SQL的繁琐问题. 动态SQL元素动态SQL是MyBatis强大特性之一,MyBatis 3采用了功能强大的基于OGNL的表达式来完成动态SQL,其主要元素如下. &lt;if&gt; : 判断语句,用于单条分支判断. &lt;choose&gt;(&lt;when&gt;,&lt;otherwise&gt;) : 相当于Java中的swith…case…default语句,用于多条件分支判断. &lt;where&gt;,&lt;trim&gt;,&lt;set&gt; : 辅助元元素,用于处理一些SQL拼装,特殊字符问题. &lt;foreach&gt; : 循环语句,常用于in语句等列举条件中. &lt;bind&gt; : 从OGNL表达式中创建一个变量,并将其绑定到上下文,常用于模糊查询的sql中. 扩展 : OGNL是Object-Graph Navigation Language的缩写,它是一种功能强大的表达式语言,通过它简单一致的表达式语法,可以存取对象的任意属性,调用对象的方法,遍历整个对象的结构图,实现字段类型转化等功能.它使用相同的表达式去存取对象的属性.这样可以更好的取得数据. 应用案例下面通过一个操作客户信息的综合案例来学习SQL动态元素 (っ•̀ω•́)っ✎⁾⁾ ~ 客户信息表结构 12345678create table t_customer ( id INT(32) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, jobs VARCHAR(45) NOT NULL, phone VARCHAR(16) NOT NULL ) db.properties : 数据库配置文件 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将SQL映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/CustomerMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Customer.java : 封装客户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.mybatis.bean;/** * @ClassName: Customer * @Description: 客户信息实体表 * @author: HuangYuhui * @date: May 18, 2019 11:37:59 AM * */public class Customer &#123; private Integer id; private String username; private String job; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Customer [id=\" + id + \", username=\" + username + \", job=\" + job + \", phone=\" + phone + \"]\"; &#125;&#125; CustomerMapper.xml : 操作’t_customer’数据表的映射文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.CustomerMapper\"&gt; &lt;!-- (&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer where 1=1 &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/select&gt; &lt;!-- (&lt;where&gt;+&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob_where\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;where&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- (&lt;trim&gt;+&lt;if&gt;)将客户名和职业组合作为查询客户信息列表的条件 --&gt; &lt;select id=\"findCustomerByNameAndJob_trim\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"job!=null and job!=''\"&gt; and job=#&#123;job&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- (&lt;where&gt;+&lt;when&gt;+&lt;otherwise&gt;)将客户名或职业其中一项作为查询客户信息的条件 --&gt; &lt;select id=\"findCustomerByNameOrJob\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer &lt;where&gt; &lt;choose&gt; &lt;when test=\"username!=null and username!=''\"&gt; and username like concat('%',#&#123;username&#125;,'%') &lt;/when&gt; &lt;when test=\"job!=null and job!=''\"&gt; and job = #&#123;job&#125; &lt;/when&gt; &lt;otherwise&gt; and phone is not null &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- (&lt;set&gt;+&lt;if&gt;)根据id更新客户信息 --&gt; &lt;update id=\"updateCustomer\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; update t_customer &lt;set&gt; &lt;if test=\"username !=null and username !=''\"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"job !=null and job !=''\"&gt; job=#&#123;job&#125; &lt;/if&gt; &lt;if test=\"phone !=null and phone !=''\"&gt; phone=#&#123;phone&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- (&lt;foreach&gt;)根据客户id批量查询客户信息 --&gt; &lt;select id=\"findCustomerByIds\" parameterType=\"List\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select id,username,job,phone from t_customer where id in &lt;foreach item=\"id\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- (&lt;bind&gt;)替换$&#123;&#125;,防止SQL注入问题.根据客户名模糊查询客户信息 --&gt; &lt;select id=\"findCustomerByName\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; &lt;bind name=\"pattern_username\" value=\" '%' + _parameter.getUsername + '%' \"/&gt; select id,username,job,phone from t_customer where username like #&#123;pattern_username&#125; &lt;/select&gt;&lt;/mapper&gt; MyBatisUtils.java : MyBatis工具类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.mybatis.util;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * @ClassName: MyBatisUtils * @Description: MyBatis工具类 * @author: HuangYuhui * @date: May 18, 2019 11:43:31 AM * */public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; private static SqlSessionFactory sqlSessionFactory = null; static &#123; // 使用MyBatis提供的Resources类加载MyBatis的配置文件 try (Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");) &#123; // 构建SqlSessionFactory工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 获取SqlSession对象的静态方法 public static SqlSession getSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; MyBatisTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package pers.huangyuhui.mybatis.test;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Customer;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @ClassName: MyBatisTest * @Description: 测试 * @author: HuangYuhui * @date: May 18, 2019 8:41:39 AM * */public class MyBatisTest &#123; private static Customer customer; private static String namespace = \"pers.huangyuhui.mybatis.mapper.CustomerMapper.\"; @BeforeClass public static void init() throws IOException &#123; customer = new Customer(); &#125; @Test @Ignore // 将客户名和职业组合作为查询客户信息列表的条件 public void findCustomerByNameAndJobTest() &#123; // 获取SqlSession对象 SqlSession sqlSession = MyBatisUtils.getSession(); // 封装需要组合查询的条件 customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"programmer\"); // 执行SqlSession的查询方法,并返回结果集 List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByNameAndJob\", customer); // 输出查询结果信息 for (Customer customer : customers) &#123; System.out.println(customer); &#125; // 关闭SqlSession sqlSession.close(); &#125; @Test @Ignore // 将客户名或职业其中一项作为查询客户信息的条件 public void findCustomerByNameOrJobTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student\"); List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByNameOrJob\", customer); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125; @Test @Ignore // 根据客户id更新客户信息 public void updateCustomerTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setId(1); customer.setPhone(\"15711111111\"); int rows = sqlSession.update(namespace + \"updateCustomer\", customer); if (rows &gt; 0) &#123; System.out.println(\"成功更新了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"数据更新操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id批量查询客户信息 public void findCustomerByIdsTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); // 创建List集合,封装查询id List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); // 查询id为1,2,3的客户信息 List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByIds\", ids); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125; @Test @Ignore // 根据客户名模糊查询客户信息 public void findCustomerByNameTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"Y\"); List&lt;Customer&gt; customers = sqlSession.selectList(namespace + \"findCustomerByName\", customer); for (Customer customer : customers) &#123; System.out.println(customer); &#125; sqlSession.close(); &#125;&#125; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring:数据库开发","slug":"Spring-数据库开发","date":"2019-05-16T07:00:49.000Z","updated":"2019-05-22T05:09:22.300Z","comments":true,"path":"2019/05/16/Spring-数据库开发/","link":"","permalink":"http://yoursite.com/2019/05/16/Spring-数据库开发/","excerpt":"","text":"学习笔记 : Spring 数据库开发Spring JDBC简介 : Spring框架降低了Java EE API的使用难度,例如JDBC. Spring的JDBC模块负责数据库资源管理和错误处理,简化了开发人员对数据库的操作,从而将更多的精力投入到编写业务逻辑中. Spring JdbcTemplate 的解析针对数据库操作,Spring框架提供了JdbcTemplate类,该类是Spring框架数据抽象层的基础,Spring JDBC的核心类. 它继承自抽象类JdbcAccessor,同时实现了JdbcOperations接口. JdbcAccessor : 该类为子类提供了一些访问是数据库时使用的公共属性. JdbcOperations : 该接口定义了在JdbcTemplate类中可以使用的操作集合,包括增删改查等操作. Spring JDBC 的配置Spring JDBC模块主要由4个包组成,如下所示哟 ~ core(核心包) : 包含了JDBC的核心功能,包括JdbcTemplate,SimpleJdbcInsert,SimpleJdbcCall类,以及NamedParameterJdbcTemplate类. dataSource(数据源包) : 访问数据源的实用工具类,它有多种数据源的实现,可以在Java EE容器外部测试JDBC代码. object(对象包) : 以面向对象的方式访问数据库,它允许执行查询并将返回结果作为业务对象,可以在数据表的列和业务对象的属性之间映射查询结果. support(支持包) : 包含了core和object包的支持类,例如: 提供异常转换功能的SQLException类. 由此可知,Spring对数据库的操作都封装在这几个包中,Spring JDBC的配置是在配置文件applicationContext.xml中完成的哟 ~ 其模板如下所示 : 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 1: 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/xxxxxx\"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"xxxxxx\" /&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"xxxxxx\" /&gt; &lt;/bean&gt; &lt;!-- 2: 配置JDBC模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 默认必须使用数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 3: 配置注入类 --&gt; &lt;bean id=\"xxxxxx\" class=\"xxxxxx\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; ······&lt;/beans&gt; 定义JdbcTemplate时,需要将dataSource注入到JdbcTemplate中,而其它需要使用JdbcTemplate的Bean,也需要将JdbcTemplate注入到该Bean中(通常注入到Dao类中,在Dao类中进行与数据库的相关操作). Spring JdbcTempalte 的常用方法JdbcTemplate类中提供了大量的操作数据库的方法,下面通过一个简单的CURE来体现一下Spring JDBC代码的简洁美 ~ applicationContext.xml : 配置文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 1: 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;!-- 连接数据库的url --&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost/Spring?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true\" /&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name=\"username\" value=\"xxxxxx\" /&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name=\"password\" value=\"xxxxxx\" /&gt; &lt;/bean&gt; &lt;!-- 2: 配置JDBC模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 默认必须使用数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 3: 配置注入类 --&gt; &lt;bean id=\"accountDao\" class=\"pers.huangyuhui.spring.jdbc.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 将jbdcTemplate注入到accountDao实例中 --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Account.java : 封装用户账户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.spring.jdbc.bean;/** * @ClassName: Account * @Description: 用户账户信息实体表 * @author: HuangYuhui * @date: May 17, 2019 11:56:41 AM * */public class Account &#123; private Integer id; private String username; private Double balance; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return \"Account [id=\" + id + \", username=\" + username + \", balance=\" + balance + \"]\"; &#125;&#125; AccountDao.java : 操作账户信息的接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package pers.huangyuhui.spring.jdbc.dao;import java.util.List;import pers.huangyuhui.spring.jdbc.bean.Account;/** * @ClassName: AccountDao * @Description: 操作用户账户表信息 * @author: HuangYuhui * @date: May 17, 2019 12:00:43 PM * */public interface AccountDao &#123; /** * @Title: createTable * @Description: 创建数据表 * @param: sql * @return: void */ public void createTable(String sql); /** * @Title: findAccountById * @Description: 查找表数据 * @param: id * @return: Account */ public Account findAccountById(int id); /** * @Title: findAllAccount * @Description: 查找全部表数据 * @return: List&lt;Account&gt; */ public List&lt;Account&gt; findAllAccount(); /** * @Title: addAccount * @Description: 添加表数据 * @param: account * @return: int */ public int addAccount(Account account); /** * @Title: updateAccount * @Description: 更新表数据 * @param: account * @return: int */ public int updateAccount(Account account); /** * @Title: deleteAccount * @Description: 删除表数据 * @param: id * @return: int */ public int deleteAccount(int id);&#125; AccountDaoImpl.java : AccountDao的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package pers.huangyuhui.spring.jdbc.dao.impl;import java.util.List;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import pers.huangyuhui.spring.jdbc.bean.Account;import pers.huangyuhui.spring.jdbc.dao.AccountDao;/** * @ClassName: AccountDaoImpl * @Description: AccountDao接口的实现类 * @author: HuangYuhui * @date: May 17, 2019 12:05:34 PM * */public class AccountDaoImpl implements AccountDao &#123; // 声明JdbcTemplate属性及其setter方法 private JdbcTemplate jdbcTemplate; // 获取JdbcTemplate实例 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public void createTable(String sql) &#123; jdbcTemplate.execute(sql); &#125; @Override public int addAccount(Account account) &#123; String sql = \"insert into account(username,balance) value(?,?)\"; // 定义数组来存储SQL语句中的参数. Good idea ~ Object[] objects = new Object[] &#123; account.getUsername(), account.getBalance() &#125;; // 执行添加操作,返回受SQL语句影响的条数 return jdbcTemplate.update(sql, objects); &#125; @Override public int updateAccount(Account account) &#123; String sql = \"update account set username=? , balance=? where id = ?\"; // 注意: `?`需与设置的参数顺序对应哟 ! Object[] objects = new Object[] &#123; account.getUsername(), account.getBalance(), account.getId() &#125;; return this.jdbcTemplate.update(sql, objects); &#125; @Override public int deleteAccount(int id) &#123; String sql = \"delete from account where id = ?\"; return this.jdbcTemplate.update(sql, id); &#125; @Override public Account findAccountById(int id) &#123; String sql = \"select id,username,balance from account where id = ?\"; // 创建BeanPropertyRowMapper对象 // 它可以自动地将数据表中的数据映射到用户自定义的类中(前提是:用户自定义类中的字段要与数据表中的字段相对应) RowMapper&lt;Account&gt; rowMapper = new BeanPropertyRowMapper&lt;Account&gt;(Account.class); // 将id绑定到SQL语句中,并通过RowMapper返回一个Object类型的单行记录 return this.jdbcTemplate.queryForObject(sql, rowMapper, id); &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; String sql = \"select id,username,balance from account\"; RowMapper&lt;Account&gt; rowMapper = new BeanPropertyRowMapper&lt;Account&gt;(Account.class); // 执行静态的SQL查询,并通过RowMapper返回结果集 return this.jdbcTemplate.query(sql, rowMapper); &#125;&#125; 5.CURETest.java : 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package pers.huangyuhui.spring.jdbc.test;import java.util.List;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.jdbc.bean.Account;import pers.huangyuhui.spring.jdbc.dao.AccountDao;/** * @ClassName: CURDTest * @Description: 测试Spring JDBC的增删改查功能 * @author: HuangYuhui * @date: May 17, 2019 12:26:43 PM * */public class CURDTest &#123; private static Account account; private static AccountDao accountDao; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; account = new Account(); // 加载配置文件 applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 获取AccountDao实例 accountDao = (AccountDao) applicationContext.getBean(\"accountDao\"); &#125; @Test // 创建用户账户信息数据表 public void createTableTest() &#123; String sql = \"create table account\\r\\n\" + \"(\\r\\n\" + \" id int primary key auto_increment,\\r\\n\" + \" username varchar(10) not null,\\r\\n\" + \" balance double not null\\r\\n\" + \")\"; accountDao.createTable(sql); System.out.println(\"success to create the table of account ~\"); &#125; @Ignore @Test // 添加账户信息 public void addAccountTest() &#123; // 向Account对象中添加数据 account.setUsername(\"YUbuntu0109\"); account.setBalance(666666.0); // 获取添加操作返回的结果 int num = accountDao.addAccount(account); if (num &gt; 0) &#123; System.out.println(\"成功添加了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"添加数据失败 !\"); &#125; &#125; @Ignore @Test // 更新指定账户信息 public void updateAccountTest() &#123; account.setId(3); account.setUsername(\"update\"); account.setBalance(999999.0); int num = accountDao.updateAccount(account); if (num &gt; 0) &#123; System.out.println(\"更新成功了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"更新数据失败 ! \"); &#125; &#125; @Ignore @Test // 删除指定账户信息 public void deleteAccountTest() &#123; int num = accountDao.deleteAccount(1); if (num &gt; 0) &#123; System.out.println(\"删除了 \" + num + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"删除数据失败 !\"); &#125; &#125; @Ignore @Test // 查询指定账户信息 public void findAccountByIdTest() &#123; account = accountDao.findAccountById(2); System.out.println(account); &#125; @Ignore @Test // 查询所有账户信息 public void findAllAccount() &#123; List&lt;Account&gt; accountInfo = accountDao.findAllAccount(); System.out.println(accountInfo); &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"VOA:One Hour of Exercise a Day Fights Damage of Sitting","slug":"VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting","date":"2019-05-15T04:50:00.000Z","updated":"2019-05-16T23:23:17.187Z","comments":true,"path":"2019/05/15/VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting/","link":"","permalink":"http://yoursite.com/2019/05/15/VOA-One-Hour-of-Exercise-a-Day-Fights-Damage-of-Sitting/","excerpt":"","text":"One Hour of Exercise a Day Fights Damage of SittingFrom VOA Learning English,this is Health&amp;Lifestyle report. When it comes to your health,it seems that sitting too much may be as bad for you as smoking. 说到健康,久坐不起可能与抽烟一样对身体不利. If you sit for many hours a day in a traditional office job,you may be interested in a new study. This study suggests that you should get an hour of “brisk exercise” every day. 如果你从事传统办公室工作,每日都要坐几个小时,你可能会对一项新研究感兴趣.这项研究建议你每天都花一个小时做轻快运动. Reasearchers says this brisk exercise can help offices workers reduce their risk of an early death. Many offices workers spend a large part of their time seated and physically inactive. 研究人员表明,这样的轻快运动能够帮助上班族降低过早死亡的风险.很多上班族大部分时间都是坐着,没有过多行动. A lack of physical activity is linked to some 5.3 million deaths worldwide each year. The researchers say that makes a sedentary lifestyle more deadly than smoking. 全球每年530万例死亡都与缺乏体育锻炼有关.研究人员表示,久坐不动的生活方式比吸烟更致命. The new report said that a sedentary lifestyle can cause many diseases,including heart disease,diabetes and even some cancers. These diseases cost the world economy $67.5 billion every year. 最新的报道表明,静态的生活方式可能会导致很多疾病,其中包括心脏病,糖尿病,甚至是癌症.每年,全球在这些疾病上等的话费约有675美元. The U.S. Centers for Disease Control and Prevention suggests adults get 150 minutes of moderate aerobic exercise every week. In addition,CDC offcials advise adults to get an additional two hours of muscle strengthening per week. 美国疾病预防与控制中心建议成年人每周做150分钟有氧运动.此外,疾病防治中心官员建议成年人每周花两个小时做肌肉训练. Ulf Ekeslund is with the Norwegian School of Sports Sciences and the University of Cambridge. He was the lead writer of the report. Elf Ekeslund同时在挪威体育学院以及剑桥大学任职.他是该报告的首席作者. Ekelund says that “For many people who commute to work and have offices-based jobs,there is no way to escape sitting for prolonged periods of time.” Ekelund表示: “对于乘车上下班到办公室的很多人来说,都无可避免在办公室久坐.” He says he and the other reasearchers “cannot stress enough” the importance of getting exercise. Ekelund suggests going for a run in the morning,riding a bicycle to work,or taking a walk in the middle of the work day. 他表示他和其他研究人员一直都在强调锻炼的重要性. Ekelund建议人们晨跑,骑车上班,并在午间散步. An hour of physical activity is “ideal”,he adds. But if this is not possible,he suggests doing at least some exercise each day to reduce the risk of diease and an early death. 每天锻炼一小时是理想的,他补充道.但如果不能做到这点,他建议人们每天至少做些运动以降低患病以及过早死亡的风险. For the study,researchers looked at 13 earlier studies on the effect of inactivity. Study subjects were grouped according to the amount of activity they reported. The range of activity reported varied greatly——from less than 5 minutes a day to up 75 minutes a day. 此项研究中,研究人员参考了13个不活动带来影响的早期案例.根据他们报告的活动量对研究对象进行了分组.报告说,活动量的幅度差别非常大,从每天至少5分钟到每天75分钟不等. The study found that those who sat for eight hours a day,but got the suggested amount of exercise reduced their chances of dying at an early age. 研究发现每天至少坐8小时,但按照建议做了适量运动的人降低了过早死亡的风险. These people did better than those who sat less but were not active. 与那些坐的时间少但不做运动的人相比,这些人的情况更好. Ekelund says, “These has been a lot of concern about the health risks” linked “with today’s more sedentary lifestyle.” He says the message from his team is a positive one: it’s possible to reduce,or even eliminate these risks if we are active enough, “even without taking up sports or going to the gym.” Ekelund表示,如今很多健康问题都与静态生活方式有关.他表示他们团队带来的信息是非常积极的: 我们有可能降低甚至消除这些风险,只要我们经常活动,即使不从事体育运动或不去健身房. A report on the study appeared in the pulication Lancet. I’m Anna Matteo. 重点词汇 brisk (a) 轻快的. inactive (a) 不活跃的. sedentary (a) 久坐的,静坐的. moderate (a) 稳健的. aerobic (a) 需氧的. prolonged (a) 延长的,拖延的. varied (a) 多变的,各式各样的. diabetes (n) 糖尿病,多尿症. economy (n) 经济. prevention (n) 预防,阻止. strengthening (n) 加强,加固. period (n) 周期,期间. inactivity (n) 不活动,静止. lancet (n) [外科]柳叶刀. commute (v) 通勤. stress (v) 强调. 重点短语 taking up : 占用了,占用","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"MyBatis的核心配置","slug":"MyBatis的核心配置","date":"2019-05-15T04:45:09.000Z","updated":"2019-05-22T08:19:50.191Z","comments":true,"path":"2019/05/15/MyBatis的核心配置/","link":"","permalink":"http://yoursite.com/2019/05/15/MyBatis的核心配置/","excerpt":"","text":"学习笔记 : MyBatis的核心配置MyBatis的核心对象SqlSessionFactorySqlSessionFactory是MyBatis中十分重要的对象,它是单个数据库映射关系经过编译后的内存镜像,其作用是创建SqlSession. SqlSessionFactory对象是线程安全的,它一旦被创建,在整个应用执行期间都会存在.如果我们多次地创建同一个数据库的SqlSessionFactory势必会耗尽数据库资源! 通常每一个数据库都会只对应一个SqlSessionFactory,所以在构建SqlSessionFactory时建议使用单例模式哟 ! SqlSessionSqlSession是MyBatis框架中另一个重要的对象,它是应用程序与持久层之间执行交互操作的一个单线程对象,其主要作用是执行持久化操作. 注意: 每一个线程都应该有一个自己的SqlSession实例,并且该实例是不能被共享的,同时SqlSession实例也是线程不安全的,因此其使用范围最好在一次请求或一个方法中,绝不能将其放在一个类的静态字段,实例或任何类型的管理范围中使用.使用后理应及时地关闭它 ! 配置文件主要元素结构图 映射文件官方简介 : MyBatis的真正强大在于它的映射语句,这是它的魔力所在.由于它的异常强大,映射器的XML文件就显得相对简单.如果拿它跟具有相同功能的JDBC代码进行对比,你会立即发现省掉了将近95%的代码! 俺喜欢简洁(✪ω✪) ~ 主要元素在映射文件中,&lt;mapper&gt;元素是映射文件的根元素,其它元素都是它的子元素,其子元素及其作用如下所示 : &lt;select&gt; : 映射查询语句,可自定义参数,返回结果等. &lt;insert&gt; : 映射插入语句,执行后返回一个整数,代表插入到条数. &lt;update&gt; : 映射更新语句,执行后返回一个整数,代表更新的条数. &lt;delete&gt; : 映射删除语句,执行后返回一个整数,代表删除的条数. &lt;sql&gt; : 用于定义一部分SQL,然后可被其它语句引用此SQL. &lt;cache-ref&gt; : 其他命名空间缓存配置的引用. &lt;resultMap&gt; : 用于描述如何从数据库结果集中来加载数据. 简单案例MyBatis框架的强大之处体现在映射文件,下面使用上述主要元素来编写一个简单的CURE程序 ~ 数据表 1234567891011121314151617# 客户信息表(用于测试增删改查元素)create table t_customer ( id INT(32) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, job VARCHAR(45) NOT NULL, phone VARCHAR(16) NOT NULL )# 用户信息表(用于测试&lt;resultMap&gt;元素)CREATE TABLE t_user( t_id INT PRIMARY KEY AUTO_INCREMENT, t_name VARCHAR(20) NOT NULL, t_age INT NOT NULL) db.properties : 数据库配置信息 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境.默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将SQL映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"pers/huangyuhui/mybatis/mapper/CustomerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; CustomerMapper.xml : 操作’t_customer’数据表的映射文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.CustomerMapper\"&gt; &lt;!-- 使用&lt;sql&gt;元素定义可重用的sql代码片段,简化代码 --&gt; &lt;sql id=\"customerColumns\"&gt;id,username,job,phone&lt;/sql&gt; &lt;!-- 使用&lt;insert&gt;元素查询客户信息 --&gt; &lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; select &lt;include refid=\"customerColumns\"/&gt; from t_customer where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 使用&lt;insert&gt;元素添加客户信息并返回数据库生成的主键值 --&gt; &lt;insert id=\"addCustomer\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; insert into t_customer(username,job,phone) values(#&#123;username&#125;,#&#123;job&#125;,#&#123;phone&#125;) &lt;/insert&gt; &lt;!-- 使用&lt;insert&gt;元素添加客户信息并使用MyBatis提供的方式生成主键值 --&gt; &lt;insert id=\"addCustomer2\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\" &gt; &lt;selectKey keyProperty=\"id\" resultType=\"Integer\" order=\"BEFORE\"&gt; select if(max(id) is null,1,max(id)+1) as newId from t_customer &lt;/selectKey&gt; insert into t_customer(id,username,job,phone) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;job&#125;,#&#123;phone&#125;) &lt;/insert&gt; &lt;!-- 使用&lt;update&gt;元素更新客户信息 --&gt; &lt;update id=\"updateCustomerById\" parameterType=\"pers.huangyuhui.mybatis.bean.Customer\"&gt; update t_customer set username=#&#123;username&#125;,job=#&#123;job&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 使用&lt;delete&gt;元素删除客户信息 --&gt; &lt;delete id=\"deleteCustomerById\" parameterType=\"Integer\"&gt; delete from t_customer where id = #&#123;id&#125; &lt;/delete&gt; &lt;/mapper&gt; UserMapper.xml : 操作’t_user’数据表的映射文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pers.huangyuhui.mybatis.mapper.UserMapper\"&gt; &lt;!-- &lt;resultMap&gt;元素可解决数据表中的列与需要返回的对象的属性名可能不一致的问题 --&gt; &lt;resultMap type=\"pers.huangyuhui.mybatis.bean.User\" id=\"resultMap\"&gt; &lt;id property=\"id\" column=\"t_id\"/&gt; &lt;result property=\"name\" column=\"t_name\"/&gt; &lt;result property=\"age\" column=\"t_age\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUser\" resultMap=\"resultMap\"&gt; select t_id,t_name,t_age from t_user &lt;/select&gt;&lt;/mapper&gt; MyBatisUtils.java : MyBatis工具类 12345678910111213141516171819202122232425262728293031323334353637383940package pers.huangyuhui.mybatis.util;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * @ClassName: MyBatisUtils * @Description: MyBatis工具类 * @author: HuangYuhui * @date: May 18, 2019 3:59:18 PM * */public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; private static SqlSessionFactory sqlSessionFactory = null; static &#123; // 使用MyBatis提供的Resources类加载MyBatis的配置文件 try (Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");) &#123; // 构建SqlSessionFactory工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 获取SqlSession对象的静态方法 public static SqlSession getSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; MyBatisTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package pers.huangyuhui.mybatis.test;import java.io.IOException;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import pers.huangyuhui.mybatis.bean.Customer;import pers.huangyuhui.mybatis.bean.User;import pers.huangyuhui.mybatis.util.MyBatisUtils;/** * @ClassName: MyBatisTest * @Description: MyBatis核心配置: CURE * @author: HuangYuhui * @date: May 18, 2019 4:03:47 PM * */public class MyBatisTest &#123; private static Customer customer; private static String namespace = \"pers.huangyuhui.mybatis.mapper.CustomerMapper.\"; @BeforeClass public static void init() throws IOException &#123; customer = new Customer(); &#125; @Test @Ignore // 根据客户编id查询客户信息 public void findCustomerByIdTest() &#123; // 获取SqlSession对象 SqlSession sqlSession = MyBatisUtils.getSession(); // 执行SqlSession的查询方法,并返回结果 Customer customerInfo = sqlSession.selectOne(namespace + \"findCustomerById\", 1); // 输出查询结果信息 System.out.println(customerInfo); // 关闭SqlSession sqlSession.close(); &#125; @Test @Ignore // 插入客户信息并获取由数据库生成的主键值 public void addCustomerTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student ~\"); customer.setPhone(\"15111111111\"); int rows = sqlSession.insert(namespace + \"addCustomer\", customer); if (rows &gt; 0) &#123; System.out.println(\"插入数据的主键id值为: \" + customer.getId()); System.out.println(\"成功插入了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"插入数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 添加客户信息并使用MyBatis提供的方式生成主键值 public void addCustomer2Test() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"student ~\"); customer.setPhone(\"13111111111\"); int rows = sqlSession.insert(namespace + \"addCustomer2\", customer); if (rows &gt; 0) &#123; System.out.println(\"mybatis生成的主键为: \" + customer.getId()); System.out.println(\"成功插入了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"插入数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id更新客户信息 public void updateCustomerByIdTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); customer.setId(1); customer.setUsername(\"YUbuntu0109\"); customer.setJob(\"speaker\"); int rows = sqlSession.update(namespace + \"updateCustomerById\", customer); if (rows &gt; 0) &#123; System.out.println(\"成功更新了 \" + rows + \" 条数据哟 ~\"); &#125; else &#123; System.out.println(\"数据更新操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 根据客户id删除客户信息 public void deleteCustomerById() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); int rows = sqlSession.delete(namespace + \"deleteCustomerById\", 1); if (rows &gt; 0) &#123; System.out.println(\"成功删除了 \" + rows + \" 条记录哟 ~\"); &#125; else &#123; System.out.println(\"删除数据操作失败 !\"); &#125; sqlSession.commit(); sqlSession.close(); &#125; @Test @Ignore // 使用&lt;resultMap&gt;元素查找`t_user`表中所有用户信息 public void findAllUserTest() &#123; SqlSession sqlSession = MyBatisUtils.getSession(); List&lt;User&gt; users = sqlSession.selectList(\"pers.huangyuhui.mybatis.mapper.UserMapper.findAllUser\"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; log4j.properties : 日志配置文件 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring:Bean","slug":"Spring-Bean","date":"2019-05-14T14:04:41.000Z","updated":"2019-05-28T14:35:34.315Z","comments":true,"path":"2019/05/14/Spring-Bean/","link":"","permalink":"http://yoursite.com/2019/05/14/Spring-Bean/","excerpt":"","text":"学习笔记 : Spring BeanBean 的配置简介 : Spring可以被看成一个大型工厂,其作用是生产和管理Spring容器中的Bean,前提是需要在Sring配置文件中进行配置. Spring容器支持XML和Properties两种格式的配置文件.其前者最为常用哟! 在配置文件中,通常为一个Bean配置id或name和class两个属性即可,注意的是如果Bean中未指定id和name,则Spring会将class值当做id使用. Bean 的实例化简介 : 在Spring中,想要使用容器中的Bean时需要先将其实例化,其实例化的方式有三种,如下所示. 构造器实例化(最常用) : Spring容器通过Bean对应类中默认的无参构造方法来实例化Bean. 静态工厂方式实例化 : 将Bean配置中的class属性指定静态工厂类,然后使用factory-method属性来指定所创建的静态工厂方法. 实例工厂方式实例化 : 将需要实例化的Bean通过factory-bean属性指向配置的实例工厂,然后使用factory-method属性确定使用工厂中的具体方法. Bean 的实例化案例通过一个示例程序来演示实例化Bean的三种方式. Bean类 1234567891011121314151617181920package pers.huangyuhui.spring.bean.instance;//构造器实例化public class Bean1 &#123;&#125;package pers.huangyuhui.spring.bean.instance;//静态工厂方式实例化 public class Bean2 &#123;&#125;package pers.huangyuhui.spring.bean.instance;//实例工厂方式实例化public class Bean3 &#123;&#125; MyBean2Factory.java : 静态工厂 1234567891011121314151617package pers.huangyuhui.spring.bean.factory;import pers.huangyuhui.spring.bean.instance.Bean2;/** * @ClassName: MyBean2Factory * @Description: 静态工厂方式实例化 * @author: HuangYuhui * @date: May 24, 2019 2:08:00 PM * */public class MyBean2Factory &#123; public static Bean2 createBean() &#123; return new Bean2(); &#125;&#125; MyBean3Factory.java : 实例工厂 123456789101112131415161718192021package pers.huangyuhui.spring.bean.factory;import pers.huangyuhui.spring.bean.instance.Bean3;/** * @ClassName: MyBean3Factory * @Description: 实例工厂方式实例化 * @author: HuangYuhui * @date: May 24, 2019 2:16:03 PM * */public class MyBean3Factory &#123; public MyBean3Factory() &#123; System.out.println(\"this is constructor ~\"); &#125; public Bean3 createBean() &#123; return new Bean3(); &#125;&#125; applicationContext.xml : Spring核心配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 构造器实例化 --&gt; &lt;bean id=\"bean1\" class=\"pers.huangyuhui.spring.bean.instance.Bean1\"/&gt; &lt;!-- 静态工厂方式实例化 --&gt; &lt;!-- factory-method: 指定工厂方法 --&gt; &lt;bean id=\"bean2\" class=\"pers.huangyuhui.spring.bean.factory.MyBean2Factory\" factory-method=\"createBean\"/&gt; &lt;!-- 实例工厂方式实例化 --&gt; &lt;!-- factory-bean:指定配置的实例工厂 --&gt; &lt;bean id=\"myBean3Factory\" class=\"pers.huangyuhui.spring.bean.factory.MyBean3Factory\"/&gt; &lt;bean id=\"bean3\" factory-bean=\"myBean3Factory\" factory-method=\"createBean\"/&gt; &lt;/beans&gt; InstanceTest.java : 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package pers.huangyuhui.spring.bean.instance.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.bean.instance.Bean1;/** * @ClassName: InstanceTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 1:57:41 PM * */public class InstanceTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test @Ignore // 构造器实例化 public void instanceTest1() &#123; Bean1 bean1 = applicationContext.getBean(Bean1.class); // result : pers.huangyuhui.spring.bean.instance.Bean1@59402b8f System.out.println(bean1); &#125; @Test @Ignore // 静态工厂方式实例化 public void instanceTest2() &#123; // result : pers.huangyuhui.spring.bean.instance.Bean2@70ed52de System.out.println(applicationContext.getBean(\"bean2\")); &#125; @Test @Ignore // 实例工厂方式实例化 public void instanceTest3() &#123; // result : // this is constructor ~ // pers.huangyuhui.spring.bean.instance.Bean3@70ed52de System.out.println(applicationContext.getBean(\"bean3\")); &#125;&#125; Bean 的作用域简介 : 在Spring 4.3中为Bean定义了七种作用域,如下所示. Singleton(单例) : 使用Singleton定义的Bean在Spring容器中将只有一个实例,也就是说,无论有多少个Bean引用它,始终指向同一个对象,其也是Spring默认的作用域. prototype(原型) : 每次通过Spring容器获取prototype定义的Bean时,容器都将创建一个新的Bean实例. request : .. session : .. globalSession : .. application : .. websocket : .. Bean 的作用域案例下面通过简单程序来分别演示singleton和prototype作用域 Bean类 123456789101112package pers.huangyuhui.spring.bean.scope;//Bean的作用域: singleton public class Bean4 &#123;&#125;package pers.huangyuhui.spring.bean.scope;//Bean的作用域: prototypepublic class Bean5 &#123;&#125; Spring核心配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- singleton(default) --&gt; &lt;bean id=\"bean4\" class=\"pers.huangyuhui.spring.bean.scope.Bean4\" scope=\"singleton\"/&gt; &lt;!-- prototype --&gt; &lt;bean id=\"bean5\" class=\"pers.huangyuhui.spring.bean.scope.Bean5\" scope=\"prototype\"/&gt;&lt;/beans&gt; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.spring.bean.scope.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @ClassName: ScopeTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 2:53:10 PM * */public class ScopeTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test @Ignore // Bean的作用域: singleton public void singletonTest() &#123; // result: // pers.huangyuhui.spring.bean.scope.Bean4@7c137fd5 // pers.huangyuhui.spring.bean.scope.Bean4@7c137fd5 System.out.println(applicationContext.getBean(\"bean4\")); System.out.println(applicationContext.getBean(\"bean4\")); &#125; @Test @Ignore // Bean的作用域: prototype public void prototypeTest() &#123; // result: pers.huangyuhui.spring.bean.scope.Bean5@3e08ff24 System.out.println(applicationContext.getBean(\"bean5\")); &#125;&#125; Bean 的装配方式简介 : Bean的装配方式可以理解为依赖注入,Bean的装配方式既Bean依赖注入的方式. Spring容器支持多种形式的Bean的装配方式,如基于XML的装配,基于Annotation的装配等.. 基于XML的装配Spring提供了两种基于XML的装配方式: 设值注入(Setter Injection)和构造注入(Constructor Injection). 在Spring实例化Bean的过程中,Spring首先会调用Bean的默认构造方法来实例化Bean对象,然后通过反射的方式调用setter方式来注入属性值.因此,设值注入要求一个Bean必须满足一下两点要求. Bean类必须提供一个默认的无参构造方法. Bean类必须为需要注入的属性提供对应的setter方法. 下面通过一个简单示例程序来展示基于XML的Bean的装配方式. User.java : Java bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.spring.assemble.bean;import java.util.List;/** * @ClassName: User * @Description: 用户信息 * @author: HuangYuhui * @date: May 24, 2019 3:37:58 PM * */public class User &#123; private String name; private List&lt;String&gt; phone; public User() &#123; &#125; public User(String name, List&lt;String&gt; phone) &#123; super(); this.name = name; this.phone = phone; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getPhone() &#123; return phone; &#125; public void setPhone(List&lt;String&gt; phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", phone=\" + phone + \"]\"; &#125;&#125; applicationContext.xml : Spring核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 利用构造注入方式装配User实例 --&gt; &lt;bean id=\"user1\" class=\"pers.huangyuhui.spring.assemble.bean.User\"&gt; &lt;constructor-arg index=\"0\" value=\"YUbuntu0109-1\"/&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;value&gt;\"15111111111\"&lt;/value&gt; &lt;value&gt;\"15211111111&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 使用设值注入方式装配User实例 --&gt; &lt;bean id=\"user2\" class=\"pers.huangyuhui.spring.assemble.bean.User\"&gt; &lt;property name=\"name\" value=\"YUbuntu0109-2\"/&gt; &lt;property name=\"phone\"&gt; &lt;list&gt; &lt;value&gt;\"13111111111\"&lt;/value&gt; &lt;value&gt;\"18111111111\"&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; AssembleTest.java : 测试类 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.spring.assemble.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.assemble.controller.UserController;/** * @ClassName: AssembleTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 3:49:42 PM * */public class AssembleTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test // @Ignore // 测试基于XML的Bean配置 public void xmlBeanAssembleTest() &#123; // result: User [name=YUbuntu0109-1, phone=[\"15111111111\", \"15211111111]] System.out.println(applicationContext.getBean(\"user1\")); // result: User [name=YUbuntu0109-2, phone=[\"13111111111\", \"18111111111\"]] System.out.println(applicationContext.getBean(\"user2\")); &#125;&#125; 基于Annotation的装配简介 : 通过注解(Annotation)来实现Bean的装配工作可以解决XML配置文件过于臃肿的问题,且便于后期维护. 其常用注解如下. @Repository : 用于将数据访问层(DAO层)的类标识为Spring中的Bean. @Service : 通常作用在业务层(Service层),用于将业务层的类标识为Spring中的Bean. @Controller : 通过作用在控制层(如Spring MVC的Controller),用于将控制层的类标识为Spring中的Bean. @Autowired : 用于对Bean的属性变量,属性的setter方法及构造方法进行标注,配合对用的注解处理器来完成Bean的自动配置工作. 下面通过一个简单案例来演示如何通过这些注解来装配Bean. UserDao.java 123456package pers.huangyuhui.spring.assemble.dao;public interface UserDao &#123; public void save();&#125; UserDaoImple.java 12345678910111213141516171819202122package pers.huangyuhui.spring.assemble.dao.impl;import org.springframework.stereotype.Repository;import pers.huangyuhui.spring.assemble.dao.UserDao;/** * @ClassName: UserDaoImpl * @Description: UserDao的实现类 * @author: HuangYuhui * @date: May 24, 2019 4:13:53 PM * */@Repository(\"userDao\") // 将UserDaoImpl类标识为Spring中的Beanpublic class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"UserDao : Save function ~\"); &#125;&#125; 其中使用@Respository注解将UserDaoImpl类标识为Spring中的Bean,其写法相当于配置文件中的&lt;bean id=&quot;userDao&quot; class=&quot;pers.huangyuhui.spring.assemble.dao.impl.UserDaoImpl&quot;/&gt; UserService.java 123456package pers.huangyuhui.spring.assemble.dao;public interface UserService &#123; public void save();&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728package pers.huangyuhui.spring.assemble.dao.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import pers.huangyuhui.spring.assemble.dao.UserDao;import pers.huangyuhui.spring.assemble.dao.UserService;/** * @ClassName: UserServiceImpl * @Description: UserService的实现类 * @author: HuangYuhui * @date: May 24, 2019 4:20:15 PM * */@Service // 将UserServiceImpl类标识为Spring中的Beanpublic class UserServiceImpl implements UserService &#123; @Autowired // 自动配置Bean private UserDao userDao; @Override public void save() &#123; userDao.save(); System.out.println(\"UserService : Save function ~\"); &#125;&#125; UserController.java 1234567891011121314151617181920212223242526package pers.huangyuhui.spring.assemble.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import pers.huangyuhui.spring.assemble.dao.UserService;/** * @ClassName: UserController * @Description: TODO * @author: HuangYuhui * @date: May 24, 2019 4:33:56 PM * */@Repository /// 将UserController类标识为Spring中的Beanpublic class UserController &#123; @Autowired // 自动配置Bean private UserService userService; public void save() &#123; userService.save(); System.out.println(\"UserController : Save function ~\"); &#125;&#125; AssembleTest.java : 测试类 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.spring.assemble.test;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.assemble.controller.UserController;/** * @ClassName: AssembleTest * @Description: 测试 * @author: HuangYuhui * @date: May 24, 2019 3:49:42 PM * */public class AssembleTest &#123; private static ApplicationContext applicationContext; @BeforeClass public static void init() &#123; applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void annotationAssembleTest() &#123; UserController userController = (UserController) applicationContext.getBean(\"userController\"); userController.save(); &#125;&#125; Spring核心配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 扫描指定包下的所有Bean类,进行注解解析 --&gt; &lt;context:component-scan base-package=\"pers.huangyuhui.spring.assemble\"/&gt; &lt;/beans&gt; 程序运行结果 123UserDao : Save function ~UserService : Save function ~UserController : Save function ~","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"VOA:Facebook Co-founder Calls for New Laws Limiting Big Tech","slug":"VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech","date":"2019-05-12T14:01:54.000Z","updated":"2019-05-14T02:58:35.252Z","comments":true,"path":"2019/05/12/VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech/","link":"","permalink":"http://yoursite.com/2019/05/12/VOA-Facebook-Co-founder-Calls-for-New-Laws-Limiting-Big-Tech/","excerpt":"","text":"Facebook Co-founder Calls for New Laws Limiting Big TechFacebook co-founder Chris Hughes has called for the breakup of Facebook,the world’s largest social media company. 脸书联合创始人克里斯·休斯(Chris Hughes)呼吁分拆这家全国最大的社交媒体公司. Hughes says the United States has laws to control monopolies——businesses that control too much of an industry. He wants the U.S. goverment to user those laws to help protect people from technology and social media companies. 休斯表示,美国有反垄断法律,垄断企业是指在某行业占据过多市场份额的企业.他希望美国政府利用这些法律帮助人们免受科技和社交媒体的侵害. His comments appeared Thursday in an opinion in The New York Times. 他的这番话出现在周四《纽约时报》的一篇评论文章中. Facebook Inc. quickly rejecte his call. Facebook公司很快拒绝了他的这一呼吁. Hughes once shared a room in college with Mark Zuckerberg,who later became Facebook’s chief executive officer. 休斯曾经在大学里和马克·扎克伯格同一寝室,后来马克·扎克伯格称为了Facebook的首席执行官. “We are a nation with a tradition of reining in monopolies,no matter how well intentioned the leader of these of companies may be.Mark’s power is unprecedented and un-American,” Hughes wrote. “我们是一个有着控制垄断传统的国家,不管这些公司的领导人的意图有多好.马克的权利是前所未有的,非美式的.” 休斯写到. More than 2 billion people worldwide currently use Facebook,The company also owns WhatApp,Messenger and Instagram. Each service has more than 1 billion users. 目前全世界有超过20亿人在使用Facebook,该公司还拥有What’s App,Messenger和Instagram三大平台.每项服务都有超过10亿的用户. Chris Hughes co-founded Facebook with Zuckerberg and Dustin Moskovitz at Harvard University in 2004,He left the company in 2007. He later said in a Linkedln post that he earned $500 million for his three years of work. 2004,克里斯·休斯,扎克伯格和达斯汀·莫斯科维茨在哈佛大学共同创办了Facebook.休斯于2007年离开了公司,他后来在领英(LinkedIn)的一篇帖子中说:三年的工作让它赚了5亿美元. It’s been 15 years since I co-founder Facebook at Harvard,and I haven’t worked at the company in a decade. But I feel a sense of anger and responsibility,he wrote. “从我在哈佛与他们联合创办Facebook已经有15年了,我已经有10年没有在这家公司工作了,但我感到愤怒和一定的责任.” 他写到. Hughes helped Barack Obama with his presidential election campaign‘s online strategy during the 2008 political campaign. 休斯在2008年大选中帮助巴卡拉·奥巴马制定了他的总统竞选网络策略. Over the past two years,several security and privacy scandals have hit Facebook. Investigators found that the company,working with a now-closed consulting business,called Cambridge Analytica,shared information about 87 million users. In 2016,the election campaign of then presidential candidate Donald Trump used that information to target its advertising to Facebook users. 在过去的两年里,Facebook涉及数起安全和隐私丑闻.调查人员发现,该公司与一家目前已经关闭的名为剑桥分析的咨询公司合作,共享了8700万用户的信息,2016年,当时的总统候选人唐纳特·特朗普的竞选团队利用这些信息,将其宣传目标对准了Facebook用户. Hughes helped to design what Facebook called the “News Feed.” He said that his team should have thought more carefully about how that might be used. 休斯帮助设计了Facebook的”新闻推送”,他说,它的团队应该更仔细地考虑如何使用这一技术. Hughes said he last met with Zuckerberg in the summer of 2017,several months before the news came out about the Cambridge Analytica scandal. 休斯说,他最后一次见到马克伯格是在2017年的夏天,几个月后,剑桥分析公司的丑闻曝光. Mark is good,kind person. But I’m angry that his focus on growth led him to sacrifice security and civility for clicks,Hughes said. 休斯说: “马克是个善良的好人.但令我愤怒的是,他太关注公司的发展导致他为了点击量而牺牲了网络安全和文明.” He also said he worries that the people around Zuckerberg always agree with him and never question his ideas. Zuckerbeg cannot be dismissed,so he has total control of the company. 他还说,他担心扎克伯格身边的人总是时顺从他,从不质疑他的想法,扎克伯格不能被解雇,所以他拥有公司的完全控制权. Hughes is not alone in asking for backup of Facebook. Some U.S. lawmakers have called for federal privacy rules and new laws to break up big tech companies. 休斯并不是唯一一个要求拆分Facebook的人.一些美国会议员呼吁制定联邦隐私法规和新法律来削弱大型科技公司. Senator Richard Blumenthal of Connecticut said on Thursday he thinks Facebook needs to be broken up. He also called for the Justice Department’s antitrust to launch an investigation. 康涅狄克州参议员查德·不卢门撒尔周四表示,他认为Facebook需要拆分.他还呼吁司法部反垄断部门对其展开调查. In March,Massachusetts Senator Elizabeth Warren promised to break up Facebook,Amazon.com Inc. and Alphabet Inc.’s Google,if elected president.She thinks that action would help to support competition in the tech field. 今年三月,马萨诸塞州参议员伊丽莎白·沃伦承若,如果当选总统,她将拆分Facebook,亚马逊和谷歌,他认为,这一行动将有助于支持科技领域的竞争. Facebook rejected Hughes’call for WhatApp and Instagram to be made into separate businesses. The social media company said that attention should be directed instead on creating rules for the internet. Facebook拒绝了休斯将WhatApp和Instagram拆分成两家公司的提议.这家社交媒体公司表示,应该把注意力转向为制定互联网规则. Facebook accepts that with success comes accountability. But you don’t enforce accountability by calling for the break up of a successful American company,a spokesperson said in the statement. “Facebook承认,成功伴随着责任.但拆分一家成功的美国公司并不能强化问责制,” 一位发言人在声明表示. I’m Jill Robbins. 重点词汇 breakup (n) 解体,分裂. monopoly (n) 垄断,垄断者. industry (n) 产业,工业. election (n) 选举,当选. campaign (n) 运动,活动. scandal (n) 丑闻,流言蜚语. investigator (n) 研究者,调查者. investigation (n) 调查研究. advertising (n) 广告. lawmaker (n) 立法者. justice (n) 司法. field (n) 领域. spokesperson (n) 发言人,代言人. accountability (n) 有义务,有责任 intentioned (a) 出于..意向的,有..企图的 unprecedented (a) 空前的,无前例的. executive (a) 行政的,经营的. presidential (a) 总统的,首长的. political (a) 政治的,党派的. several (a) 几个的,各自的. consulting (a) 咨询的,商议的. federal (a) 联邦的. antitrust (a) [经]反垄断的. rein (v) 控制. dismiss (v) 解散,解雇. separate (v) 分开,隔开. enforce (v) 强迫,强制. chief (adv) 主要地,首要地. Inc (abbr) 股份有限公司(incorporated) 重点短语 called for : 提倡,要求. break up : 拆分,解散.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Hi MyBatis ~","slug":"Hi-MyBatis","date":"2019-05-09T13:02:06.000Z","updated":"2019-05-14T11:08:27.186Z","comments":true,"path":"2019/05/09/Hi-MyBatis/","link":"","permalink":"http://yoursite.com/2019/05/09/Hi-MyBatis/","excerpt":"","text":"学习笔记 : 初识MyBatis简介 : MyBatis的前身是iBATIS,是Clinton Begin在2001年发起的一个开源项目,最初侧重于密码软件的开发,后来发展成为一款基于Java的持久层框架.2004年,Clinton将iBATIS的名字和源码捐赠给了Apache软件基金会.2010年,核心开发团队决定离开Apache软件基金会,并且将iBATIS该名为MyBatis. MyBatis 工作原理MyBatis框架执行流程图如下所示 : 从MyBatis框架执行流程图中可得知,MyBatis框架在操作数据库时,大体经过了8个步骤.下面对每一步进行详解哟 ~ 读取MyBatis配置文件mybatis-config.xml.其作为MyBatis的全局配置文件,配置了MyBatis的运行环境等信息,其中主要内容是获取数据库连接. 加载映射配置文件Mapper.xml.既SQL映射文件,该文件配置了操作数据库的SQL语句,需要在mybatis-config.xml中加载才能执行.mybatis-config.xml可以加载多个配置文件,每个配置文件对应数据库中的一张表. 构建会话工厂.通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory. 创建SqlSession对象.由会话工厂创建SqlSession对象,该对象中包含了执行SQL的所有方法. MyBatis底层定义了一个Executor接口来操作数据库,它会根据SqlSession传递的参数动态地生成需要执行的SQL语句,同时负责查询缓存的维护. 在Executor接口的执行方法中,包含一个MappedStatement类型的参数,该参数是对映射信息的封装,用于存储要映射的SQL语句的id,参数等.. Mapper.xml文件中一个SQL对应一个MappedStatement对象,SQL的id既是MappedStatement的id. 输入参数映射,其过程类似于JDBC编程中对preparedStatement对象设置参数的过程. 输出参数映射,其过程类似于JDBC编程中对结果的解析处理过程. MyBatis 入门程序 User.java : 一个简单Java bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.mybatis.bean;/** * @ClassName: User * @Description: 封装用户信息 * @author: HuangYuhui * @date: May 9, 2019 5:07:23 PM * */public class User &#123; private Integer id; private String name; private String gender; private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", name=\" + name + \", gender=\" + gender + \", email=\" + email + \"]\"; &#125;&#125; db.properties : 数据库配置信息文件. 12345#database configuration informationjdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://LOCALHOST/MyBatis?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=GoodTime mybatis-config.xml : MyBatis核心配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!-- 配置环境-默认环境id为MySQL --&gt; &lt;environments default=\"MySQL\"&gt; &lt;environment id=\"MySQL\"&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将sql映射文件注册到全局配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserTest.java : 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pers.huangyuhui.mybatis.bean.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import pers.huangyuhui.mybatis.bean.User;/** * @ClassName: UserTest * @Description: Test Mybatis * @author: HuangYuhui * @date: May 9, 2019 5:26:52 PM * */public class UserTest &#123; InputStream inputStream; SqlSessionFactory sqlSessionFactory; SqlSession sqlSession; @Test public void test() &#123; try &#123; // 读取配置文件 inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 根据配置文件构建会话工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 通过SqlSessionFactory创建SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行映射文件中定义的SQL并返回映射结果 User user = sqlSession.selectOne(\"Namespace.UserInfoMapper.SelectUserInfoByID\", 1); System.out.println(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125;&#125; log4j.properties : 日志文件(便于查看MyBatis操作数据库的过程). 12345678#Global configurationlog4j.rootLogger=DEBUG,stdout#Log configurationlog4j.logger.pers.huangyuhui.mybatis.bean.test=TRACE#Console configurationlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.layout.ConversionPattern=%5p [%t] - %m%n 程序运行结果如下所示 1234567891011121314151617Logging initialized using &apos;class org.apache.ibatis.logging.log4j.Log4jImpl&apos; adapter.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.Opening JDBC ConnectionCreated connection 1238080693.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]==&gt; Preparing: select id,name,gender,email from Test_MyBatis where id = ? ==&gt; Parameters: 1(Integer)&lt;== Total: 1User [id=1, name=YUbuntu0109, gender=M, email=Gentleman_0109@outlook.com]Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@49cb9cb5]Returned connection 1238080693 to pool.","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Hi Spring ~","slug":"Hi-Spring","date":"2019-05-09T13:01:53.000Z","updated":"2019-05-14T08:47:04.973Z","comments":true,"path":"2019/05/09/Hi-Spring/","link":"","permalink":"http://yoursite.com/2019/05/09/Hi-Spring/","excerpt":"","text":"学习笔记 : 初识 SpringSpring 简介Spring是由Rod Johnson组织和开发的一个分层的Java SE/EE full-stack(一站式)轻量级开源框架,它以IoC(Inversoin of Control,控制反转)和AOP(Aspect Oriented Programming,面向切面编程)为内核,使用基本的JavaBean来完成以前只可能由EJB(Enterprise Java Beans,Java企业Bean)完成的工作.取代了EJB的臃肿,低效的开发模式哟 ! Spring 框架优点Spring 具有简单,可测试和松耦合等特点,从这个角度出发,Spring可适用于服务器端/任何Java应用的开发. 非侵入式设计 方便耦合,简化开发 支持AOP 支持声明式事务处理 方便程序的测试 方便集成各种优秀的框架 降低Java EE API的使用难度 Spring 核心容器Spring框架的主要功能是通过其核心容器来实现.Spring框架提供了两种核心容器,分别是BeanFatory和ApplicatoinContext. BeanFactoryBeanFactory为基础类型的Ioc容器,简单的说就是一个管理Bean的工厂,它主要负责初始化各种Bean,并调用它们的生命周期方法. ApplicationContextApplicationContext是BeanFactory的子接口,也称为应用上下文,不仅包含了BeanFactory的所有功能,还添加了对国际化,资源访问,事件传播等方面的支持.有两种创建ApplicatoinContext接口实例的方法. 通过ClassPathXmlApplicationContext创建通过类路径classPath中寻找指定的XML配置文件,找到并装载完成ApplicationContext的实例化工作. 通过FileSystemXmlApplicatoinContext创建通过指定的文件系统路径(绝对路径)中寻找指定的XML配置文件,找到并装载完成ApplicationContext的实例化工作. 依赖注入依赖注入的作用就是在使用Spring框架创建对象时,动态地将其所依赖的对象注入Bean组件中,其实现方式通常有两种,一种是属性setter方法注入,另一种是构造方法注入. 属性setter方法注入指Spring容器使用setter方法注入被依赖的实例.通过调用无参的构造器或无参静态工厂方法实例化Bean后,调用该Bean的setter方法,即可实现基于setter方法的依赖注入. 构造方法注入指Spring容器使用的构造方法注入被依赖的实例.基于构造方法的依赖注入通过带参数的构造方法来实现,每个参数代表着一个依赖. Spring 简单示例程序 创建一个简单的Java bean 12345678910111213141516171819package pers.huangyuhui.spring.bean;public class HiSpring5 &#123; private String name; public HiSpring5() &#123; System.out.println(\"The Constructor be called !\"); &#125; public void setName(String name) &#123; System.out.println(\"setName(String name) method be called !\"); this.name = name; &#125; public void ouputName() &#123; System.out.println(\"ouputName() method: my name is \" + name + \" !\"); &#125;&#125; 创建Spring的配置文件: applicationContext.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- id: IOC容器中Bean的唯一标识 class: 通过反射机制在IOC容器中创建Bean(所以要求Bean中必须有无参的构造器). --&gt; &lt;bean id=\"SpringTestID\" class=\"pers.huangyuhui.spring.bean.HiSpring5\"&gt; &lt;!-- 初始化HiSpring类中的属性名为name的值 --&gt; &lt;property name=\"name\" value=\"Spring\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213141516171819202122232425package pers.huangyuhui.spring.bean.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pers.huangyuhui.spring.bean.HiSpring5;public class Spring5Test &#123; @Test public void test() &#123; // 创建Spring的IOC对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 从IOC容器中获取Bean实例 HiSpring5 hiSpring5 = (HiSpring5) applicationContext.getBean(\"SpringTestID\"); hiSpring5.ouputName(); &#125;&#125; 程序运行结果如下 12345678May 14, 2019 4:23:28 PM org.springframework.context.support.ClassPathXmlApplicationContext prepareRefreshINFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@a2431d0: startup date [Tue May 14 16:23:28 CST 2019]; root of context hierarchyMay 14, 2019 4:23:28 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from class path resource [applicationContext.xml]The Constructor be called !setName(String name) method be called !ouputName() method: my name is Spring !","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Java web:JSP Model","slug":"Java-web-JSP-Model","date":"2019-05-05T14:11:44.000Z","updated":"2019-05-06T04:38:16.746Z","comments":true,"path":"2019/05/05/Java-web-JSP-Model/","link":"","permalink":"http://yoursite.com/2019/05/05/Java-web-JSP-Model/","excerpt":"","text":"学习笔记 : Java web之JSP 开发模型JSP Model1简介 : JSP Model1采用JSP+JavaBean的技术,将页面显示和业务逻辑分开.其中,JSP实现流程控制和页面显示,JavaBean对象封装数据和业务逻辑.这种设计实现了数据,业务逻辑和页面显示的分离,在一定程度上实现了程序开发的模块化,降低了程序修改和维护的难度. JSP Model1 案例案例描述 : 通过一个简单的网络计算器程序来深化对JSP Model1模型的理解. Calculator.java : 封装计算器中的数据,处理业务逻辑. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package pers.huangyuhui.jspmodel.model1.calculator;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;import java.util.regex.Pattern;/** * @ClassName: Calculator * @Description: 封装计算器中的数据及处理业务逻辑 * @author: HuangYuhui * @date: May 5, 2019 10:10:43 AM * */public class Calculator &#123; private char operator; private String firstNumber; private String secondNumber; private Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;();// 封装错误信息 public String getFirstNumber() &#123; return firstNumber; &#125; public void setFirstNumber(String firstNumber) &#123; this.firstNumber = firstNumber; &#125; public String getSecondNumber() &#123; return secondNumber; &#125; public void setSecondNumber(String secondNumber) &#123; this.secondNumber = secondNumber; &#125; public char getOperator() &#123; return operator; &#125; public void setOperator(char operator) &#123; this.operator = operator; &#125; public Map&lt;String, String&gt; getErrors() &#123; return errors; &#125; public void setErrors(Map&lt;String, String&gt; errors) &#123; this.errors = errors; &#125; // 运算操作 public String caculate() &#123; BigDecimal result = null; BigDecimal firstNum = new BigDecimal(firstNumber); BigDecimal secondNum = new BigDecimal(secondNumber); switch (operator) &#123; case '+': result = firstNum.add(secondNum); break; case '-': result = firstNum.subtract(secondNum); break; case '*': result = firstNum.multiply(secondNum); break; case '/': if (\"0\".equals(secondNumber)) &#123; // throw new RuntimeException(\"除数不能为 0 !\"); return null; &#125; result = firstNum.divide(secondNum); break; default: break; &#125; return result.toString(); &#125; // 验证表单传入的数据是否合法 public boolean validate() &#123; boolean flag = true; Pattern pattern = Pattern.compile(\"\\\\d+\");// 匹配数字 if (firstNumber == null || \"\".equals(firstNumber)) &#123; errors.put(\"firstNumberErrorInfo\", \"第一个运算数不能为空 !\"); flag = false; &#125; else if (!pattern.matcher(firstNumber).matches()) &#123; errors.put(\"firstNumberErrorInfo\", \"第一个运算数必须为数字 !\"); flag = false; &#125; if (secondNumber == null || \"\".equals(secondNumber)) &#123; errors.put(\"secondNumberErrorInfo\", \"第二个运算数不能为空 !\"); flag = false; &#125; else if (!pattern.matcher(secondNumber).matches()) &#123; errors.put(\"secondNumberErrorInfo\", \"第二个运算数必须为数字 !\"); flag = false; &#125; else if (\"0\".equals(secondNumber)) &#123; errors.put(\"secondNumberErrorInfo\", \"被除数不能为 0 !\"); flag = false; &#125; return flag; &#125;&#125; calculator.jsp : 显示网络计算机的页面. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.Map\"%&gt;&lt;jsp:useBean id=\"calculator\" class=\"pers.huangyuhui.jspmodel.model1.calculator.Calculator\"/&gt;&lt;jsp:setProperty property=\"*\" name=\"calculator\"/&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 1&lt;/title&gt; &lt;style&gt; span&#123; font-size:13px; color:red; &#125; #main&#123; width:600px; margin-left: 425px; &#125; #main tr&#123; height:40px; &#125; #main tr td&#123; width: 50px; &#125; #main tr td input&#123; width: 200px; &#125; .buttom &#123; text-align: center; padding-top: 25px; &#125; .buttom .calculate&#123; margin-right: 65px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;JSP Mode 1 : 计算器&lt;/h3&gt;&lt;hr/&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;table id=\"main\"&gt; &lt;tr&gt; &lt;td&gt; 第一个运算数&lt;/td&gt; &lt;td &gt; &lt;input type=\"text\" name=\"firstNumber\"/&gt; &lt;span&gt;$&#123;errors.firstNumberErrorInfo &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 运算符&lt;/td&gt; &lt;td&gt; &lt;select name=\"operator\" style=\"margin-left:65px\"&gt; &lt;option value=\"+\"&gt;+&lt;/option&gt; &lt;option value=\"-\"&gt;-&lt;/option&gt; &lt;option value=\"*\"&gt;*&lt;/option&gt; &lt;option value=\"/\"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二个运算符&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"secondNumber\"/&gt; &lt;span&gt;$&#123;errors.secondNumberErrorInfo &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;运算结果: &lt;/td&gt; &lt;td&gt; &lt;% Map&lt;String,String&gt; errorInfo = calculator.getErrors(); if(calculator.validate())&#123; pageContext.getSession().removeAttribute(\"errors\"); %&gt; &lt;font color=\"green\"&gt; &lt;jsp:getProperty property=\"firstNumber\" name=\"calculator\"/&gt; &lt;jsp:getProperty property=\"operator\" name=\"calculator\"/&gt; &lt;jsp:getProperty property=\"secondNumber\" name=\"calculator\"/&gt; = &lt;%=calculator.caculate() %&gt; &lt;% &#125;else&#123; pageContext.getSession().setAttribute(\"errors\",errorInfo); &#125; %&gt; &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=\"buttom\"&gt; &lt;input class=\"calculate\" type=\"submit\" value=\"计算\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图. JSP Model2简介 : JSP Model2架构模型采用JSP+Servlet+JavaBean技术,其将JSP Model1中JSP页面里的流程控制代码提取出来.封装到Servlet中,从而实现了整个程序页面显示,流程控制和业务逻辑的分离.实际上JSP Model2就是MVC设计模式,其中控制器(Colltroller)的角色由Servlet实现,视图(View)的角色由JSP实现,模型(Model)的角色由JavaBean实现. JSP Model2 案例案例描述 : 按照JSP Model2的模型思想编写一个用户注册的简单示例程序. UserBean.java : 封装用户的注册信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.jspmodel.model2.register;/** * @ClassName: UserBean * @Description: 封装用户注册信息 * @author: HuangYuhui * @date: May 5, 2019 4:35:21 PM * */public class UserBean &#123; private String name; private String password; private String email; public UserBean(String name, String password, String email) &#123; super(); this.name = name; this.password = password; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; RegisterFormBean.java : 封装并效验注册表单信息的JavaBean. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package pers.huangyuhui.jspmodel.model2.register;import java.util.HashMap;import java.util.Map;/** * @ClassName: RegisterFormBean * @Description: 效验注册表单信息 * @author: HuangYuhui * @date: May 5, 2019 4:37:33 PM * */public class RegisterFormBean &#123; private String name; private String password; private String password2; private String email; // 存储验证表单时发生的错误信息 private Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); public RegisterFormBean(String name, String password, String password2, String email) &#123; super(); this.name = name; this.password = password; this.password2 = password2; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPassword2() &#123; return password2; &#125; public void setPassword2(String password2) &#123; this.password2 = password2; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; // 获取注册信息效验时发生的错误信息 public Map&lt;String, String&gt; getErrors() &#123; return errors; &#125; // 添加注册信息效验时发生的错误信息 public void setErrorsMsg(String error, String errorMsg) &#123; if ((error) != null &amp;&amp; (errorMsg != null)) &#123; errors.put(error, errorMsg); &#125; &#125; // 校验用户注册信息 public boolean validate() &#123; boolean flag = true; if (name == null || name.trim().equals(\"\")) &#123; errors.put(\"nameErrorInfo\", \"请输入用户名 !\"); flag = false; &#125; if (password == null || password.trim().equals(\"\")) &#123; errors.put(\"passwordErrorInfo\", \"请输入密码 !\"); flag = false; &#125; else if (password.length() &gt; 16 || password.length() &lt; 6) &#123; errors.put(\"passwordErrorInfo\", \"请输入6-12位的密码 !\"); flag = false; &#125; if (password != null &amp;&amp; !password.equals(password2)) &#123; errors.put(\"password2ErrorInfo\", \"两次输入的密码不相同 !\"); flag = false; &#125; if (email == null || email.trim().equals(\"\")) &#123; errors.put(\"emailErrorInfo\", \"请输入邮箱地址 !\"); flag = false; &#125; else if (!email.matches(\"[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\\\.[a-zA-Z0-9_-]+)+\")) &#123; errors.put(\"emailErrorInfo\", \"邮箱地址格式错误 !\"); flag = false; &#125; return flag; &#125;&#125; DBUtil.java : 访问数据库的辅助类,充当DAO. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.jspmodel.model2.register;import java.util.HashMap;/** * @ClassName: DBUtil * @Description: 模拟数据库,充当DAO * @author: HuangYuhui * @date: May 5, 2019 4:50:10 PM * */public class DBUtil &#123; private static DBUtil instance = new DBUtil(); private HashMap&lt;String, UserBean&gt; users = new HashMap&lt;String, UserBean&gt;(); private DBUtil() &#123; // 向数据库中添加一条用户数据 UserBean firstUser = new UserBean(\"YUbuntu0109\", \"myPassword\", \"Gentleman_0109@outlook.com\"); users.put(\"YUbuntu0109\", firstUser); &#125; public static DBUtil getInstance() &#123; return instance; &#125; // 获取数据库中指定用户名的数据 public UserBean getUser(String userName) &#123; UserBean user = users.get(userName); return user; &#125; // 向数据库中添加新的用户数据 public boolean insertUser(UserBean user) &#123; if (user == null) &#123; return false; &#125; String userName = user.getName(); if (users.get(userName) != null) &#123; return false; &#125; users.put(userName, user); return true; &#125;&#125; ControllerServlet.java : 控制器,负责处理用户注册的请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package pers.huangyuhui.jspmodel.model2.register;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ColltrollerServlet * @Description: 处理用户注册请求 * @author: HuangYuhui * @date: May 5, 2019 5:01:46 PM * */@WebServlet(\"/ControllerServlet\")public class ControllerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ControllerServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html;charset=utf-8\"); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String password2 = request.getParameter(\"userPassword2\"); String email = request.getParameter(\"userEmail\"); // 效验用户提交的注册表单信息 RegisterFormBean registerFormBean = new RegisterFormBean(name, password, password2, email); if (!registerFormBean.validate()) &#123; request.setAttribute(\"registerFromBean\", registerFormBean); request.getRequestDispatcher(\"/register.jsp\").forward(request, response); return; &#125; // 存储用户注册信息 UserBean userBean = new UserBean(name, password2, email); if (!DBUtil.getInstance().insertUser(userBean)) &#123; request.setAttribute(\"BDUtilErrorInfo\", \"抱歉! 你注册的用户名已存在啦 !\"); request.setAttribute(\"registerFromBean\", registerFormBean); request.getRequestDispatcher(\"/register.jsp\").forward(request, response); return; &#125; request.getSession().setAttribute(\"userBean\", userBean); response.getWriter().print(\"注册成功啦 ! 三秒后将自动跳转到用户注册信息的页面 !\"); response.setHeader(\"refresh\", \"3;url=registerInfo.jsp\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; register.jsp : 用户注册页面. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 2&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3&#123; text-align:center; &#125; #main&#123; width:600px; margin-left: 450px; &#125; #main tr&#123; height:40px; &#125; #main tr td&#123; width: 50px; &#125; #main tr td input&#123; width: 200px; &#125; span&#123; font-size:13px; color:red; &#125; .buttom &#123; text-align: center; padding-top: 25px; &#125; .buttom .register&#123; margin-right: 70px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"ControllerServlet\" method=\"post\"&gt; &lt;table id=\"main\"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\" value=\"$&#123;registerFromBean.name &#125;\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.nameErrorInfo &#125; $&#123;BDUtilErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"userPassword\" /&gt; &lt;span&gt; $&#123;registerFromBean.errors.passwordErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"userPassword2\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.password2ErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userEmail\" value=\"$&#123;registerFromBean.email &#125;\"/&gt; &lt;span&gt; $&#123;registerFromBean.errors.emailErrorInfo &#125; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=\"buttom\"&gt; &lt;input class=\"register\" type=\"submit\" value=\"注册\"/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; registerInfo.jsp : 用户注册成功页面. 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSP Model 2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;JSP Mode2 : 用户注册信息&lt;/h3&gt; &lt;hr/&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;sessionScope.userBean == null &#125;\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/register.jsp\"&gt;你还未注册! 请注册哟ヾ(●´∀｀●) ~&lt;/a&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;div align=\"center\"&gt; &lt;p&gt;你的姓名: $&#123;sessionScope.userBean.name &#125;&lt;/p&gt; &lt;p&gt;你的邮箱: $&#123;sessionScope.userBean.email &#125;&lt;/p&gt; &lt;/div&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Critics Praise New and Last Avengers Series Film","slug":"VOA-Critics-Praise-New-and-Last-Avengers-Series-Film","date":"2019-05-02T14:13:07.000Z","updated":"2019-05-06T00:23:29.078Z","comments":true,"path":"2019/05/02/VOA-Critics-Praise-New-and-Last-Avengers-Series-Film/","link":"","permalink":"http://yoursite.com/2019/05/02/VOA-Critics-Praise-New-and-Last-Avengers-Series-Film/","excerpt":"","text":"Critics Praise New and Last Avengers Series FilmMany movie critics are giving high praise to Avengers: Endgame,the final film in the superhero series from Walt Disney’s Marvel Studios. 许多影评人对《复仇者联盟:终局》都给予了高度评价,该电影是华特迪士尼漫威工作室超级英雄系列电影的最后一部. As of Tuesday,all but one of 56 Endgame critiques on the Rotten Tomatoes website were rated as positive. 截止到周二,烂番茄网站上出现的56篇有关《终局》的评论中,除了一篇之外 其余都是正面评论. USA Today’s Brain Truitt called the three-hour film “glorious“. He especially praised the time-travel part of the story. He said the movie includes returns to past happenings,which will please fans of superheroes like Iron Man and Thor. 《今日美国》的布莱恩·特鲁伊特称这部三个小时的电影”极其壮观”.他特别赞扬了故事中穿越时空的部分.他说,这部电影中出现的对过去发生的事情的回顾,可以取悦像钢铁侠和雷神这样的超级英雄的粉丝. But “it’s also a singular story”,Truitt said. 但是,”它也是一个奇艺非凡的故事,”特鲁伊说. The final film begins where last year’s Avengers: Infinity War ended,when several beloved heroes appeared to turn to dust. 最后一部电影以去年的《复仇者联盟3:无限战争》结束的地方为开端,当时几位深爱观众喜爱的英雄人物几乎都化为了灰烬. CNN’s Brain Lowry said Endgame is a winning finish. 美国广播电视公司的布莱恩·洛瑞表示,《复仇者联盟:终局》是胜利的结束. “The filmmakers have sought to reward movie-goers with a spectacle that’s epic in every way,” Lowry said. “电影制作人试图用史诗般的场面回报电影观众.” 洛瑞说. He alse wrote that there are several real surprises in the movie.and a lot of humor and emotional moments,as well. 他还写到,电影中还有一些惊喜,以及很多幽默和令人感动的时刻. A.O.Scott of The New York Times said the movie provides a “sense of an ending,” even though many characters are expected to return in future films. 《纽约时报》的斯科特说,这部电影让人们得到一种”结局感”,尽管很多角色都有望在未来的电影中回归. Scott wrote,”We’ve lived with these character and actors playing them for more than 10 years.” He added: “For the most part,it’s nice to see them again,and a little sad to say goodbye.” 斯科特写道: “我们和这些角色以及扮演他们的演员生活在一起已经有10多年.” 他补充道: “在很大程度上,在此见到他们很高兴,但说再见时有点伤感.” Esther Zuckerman of Thrillist agrees. “Endgame reinforces that there’s still a beating heart beneath all the machinery,” she wrote. 推尔名单网站的埃斯特·祖克曼对此表示赞同.”《终局》强化了一个概念,既所有机器下面仍有一颗跳动的心,” 她写到. Not everyone is pleased with the new film,Barry Herhz of Canada’s Globe and Mail newspaper calls Avengers: Endgame “shockingly boring.” 然而,并不是每个人都对这部电影感到满意.加拿大《环球邮报》的巴里·赫兹称《复仇者联盟:终局》”无聊至极.” Movie experts say the film may break records for opening weekend ticket sales in the United States and Canada. That record now stands at $257.7 million,set by Avengers: Infinity War. 电影专家表示,这部电影可能会打破美国和加拿大首映周末票房的记录.目前记录是由《复仇者联盟3:无限战争》创下的2.577亿美元. I’m Ashley Thompson. 重点词汇 critic (n) 批评家,评论家. avenger (n) 复仇者. series (n) 系列,连续. disney (n) 迪斯尼. studio (n) 工作室. endgame (n) 最后阶段,尾声. infinity (n) 无穷,无限大. filmmaker (n) 电影制作人. spectacle (n) 景象,场面. critique (n) 批评,评论文章. rotten (a) 腐烂的,堕落的. glorious (a) 光荣的,辉煌的. singular (a) 非凡的,单一的. beloved (a) 心爱的,挚爱的. epic (a) 史诗的,叙事诗的. emotional (a) 情绪的,感动人的. several (a) 几个的,各自的. reinforce (v) 加强,补充. beneath (ad) 在下方. shockingly (ad) 非常地. 重点短语 were rated as : 被看做,被评为.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Java web:Cookie and Session","slug":"Java-web-Cookie-and-Session","date":"2019-05-02T01:33:30.000Z","updated":"2019-05-02T14:05:57.558Z","comments":true,"path":"2019/05/02/Java-web-Cookie-and-Session/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Cookie-and-Session/","excerpt":"","text":"学习笔记 : Java web之会话及其会话技术概述在Web开发中,服务器跟踪用户信息的技术成为会话技术,它指的是一个客户端(浏览器)与Web服务器之间连续发生的一系列请求和响应的过程.为了保存会话过程中产生的数据,在Servlet技术中,提供了两个用于保存会话数据的对象,分别是Cookie和Session. Cookie objectCooke是一种会话技术,它用于将会话过程中的数据保存到用户的浏览器中,从而使浏览器和服务器可以更好地进行数据交互.Cookie在浏览器和服务器之间的传输过程示例图如下 : Cookie application显示用户上次访问时间案例描述 : 当用户请求LastAccessServlet时,服务器会调用HttpServletResponse接口的addCookie(Cookie cookie)方法,该方法会在发送给浏览器的HTTP响应消息中增加一个Set-Cookie头字段,将创建的Cookie对象作为Set-Cookie头字段的值传递给浏览器.示例程序如下 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@WebServlet(\"/LastAccessServlet\")public class LastAccessServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LastAccessServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String lastAccessTime = null;// 最后一次登录的时间 // 获取所有cookie,并将其存放到数组中 Cookie[] cookies = request.getCookies(); for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; // 如果cookie的名称为lastAccess,则获取其对应的cookie值 if (\"lastAccess\".equals(cookies[i].getName())) &#123; lastAccessTime = cookies[i].getValue(); break; &#125; &#125; // 判断是否存在名称为lastAccess的cookie if (lastAccessTime == null) &#123; response.getWriter().println(\"the first to visit this page !\"); &#125; else &#123; response.getWriter().println(\"the time of last visited : \" + lastAccessTime); &#125; // 创建cookie,并将当前时间作为名为lastAccess的cookie的值 String currentTime = new SimpleDateFormat(\"YYYY-MM-dd—&gt;hh:mm:ss\").format(new Date()); Cookie cookie = new Cookie(\"lastAccess\", currentTime); // 设置Cookie对象在客户端的存活时长,默认值为 -1 cookie.setMaxAge(60); // 设置该Cookie项的有效目录路径 cookie.setPath(\"/Cookie-Session_basic\"); // 发送cookie到客户端 response.addCookie(cookie); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Session objectCookie技术可以将用户的信息保存在各自的浏览器中,并且可以在多次请求下实现数据的共享.但是,如果传递的信息比较多,使用Cookie技术显然会增加服务器端程序处理的难度.这时,可以使用Session实现,Session是一种将会话数据保存到服务器端的技术.当浏览器访问Web服务器时,Servlet容器就会创建一个Session对象和ID属性,当客户端后续访问服务器时,只要将标识号传递给服务器,服务器就能判断出该请求是哪个客户端发送的,从而选择与之对应的Session对象为其服务.需要注意的是 : 由于客端户需要接收,记录,回送Session对象的ID,因此,通常情况下,Session是借助Cookie技术来传递ID属性的 ! HttpSession APISession是与每个请求消息紧密相关的,HttpServletRequest接口中定义了用于获取Session对象的getSession()方法,该方法有两种重载形式.1234// 根据传递的参数来判断是否创建新的HttpSession对象public HttpSession getSession(boolean create);// 在相关的HttpSession对象不存在时总是创建新的HttpSession对象public HttpSession getSession(); Session超时管理为了解决不再使用的HttpSession对象会在Web服务器中因积累过多从而导致Web服务器内存耗尽的问题,Web服务器采用了超时限制的办法来判断客户端是否还在继续访问.在会话过程中,会话的有效时间可以在web.xml文件中设置,其默认值由Servlet容器定义.如果想使站点内的所有Web应用程序都起作用,可以配置&lt;Tomcat directory&gt;\\conf\\web.xml文件,如下所示 :1234567&lt;!-- ==================== Default Session Configuration ================= --&gt; &lt;!-- You can set the default session timeout (in minutes) for all newly --&gt; &lt;!-- created sessions by modifying the value below. --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; Session application实现购物车案例描述 : 购物车的的实现流程如下图所示,当用户使用浏览器访问某个网站的图书列表页面时,如果购买某一本书,那么首先会判断书籍是否存在,如果存在就加入购物车,跳转到购物车中所购买图书的列表页,否则,返回图书列表页面. Book.java : 用于封装图书的信息. 123456789101112131415161718192021222324252627282930313233343536package pers.huangyuhui.session.example.shoppingtrolley;/** * @ClassName: Book * @Description: 封装图书的信息 * @author: HuangYuhui * @date: Apr 29, 2019 4:52:20 PM * */public class Book &#123; private String id; private String name; public Book(String book_id, String book_name) &#123; id = book_id; name = book_name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; BookDB.java : 用于模拟保存所有图书的数据库. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.session.example.shoppingtrolley;import java.util.Collection;import java.util.LinkedHashMap;import java.util.Map;/** * @ClassName: BookDB * @Description: 模拟保存所有图书的数据库 * @author: HuangYuhui * @date: Apr 29, 2019 4:56:02 PM * */public class BookDB &#123; private static Map&lt;String, Book&gt; books = new LinkedHashMap&lt;String, Book&gt;(); static &#123; books.put(\"1\", new Book(\"1\", \"《Java web 入门》\")); books.put(\"2\", new Book(\"2\", \"《Java web 进阶》\")); books.put(\"3\", new Book(\"3\", \"《Spring》\")); books.put(\"4\", new Book(\"4\", \"《Spring MVC》\")); books.put(\"5\", new Book(\"5\", \"《MyBatis》\")); &#125; // 获取所有的图书 public static Collection&lt;Book&gt; getall() &#123; return books.values(); &#125; // 根据指定的id获取图书 public static Book getBook(String book_id) &#123; return books.get(book_id); &#125;&#125; ListBookServlet.java : 用于显示所有可购买图书的列表.通过点击”click to buy”链接,便可将指定的图书添加到购物车中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ListBookServlet * @Description: 显示所有可购买图书的列表 * @author: HuangYuhui * @date: Apr 29, 2019 5:05:12 PM * */@WebServlet(\"/ListBookServlet\")public class ListBookServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ListBookServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); Collection&lt;Book&gt; bookInfo = BookDB.getall(); printWriter.println(\"&lt;h3 align='center'&gt;All of book be shown as followed&lt;/h3&gt;&lt;hr/&gt;\"); for (Book book : bookInfo) &#123; String url = \"/Cookie-Session_basic/PurchaseServlet?id=\" + book.getId(); printWriter.println(book.getName() + \"&lt;a href=' \" + url + \" '&gt;click to buy ..&lt;/a&gt;&lt;br&gt;\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; PurchaseServlet.java : 功能一: 将用户购买的图书信息保存到Session对象中. 功能二: 在用户购买图书结束后,将页面重定向到用户已经购买的图书列表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * @ClassName: PurchaseServlet * @Description: 购买图书 * @author: HuangYuhui * @date: May 2, 2019 5:17:54 PM * */@WebServlet(\"/PurchaseServlet\")public class PurchaseServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public PurchaseServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得用户购买的商品 String book_id = request.getParameter(\"id\"); // 如果book_id为空,重定向到ListBookServlet页面 if (book_id == null) &#123; response.sendRedirect(\"/ListBookServlet\"); return; &#125; Book book = BookDB.getBook(book_id); // 创建/获取用户的Session对象 HttpSession session = request.getSession(); // 从Session对象中获得用户的购物车 @SuppressWarnings(\"unchecked\") List&lt;Book&gt; cart = (List&lt;Book&gt;) session.getAttribute(\"cart\"); if (cart == null) &#123; // 首次购买,为用户创建一个购物车( 用List集合模拟购物车 ) cart = new ArrayList&lt;Book&gt;(); // 将购物车存入到Session对象中 session.setAttribute(\"cart\", cart); &#125; // 将商品放入购物车 cart.add(book); // 创建Cookie存放Session的标识号( 体现了Session是借助Cookie技术来传递ID属性的 ) // JSeesionID: Tomcat容器对SessionID的称呼 Cookie cookie = new Cookie(\"JSessionID\", session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(\"/Cookie-Session_basic\"); // 重定向到购物车页面 response.sendRedirect(\"/Cookie-Session_basic/CartServlet\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; CartServlet.java : 展示用户已经购买的图书列表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package pers.huangyuhui.session.example.shoppingtrolley;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * @ClassName: CartServlet * @Description: 展示用户已购买的图书列表 * @author: HuangYuhui * @date: Apr 29, 2019 5:30:42 PM * */@WebServlet(\"/CartServlet\")public class CartServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public CartServlet() &#123; super(); &#125; @SuppressWarnings(\"unchecked\") protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); // 引用用户的购物车 List&lt;Book&gt; cart = null; // 标记用户是否买过商品 boolean purFlag = true; // 获得用户的session HttpSession session = request.getSession(false); if (session == null) &#123; purFlag = false; &#125; else &#123; // 获得用户购物车 cart = (List&lt;Book&gt;) session.getAttribute(\"cart\"); // 如果用户的购物车为空 if (cart == null) &#123; purFlag = false; &#125; &#125; if (!purFlag) &#123; printWriter.println(\"Sorry,you don't buy any books ...\"); response.sendRedirect(\"/ListServlet\"); &#125; else &#123; // 显示用户所购买图书的信息 printWriter.println(\"&lt;h3 align='center'&gt;the book be shown as followed which you had bought&lt;/h3&gt;&lt;hr/&gt;\"); for (Book book : cart) &#123; printWriter.println(book.getName() + \"&lt;br&gt;\"); &#125; &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 实现用户登录案例描述 : 当用户进入网站首页时,如果还未登录,则可以通过单击”登录”按钮进入登录界面.在用户登录时,如果用户名及密码正确则登录成功,否则登录失败.登录成功后还可以单击”退出”按钮,回到首页,显示未登录时的界面.用户登录流程图如下所示 : Login.html : 用户登录页面. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;User login interface&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;Login in&lt;/h3&gt; &lt;hr/&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userpassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; User.java : 封装用户信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.session.example.login;/** * @ClassName: User * @Description: 封装用户的信息 * @author: HuangYuhui * @date: Apr 29, 2019 9:21:28 PM * */public class User &#123; private String username; private String password; public User(String name, String password) &#123; this.username = name; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; IndexServlet.java : 用于显示网站的首界面,如果用户没有登录,那么首界面需要提示用户登录,否则,显示用户已经登录的信息. 12345678910111213141516171819202122232425262728293031323334353637383940@WebServlet(\"/IndexServlet\")public class IndexServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IndexServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 创建/获取保存用户信息的Session对象 HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"user\"); if (user == null) &#123; response.getWriter().println(\"你还没有登录 ! 请&lt;a href='Login.jsp'&gt;登录&lt;/a&gt;\"); &#125; else &#123; response.getWriter().println(\"你已经登录 ! 欢迎你 : \" + user.getUsername() + \" !\"); String url = \"LogoutServlet2\"; response.getWriter().println(\"&lt;a href=' \" + url + \" '&gt;退出&lt;/a&gt;\"); // 创建Cookie用于存放Session标识号 Cookie cookie = new Cookie(\"JSessionID\", session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(\"/Cookie-Session_basic\"); response.addCookie(cookie); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 用于显示用户登录成功后的界面. 12345678910111213141516171819202122232425262728293031323334@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); String username = request.getParameter(\"username\"); String password = request.getParameter(\"userpassword\"); if (\"YUbuntu0109\".equals(username) &amp;&amp; \"demo\".equals(password)) &#123; // 传递用户登录信息 User user = new User(username, password); request.getSession().setAttribute(\"user\", user); response.sendRedirect(\"/Cookie-Session_basic/IndexServlet\"); &#125; else &#123; printWriter.println(\"登录失败 ! 用户名或密码错误 ! &lt;a href='Login.html'&gt;重新登录&lt;/a&gt;\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LogoutServlet.java : 用于完成用户注销功能. 12345678910111213141516171819202122232425@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 将Session对象中的User对象移除 request.getSession().removeAttribute(\"user\"); response.getWriter().println(\"你的账户已成功注销 ! &lt;a href='Login.html'&gt;返回登录页面&lt;/a&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 利用Session实现一次性验证码案例描述 : 在实际开发中,为了保证用户信息的安全,都会在网站登录的界面中添加一次性验证码,从而限制不法分子使用软件暴力猜测密码.一次性验证码的功能同样可以使用Session来实现.该案例代码基于上个案例(实现用户登录)进行改写. Login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;User login interface&lt;/h3&gt; &lt;hr/&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet2\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;verification code&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"verificationCode\"/&gt; &lt;img src=\"CheckServlet\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CheckServlet.java : 用于生成验证码图片. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package pers.huangyuhui.session.example.verifcode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet(\"/CheckServlet\")public class CheckServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static int WIDTH = 100; private static int HEIGHT = 30; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // set specifying the MIME type of the content response.setContentType(\"image/jpeg\"); // 设置浏览器勿缓冲此图片 response.setHeader(\"Pragma\", \"No-cache\"); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setDateHeader(\"Expiress\", 0); // 获取/创建Session对象 HttpSession session = request.getSession(); // 创建内存图像并获得其图像上下文 BufferedImage bufferedImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_BGR); // 绘制图像 Graphics graphics = bufferedImage.getGraphics(); // 产生随机的认证码 char[] rands = generateCheckCode(); // 产生图像 drawBackground(graphics); drawRands(graphics, rands); // 结束图形的绘制过程 graphics.dispose(); // 将图像输出到客户端 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // writes an image using an arbitrary ImageWriterthat supports the given format // to an OutputStream. ImageIO.write(bufferedImage, \"JPEG\", byteArrayOutputStream); // Sets the length of the content body in the response In HTTP servlets, // this method sets the HTTP Content-Length header. byte[] buff = byteArrayOutputStream.toByteArray(); response.setContentLength(buff.length); // 将图片写入到Servlet输出流 ServletOutputStream servletOutputStream = response.getOutputStream(); byteArrayOutputStream.writeTo(servletOutputStream); byteArrayOutputStream.close(); servletOutputStream.close(); // 将当前验证码存放到Session中 session.setAttribute(\"check_code\", new String(rands)); // 直接使用下述代码将有问题! 因为Session对象必须在提交响应前获得 // request.getSession().setAttribute(\"check_code\", new String(rands)); &#125; // 生成验证码 private char[] generateCheckCode() &#123; String chars = \"0123456789abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char[] rands = new char[4]; for (int i = 0; i &lt; 4; i++) &#123; int rand = (int) (Math.random() * (10 + 26 * 2)); rands[i] = chars.charAt(rand); &#125; return rands; &#125; // 绘制验证码 private void drawRands(Graphics g, char[] rands) &#123; g.setColor(Color.RED); g.setFont(new Font(\"Console\", Font.BOLD, 25)); // 在不同的坐标上输出每个字符 g.drawString(\"\" + rands[0], 10, 22); g.drawString(\"\" + rands[1], 30, 22); g.drawString(\"\" + rands[2], 50, 22); g.drawString(\"\" + rands[3], 70, 22); &#125; // 绘制图片背景 private void drawBackground(Graphics g) &#123; // 画背景 g.setColor(Color.LIGHT_GRAY); g.fillRect(0, 0, WIDTH, HEIGHT); // 随机产生200个干扰点 for (int i = 0; i &lt; 200; i++) &#123; int x = (int) (Math.random() * WIDTH); int y = (int) (Math.random() * HEIGHT); int red = (int) (Math.random() * 255); int green = (int) (Math.random() * 255); int blue = (int) (Math.random() * 255); g.setColor(new Color(red, green, blue)); g.drawOval(x, y, 2, 2);// draws the outline of an oval &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 对LoginServlet进行修改,增加对验证码的判断. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.session.example.verifcode;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/LoginServlet\")public class LoginServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet2() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String checkCode = request.getParameter(\"verificationCode\"); /* * 获取Session中的验证码信息 */ String saveCheckCode = (String) request.getSession().getAttribute(\"check_code\"); if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password) &amp;&amp; checkCode.equals(saveCheckCode)) &#123; User user = new User(name, password); request.getSession().setAttribute(\"user\", user); response.sendRedirect(\"/Cookie-Session_basic/IndexServlet\"); &#125; else if (checkCode.equals(saveCheckCode)) &#123; printWriter.println(\"登录失败! 用户名或密码 !\"); &#125; else &#123; printWriter.println(\"验证码错误 !\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 用户登录页面.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:Servlet listener","slug":"Java-web-Servlet-listener","date":"2019-05-02T01:31:43.000Z","updated":"2019-05-04T14:31:27.464Z","comments":true,"path":"2019/05/02/Java-web-Servlet-listener/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Servlet-listener/","excerpt":"","text":"学习笔记 : Java web之Servlet事件监听器概述Servlet事件监听器可以监听ServletContext,HttpSession,ServletRequest等域对象的创建和销毁过程,监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态.根据监听事件的不同可以将其分为三类,具体如下 : 用于监听域对象创建和销毁的事件监听器 : ServletContextListener,HttpSessionListener,ServletRequestListener interface 用于监听域对象属性增加和删除的事件监听器 : ServletContextAttributeListener,HttpSessionAttributeListener,ServletRequestAttributeListener interface 用于监听绑定到HttpSession域中某个对象状态的事件监听器 : HttpSessionBindingListener,HttpSessionActivationListener interface 监听域对象的生命周期简介 : 在Web应用程序的运行期间,Web容器会创建和销毁三个比较的重要的对象: ServletContext,HttpSession,ServletRequest,这些对象被称为域对象,为了监听这些域对象的生命周期,Servlet API中提供了三个对应的接口: ServletContextListener,HttpSessionListener,ServletRequestListener. 案例-监听域对象的生命周期示例代码如下所示1234567891011121314151617181920212223242526272829303132333435363738394041/** * @ClassName: MyServletListener * @Description: 监听域对象的生命周期 * @author: HuangYuhui * @date: May 3, 2019 3:17:56 PM * */@WebListener(value=\"/MyServletListener\")//Servlet 3.0public class MyServletListener implements ServletContextListener, ServletRequestListener, HttpSessionListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"ServletContext object be initialized !\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"ServletContext object be destroyed !\"); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(\"ServletRequest object be initialized !\"); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(\"ServletRequest object be destroyed !\"); &#125; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(\"HttpSession object be initialized !\"); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(\"HttpSession object be destroyed !\"); &#125;&#125; 为了查看HttpSessionListener和ServletRequestListener监听器的运行效果,可以新建一个index.jsp页面,当运行Tomcat服务器第一次访问index.jsp时,Web容器除了为这次请求创建了ServletRequest对象外,还创建了与这个浏览器对应的HttpSession对象,当这两个对象在被创建时,Web容器会调用监听器MyServeltListener中相应的方法,当Web服务器完成这次请求后,ServletRequest对象会随之销毁.需要注意的是: 如果刷新index.jsp页面,会再次触发ServletRequestListener监听器接口中的方法,继而创建新的ServletRequest对象,但不会创建新的HttpSession对象,这是因为Web容器会为每次访问请求创建一个新的ServletRequest对象,而对于同一个浏览器在会话期间的后续访问是不会再创建新的HttpSession对象的. 案例-统计当前在线人数案例描述 : 通常情况下,当一个用户在进入某个网站时服务器就会为其创建一个HttpSessionListener对象,当用户离开网站时HttpSessionListener对象就会别销毁.因此,可以使用实现了HttpSessionListener接口的监听器来统计网站的在线人数. login.jsp : 用于显示当前在线人数. 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HttpSessionListener案例: 统计当前在线人数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;当前在线人数为: &lt;%=application.getAttribute(\"count\")%&gt;&lt;/h3&gt; &lt;a href=\"&lt;%=response.encodeURL(\"logout.jsp\")%&gt;\"&gt;退出登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; CountListener.java : 用于统计当前在线人数. 1234567891011121314151617181920212223242526272829/** * @ClassName: CountListener * @Description: 统计在线人数 * @author: HuangYuhui * @date: May 3, 2019 3:40:59 PM * */@WebListener(value = \"/CountListener\")public class CountListener implements HttpSessionListener &#123; private int count = 0;// 在线人数 @Override // Session对象创建时count++ public void sessionCreated(HttpSessionEvent se) &#123; count++; ServletContext servletContext = se.getSession().getServletContext(); servletContext.setAttribute(\"count\", Integer.valueOf(count)); &#125; @Override // Session对象销毁时count-- public void sessionDestroyed(HttpSessionEvent se) &#123; count--; ServletContext servletContext = se.getSession().getServletContext(); servletContext.setAttribute(\"count\", Integer.valueOf(count)); &#125;&#125; logout.jsp : 用于注销用户登录. 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HttpSessionListener案例: 统计当前在线人数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% session.invalidate();// 使当前的Session失效 %&gt; &lt;h3 align=\"center\"&gt;你已退出本系统&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 监听域对象中的属性变更简介 : Servlet API 中提供了三个用于监听某个域对象属性变更的接口: ServletContextAttributelistener,HttpSessionAttributerListener和ServletRequestAttributeListener.这三个接口都定义了相同名称的方法,分别用于处理被监听对象属性的增加,删除和替换. 案例-监听域对象的属性变更 attribute.jsp : 设置各个域对象的属性.12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;案例:监听域对象的属性变更&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;测试域对象属性信息监听器的页面&lt;/h3&gt; &lt;% getServletContext().setAttribute(\"name\", \"YUbuntu0109\"); getServletContext().setAttribute(\"name\", \"https://YUbuntu0109.github.io\"); getServletContext().removeAttribute(\"name\"); session.setAttribute(\"name\", \"YUbuntu0109\"); session.setAttribute(\"name\",\"https://YUbuntu0109.github.io\"); session.removeAttribute(\"name\"); request.setAttribute(\"name\", \"YUbuntu0109\"); request.setAttribute(\"name\", \"https://YUbuntu0109.github.io\"); request.removeAttribute(\"name\"); %&gt; &lt;/body&gt;&lt;/html&gt; MyAttributeListener.java : 用于监听各个域对象属性的变更. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @ClassName: MyAttributeListener * @Description: 监听域对象的属性变更 * @author: HuangYuhui * @date: May 3, 2019 4:18:40 PM * */@WebListener(\"/MyAttributeListener\")public class MyAttributeListener implements ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener &#123; @Override public void attributeAdded(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 添加属性: name=\" + event.getServletContext().getAttribute(event.getName())); &#125; @Override public void attributeReplaced(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 替换属性: name=\" + event.getServletContext().getAttribute(event.getName())); &#125; @Override public void attributeRemoved(ServletContextAttributeEvent event) &#123; System.out.println(\"ServletContext 移除属性: \" + event.getName()); &#125; @Override public void attributeAdded(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 添加属性: name=\" + srae.getServletRequest().getAttribute(srae.getName())); &#125; @Override public void attributeReplaced(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 替换属性: name=\" + srae.getServletRequest().getAttribute(srae.getName())); &#125; @Override public void attributeRemoved(ServletRequestAttributeEvent srae) &#123; System.out.println(\"HttpRequest 移除属性: \" + srae.getName()); &#125; @Override public void attributeAdded(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 添加属性: name=\" + event.getSession().getAttribute(event.getName())); &#125; @Override public void attributeReplaced(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 替换属性: name=\" + event.getSession().getAttribute(event.getName())); &#125; @Override public void attributeRemoved(HttpSessionBindingEvent event) &#123; System.out.println(\"HttpSession 移除属性: \" + event.getName()); &#125;&#125; 程序运行结果如下所示. 123456789ServletContext 添加属性: name=YUbuntu0109ServletContext 替换属性: name=https://YUbuntu0109.github.ioServletContext 移除属性: nameHttpSession 添加属性: name=YUbuntu0109HttpSession 替换属性: name=https://YUbuntu0109.github.ioHttpSession 移除属性: nameHttpRequest 添加属性: name=YUbuntu0109HttpRequest 替换属性: name=https://YUbuntu0109.github.ioHttpRequest 移除属性: name 案例-统计当前在线人数名单案例描述 : 在上述统计当前在线人数的案例中,实际上统计的是Web应用当前的所有会话的数目.它无法统计所有所有在线用户的具体名单! 下面我们通过使用HttpSessionBindingListener接口不仅可以统计在线用户的数量,还可以统计在线用户的名单. login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;案例:统计登录用户的在线名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户登录页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table width=\"280px\" cellpadding=\"0\" align=\"center\"&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"50\" colspan=\"2\" align=\"center\"&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;span style=\"font-size:13px;color:red\"&gt;$&#123;errorMsg &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; User.java : 封装用户信息. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package pers.huangyuhui.servletlistener.example.onlinenumber2;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;/** * @ClassName: User * @Description: 封装用户信息 * @author: HuangYuhui * @date: May 4, 2019 9:10:47 AM * */public class User implements HttpSessionBindingListener &#123; private String id; private String username; private String password; public User(String id, String name, String password) &#123; this.id = id; this.username = name; this.password = password; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public void valueBound(HttpSessionBindingEvent event) &#123; // System.out.println(\"将新用户添加到在线名单 : \" + event.getName() + \"=\" + event.getValue()); OnlineUser.getInstance().addUser(this); &#125; @Override public void valueUnbound(HttpSessionBindingEvent event) &#123; // System.out.println(\"从在线名单中移除该用户 : \" + event.getName() + \"=\" + event.getValue()); OnlineUser.getInstance().removeUser(this); &#125;&#125; OnlineUser.java : 用于存储和获取在线用户列表. 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.util.HashMap;import java.util.Map;/** * @ClassName: OnlineUser * @Description: 存储及获取在线用户列表 * @author: HuangYuhui * @date: May 4, 2019 9:14:09 AM * */public class OnlineUser &#123; private OnlineUser() &#123; &#125; private static OnlineUser instance = new OnlineUser(); public static OnlineUser getInstance() &#123; return instance; &#125; private Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;(); // 将用户添加至在线列表 public void addUser(User user) &#123; userMap.put(user.getId(), user.getUsername()); &#125; // 将用户从在线列表中移除 public void removeUser(User user) &#123; userMap.remove(user.getId()); &#125; // 返回在线的用户列表 public Map&lt;String, String&gt; getOnlineUsers() &#123; return userMap; &#125;&#125; LoginServlet.java : 处理用户登录请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.io.IOException;import java.util.Map;import java.util.UUID;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LoginServlet * @Description: 处理用户登录请求 * @author: HuangYuhui * @date: May 4, 2019 9:30:23 AM * */@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); String username = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); if (username != null &amp;&amp; !username.trim().equals(\"\")) &#123; User user = new User(UUID.randomUUID().toString(), username, password); request.getSession().setAttribute(\"user\", user); Map&lt;String, String&gt; onlineUsers = OnlineUser.getInstance().getOnlineUsers(); request.setAttribute(\"onlineUsers\", onlineUsers); request.getRequestDispatcher(\"/showOnlineUsers.jsp\").forward(request, response); &#125; else &#123; request.setAttribute(\"errorMsg\", \"用户名不能为空 !\"); request.getRequestDispatcher(\"/login.jsp\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LogoutServlet.java : 注销用户登录信息. 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.servletlistener.example.onlinenumber2;import java.io.IOException;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LogoutServlet * @Description: 注销用户登录信息 * @author: HuangYuhui * @date: May 4, 2019 9:54:27 AM * */@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getSession().removeAttribute(\"user\"); Map&lt;String, String&gt; onlineUsers = OnlineUser.getInstance().getOnlineUsers(); request.setAttribute(\"onlineUsers\", onlineUsers); request.getRequestDispatcher(\"/showOnlineUsers.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; showOnlineUsers.jsp : 显示所有用户的登录信息以及当前登录的用户. 1234567891011121314151617181920212223242526&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;应用案例:统计登录用户的在线名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户在线名单如下所示&lt;/h3&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;sessionScope.user == null &#125;\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/login.jsp\"&gt;登录&lt;/a&gt;&lt;br&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 你已成功登录! 欢迎你: $&#123;sessionScope.user.username &#125; &lt;a href=\"$&#123;pageContext.request.contextPath &#125;/LogoutServlet\"&gt;退出&lt;/a&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;hr/&gt; &lt;c:forEach var=\"user\" items=\"$&#123;requestScope.onlineUsers &#125;\"&gt; &lt;p align='center'&gt;用户名: $&#123;user.value&#125;&lt;/p&gt; &lt;/c:forEach&gt; &lt;/body&gt;&lt;/html&gt; 程序运行效果示例图. 感知被HttpSession绑定的事件监听器暂略写 ..","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:Filter","slug":"Java-web-Filter","date":"2019-05-02T01:29:12.000Z","updated":"2019-05-03T04:08:39.473Z","comments":true,"path":"2019/05/02/Java-web-Filter/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-Filter/","excerpt":"","text":"学习笔记 : Java web之过滤器简介Filter被称作过滤器或者拦截器,作为Servlet 2.3中新增的技术,可以实现用户在访问某个目标资源之前,对访问的请求和响应进行相应处理.其基本功能就是对Servlet容器调用Servlet的过程进行拦截,从而在Servlet响应处理前后实现一些特殊功能. Filter过滤器实现了javax.servlet.Filter接口.在Filter接口中定义了三个方法,其代表Filter的生命周期,如下所示 :123456// 用于初始化过滤器init(FilterConfig filterConfig);// 客户端请求时被调用(Filter所有的工作都集中在此方法中)doFilter(ServletRequest request,ServletResponse response,FilterChain chain);// 在Web应用程序卸载时被调用destory(); Filter annotation简介 : Servlet3.0提供@WebFilter注解将一个实现了javax.servlet.Filter接口的类定义为过滤器,继而当我们在Web应用中使用过滤器时无需在web.xml文件中配置Filter映射 ! 注解示例-拦截用户的所有请求1234@WebFilter(filterName=\"/MyFilter\" , urlPatterns= \"/*\")public class MyFilter implements Filter &#123; ···&#125; 注解示例-拦截不同方式的访问请求描述 : 根据被Servlet容器调用的方式来拦截指定的资源.其调用方式如下所示 :1234567891011121314package javax.servlet;/** * Enumeration of filter dispatcher types. * * @since Servlet 3.0 */public enum DispatcherType &#123; FORWARD, INCLUDE, REQUEST, ASYNC, ERROR&#125; 下面以FORWARD(如果目标资源是通过RequestDispatcher的forward()方法访问时,该过滤器将会被调用)为例,演示Filter对转发请求的过滤效果. ServletTest : 将请求转发给index.jsp页面. 1234567891011121314151617181920@WebServlet(\"/ServletTest\")public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletTest() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(\"/index.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; FilterTest.java : 拦截index.jsp页面. 1234567891011121314151617181920// Servlet 3.0@WebFilter(filterName = \"/FilterTest\", urlPatterns = \"/index.jsp\", dispatcherTypes = &#123; DispatcherType.FORWARD &#125;) public class FilterTest implements Filter &#123; public FilterTest() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.getWriter().println(\"This is Filter !\"); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; FilterConfig interface简介 : 为了获取Filter程序在web.xml中的配置信息,Servlet API提供了一个FilterConfig接口,该接口封装了Filter程序在web.xml中的所有注册信息.并提供了一系列获取这些配置信息的方法.(同时适用于注解的哟 ~) getInitParameter(String name)描述 : 下面以接口FilterConfig接口中的getInitParameter(String name)方法为例,演示FilterConfig接口的作用. FilterConfigTest.java : 获取注解中指定名称的初始化参数值. 12345678910111213141516171819202122232425262728// 使用注解为该Filter设置初始化参数: initParams= &#123;@WebInitParam(name=\"encoding\",value=\"utf-8\")&#125;@WebFilter(filterName = \"/FilterConfigTest\", urlPatterns = \"/MyServlet\", initParams = &#123; @WebInitParam(name = \"encoding\", value = \"utf-8\") &#125;)public class FilterConfigTest implements Filter &#123; FilterConfig filterConfig; String characterEncoding = null; public FilterConfigTest() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.setContentType(\"text/html;charset=utf-8\"); characterEncoding = filterConfig.getInitParameter(\"encoding\"); response.getWriter().println(\"encoding的初始化参数的值为: \" + characterEncoding); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; this.filterConfig = fConfig; &#125;&#125; FilterConfigTest.java : 获取web.xml中指定名称的初始化参数值(代码同FilterConfigTest.java),web.xml中的配置信息如下 : 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Filter_basic&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;FilterConfigTest&lt;/filter-name&gt; &lt;filter-class&gt;pers.huangyuhui.filter.filterconfig.FilterConfigTest&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;gbk2312&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterConfigTest&lt;/filter-name&gt; &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Filter applicationFilter 实现用户自动登录案例描述 : 使用Cookie实现用户自动登录后,当客户端访问服务器的Servlet时,所有的Servelt都需要对用户的Cookie信息进行校验,这样势必会导致在Servlet程序中书写大量重复的代码.为了解决这个问题,可以在Filter程序中实现Cookie的校验.由于Filter可以对服务器的所有请求进行拦截,因此,一旦请求通过Filter程序,就相当于用户信息校验通过,然后Servelt程序就可以根据获取到的用户信息实现自动登录功能了. User.java : 封装用户的信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.filter.example.autologin;/** * @ClassName: User * @Description: 封装用户的信息 * @author: HuangYuhui * @date: May 1, 2019 7:24:26 PM * */public class User &#123; private String username; private String password; public User(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; login.jsp : 用户登录页面. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;应用案例 : Filter实现用户自动登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;用户登录页面&lt;/h3&gt; &lt;hr/&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table width=\"380px\" cellpadding=\"0\" align=\"center\"&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"userName\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"30\" align=\"center\"&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userPassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"40\" align=\"center\"&gt;自动登录时间&lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60 &#125;\"/&gt;一小时 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24 &#125;\"/&gt;一天 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24*7 &#125;\"/&gt;一周 &lt;input type=\"radio\" name=\"autologin\" value=\"$&#123;60*60*24*31 &#125;\"/&gt;一个月 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"50\" colspan=\"2\" align=\"center\"&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;span style=\"font-size:13px;color:red\"&gt;$&#123;errorMsg &#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; LoginServlet.java : 处理用户的登录请求. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LoginServlet * @Description: 处理用户的登录请求 * @author: HuangYuhui * @date: May 1, 2019 9:38:38 PM * */@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); String autoLogin = request.getParameter(\"autologin\"); // 检查用户登录信息 if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; // 将用户对象存入session域 User user = new User(name, password); request.getSession().setAttribute(\"user\", user); if (autoLogin != null) &#123; Cookie cookie = new Cookie(\"autologin\", name + \"-\" + password);// 加密 cookie.setMaxAge(Integer.parseInt(autoLogin)); cookie.setPath(request.getContextPath()); response.addCookie(cookie);// 发送自动登录的cookie &#125; response.sendRedirect(\"index.jsp\"); // 跳转到首页 &#125; else &#123; request.setAttribute(\"errorMsg\", \"提示: 用户名或密码错误 !\"); request.getRequestDispatcher(\"/login.jsp\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; LoginServlet.java : 注销用户的登录信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: LogoutServlet * @Description: 注销用户登录的信息 * @author: HuangYuhui * @date: May 1, 2019 9:47:49 PM * */@WebServlet(\"/LogoutServlet\")public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 将Session会话中保存的User对象删除 request.getSession().removeAttribute(\"user\"); // 将自动登录的Cookie删除 Cookie cookie = new Cookie(\"autologin\", \"msg\"); cookie.setPath(request.getContextPath()); cookie.setMaxAge(0); response.addCookie(cookie); response.sendRedirect(request.getContextPath() + \"/index.jsp\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; AutoLoginFilter.java : 拦截用户登录的访问请求. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.filter.example.autologin;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;/** * @ClassName: AutoLoginFilter * @Description: 拦截用户登录的访问请求 * @author: HuangYuhui * @date: May 1, 2019 9:51:23 PM * */@WebFilter(filterName = \"/AutoLoginFilter\", urlPatterns = \"/*\")public class AutoLoginFilter implements Filter &#123; public AutoLoginFilter() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request2 = (HttpServletRequest) request; Cookie[] cookies = request2.getCookies(); // 获取一个名为`autologin`的cookie String autoLogin = null; for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (\"autologin\".equals(cookies[i].getName())) &#123; autoLogin = cookies[i].getValue(); break; &#125; &#125; // 验证用户登录信息 if (autoLogin != null) &#123; String[] parts = autoLogin.split(\"-\"); String name = parts[0]; String password = parts[1]; if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; // 将用户的登录信息封装到User对象并存入Sesssion域中,既而完成自动登录 User user = new User(name, password); request2.getSession().setAttribute(\"user\", user); &#125; &#125; chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125;","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"Java web:请求与响应","slug":"Java-web-请求与响应","date":"2019-05-02T01:28:42.000Z","updated":"2019-05-02T04:35:14.130Z","comments":true,"path":"2019/05/02/Java-web-请求与响应/","link":"","permalink":"http://yoursite.com/2019/05/02/Java-web-请求与响应/","excerpt":"","text":"学习笔记 : Java web之请求与响应简介Servlet最主要的作用就是处理客户端请求,并向客户端做出响应.为此,针对Servlet的每次请求,Web服务器在调用service()之前,都会创建两个对象,分别是: HttpServletRequest和HttpServletResponse.其中HttpServletRequest用于封装HTTP请求消息,简称request对象.HttpServletResponse用于封装HTTP响应消息,简称response对象.下面通过示例图来展示浏览器访问Servlet的交互过程. HttpServletResponseHttpServletResponse接口继承自ServletResponse,用于封装HTTP响应消息.由于HTTP响应消息分为 : 状态行,响应消息头,消息体三部分,因此,在HttpServletResponse接口中定义了向客户端发送响应状态码,响应消息头,响应消息体的方法. HttpServletResponse application中文输出乱码问题由于计算机中的数据都是以二进制形式存储的,因此,当传输文本时,就会发生字符和字节之间的转换.字符与字节之间是通过查码表完成的,将字符转换为字节的过程称为编码,相反称为解码.如果两者使用的码表不一致就会导致乱码问题.可通过以下示例程序中的方法解决此问题.12345678910111213141516171819202122232425262728@WebServlet(\"/SetCharsetServlet\")public class SetCharsetServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SetCharsetServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 第一种解决乱码的方式 // response.setCharacterEncoding(\"utf-8\"); // response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\"); // 第二种解决乱码的方式 response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); printWriter.write(\"中文\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 网页定时刷新并跳转在HTTP中定义了一个Refresh头字段,他可以通知浏览器在指定的时间自动刷新并跳转到其它页面.示例程序如下.12345678910111213141516171819202122@WebServlet(\"/SetHeaderServlet\")public class SetHeaderServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SetHeaderServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 实现网页的定时刷新并跳转 response.setHeader(\"Refresh\",\"5;URL=https://yubuntu0109.github.io\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 请求重定向在某些情况下,针对客户端的请求,一个Servlet类可能无法完成全部工作.这时,可以使用请求重定向来完成.所谓的请求重定向,指的是Web服务器接受到客户端的请求后,可能由于某些条件限制,不能访问当前请求URL所指的Web资源,而是指定了一个新的资源路径,让客端户重新发送请求. 用户登录界面 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;User login interface&lt;/h3&gt; &lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"SendRedirectTest\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;User name&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Password&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"userpassword\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" name=\"login in\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 登录成功页面 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;success&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\" &gt;weclome&lt;/h3&gt; &lt;hr&gt; &lt;p align=\"center\"&gt;success to login in !&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 编写处理用户登录请求的Servlet程序 12345678910111213141516171819202122232425262728293031@WebServlet(\"/SendRedirectServlet\")public class SendRedirectServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SendRedirectServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码 response.setContentType(\"text/html;charset=utf-8\"); // 使用HttpServletRequest对象的getParameter()方法获取用户名及密码 String name = request.getParameter(\"username\"); String password = request.getParameter(\"userpassword\"); if (\"YUbuntu0109\".equals(name) &amp;&amp; \"demo\".equals(password)) &#123; response.sendRedirect(\"Redirection/welcome.jsp\"); &#125; else &#123; response.sendRedirect(\"login.jsp\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; HttpServletRequestHttpServletRequest接口继承自ServletRequest,用于封装HTTP请求消息.由于HTTP请求消息分为 : 请求行,请求消息头,请求消息体三部分,因此,在HttpServletRequest接口中定义了获取请求行,请求头,请求消息体的相关方法. HttpServletRequest application利用Referer请求头防止盗链编写一个Servlet类,其负责提供下载内容,但它要求下载请求的链接必须是通过本网站进入的,否则,会将请求转发给下载说明的HTML页面.123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @ClassName: DownManagerServlet * @Description: 利用`Referer`请求头防止盗链 * @author: HuangYuhui * @date: Apr 29, 2019 9:41:11 AM * */@WebServlet(\"/DownManagerServlet\")public class DownManagerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public DownManagerServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); // 获取referer头的值: http://localhost:8080/Request-Response_basic/DownManagerServlet String referer = request.getHeader(\"referer\"); // 获取访问地址 // 由于第一次请求DownManagerServlet时,请求消息中并不包含referer请求头, // 所以DownManagerServlet会将下载请求转发给了downlaod.html页面 String sitePart = \"http://\" + request.getServerName(); if (referer != null &amp;&amp; referer.startsWith(sitePart)) &#123; printWriter.println(\"dealing download ...\"); &#125; else &#123; // 非法下载请求将跳转到download.html页面 request.getRequestDispatcher(\"HttpServletRequest/download.html\").forward(request, response); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 请求参数的中文乱码问题HttpServletRequest接口中,提供了一个setCharacterEncoding()方法,该方法用于设置request对象的解码方式.但该方法只对POST提交方式有效(错误结论),为了解决GET方式提交表单的中文乱码问题,可以首先使用ISO 8859-1将用户名重新编码,然后使用码表GBK进行解码.示例程序略.. RequestDispatcher当一个Web资源收到客户端的请求后,如果希望服务器通知另外一个资源去处理请求,这时,除了使用sendRedirect()方法实现请求重定向外,还可以通过RequestDispatcher接口的实例对象来实现.在ServletRequest接口中定义了一个获取RequestDispatcher对象的方法. 获取RequestDispatcher对象的方法 123// 返回封装了某个路径所指资源的RequestDispather对象.其中,参数path必须// 以'/'开头,用于表示当前Web应用的根目录getRequestDispatcher(String path); 获取RequestDispatcher对象后,最重要的工作是通知其他Web资源处理当前的Servlet请求,为此,在RequestDispather接口中,定义了两个相关的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 该方法用于将请求从一个Servlet传递给另外的一个Web资源(请求转发)// 注意: 该方法必须在响应提交给客户端之前被调用,否则抛出IllegalStateExceptionforward(ServletRequests request,ServletResponse response);// 该方法用于将其他的资源作为当前响应内容包含进来include(ServletRequest request,ServletResponse response);``` ### RequestDispatcher applicatoin#### forward()实现请求转发*通过使用`forward()`方法,将当前RequestForwardServlet的请求转发到ResultServlet页面*1. *RequestForwardServlet示例程序*```java/** * @ClassName: RequestForwardServlet * @Description: 请求转发:forword() * @author: HuangYuhui * @date: Apr 29, 2019 11:07:03 AM * */@WebServlet(\"/RequestForwardServlet\")public class RequestForwardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public RequestForwardServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); request.setAttribute(\"websiteURL\", \"https://yubuntu0109.github.io\"); // request.getRequestDispatcher(\"/ResultServlet\").forward(request, response); RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/ResultServlet\"); requestDispatcher.forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; ResultServlet示例程序 1234567891011121314151617181920212223242526272829/** * @ClassName: ResultServlet * @Description: 请求转发:forword() * @author: HuangYuhui * @date: Apr 29, 2019 11:12:47 AM * */@WebServlet(\"/ResultServlet\")public class ResultServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ResultServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().println(\"&lt;p align='center'&gt;\" + \"my personal blog website address : \" + request.getAttribute(\"websiteURL\") + \"&lt;/p&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 页面显示结果 1my personal blog website address : https://yubuntu0109.github.io 由结果可知,forward()方法不仅可以实现请求转发,还可以使转发页面和转发到的页面共享数据.需要注意的是: 存储在request对象中的数据只对当前请求有效,而对其他请求无效. include()实现请求包含请求包含指的是使用include方法将Servlet请求转发给其他Web资源进行处理,与请求转发不同的是,在请求包含返回的响应消息中,既包含当前Servlet的响应消息也包含其他Web资源所做出的响应消息. 编写IncludingServlet程序,其中调用include()方法请求包含IncludedServlet程序. 123456789101112131415161718192021222324252627282930313233/** * @ClassName: IncludingServlet * @Description: 请求包含:include() * @author: HuangYuhui * @date: Apr 29, 2019 11:28:25 AM * */@WebServlet(\"/IncludingServlet\")public class IncludingServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IncludingServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 因为请求IncludingServelt时,用于封装响应消息的HttpServletResponse对象已经创建,该对象在编码时采用的是默认的: ISO 8859-1 // 所以当客户端对接收到的数据进行解码时,Web服务器会继续保持调用HttpServeltResponse对象中的信息,从而使IncludedServlet中 // 的输出内容发生乱码.为解决此问题需在IncludingServlet中提前设置如下编码方式 . response.setContentType(\"text/html;charset=utf-8\"); RequestDispatcher resDispatcher = request.getRequestDispatcher(\"/IncludedServelt?name=YUbuntu0109\"); resDispatcher.include(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; IncludedServlet程序 123456789101112131415161718192021222324252627282930/** * @ClassName: IncludedServlet * @Description: 请求包含:include() * @author: HuangYuhui * @date: Apr 29, 2019 11:33:42 AM * */@WebServlet(\"/IncludedServelt\")public class IncludedServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public IncludedServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = response.getWriter(); printWriter.println(\"中文&lt;br&gt;\"); printWriter.println(\"user name : \" + request.getParameter(\"name\") + \"&lt;br&gt;\"); printWriter.println(\"request.getRequestURI() : \" + request.getRequestURI()); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 页面显示结果 123中文user name : YUbuntu0109request.getRequestURI() : /Request-Response_basic/IncludingServlet 注意: 使用forward()实现请求转发或使用include()方法实现请求包含后,浏览器显示的URL地址是不会变化的 !","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Americans`Favorite Thing To Do","slug":"VOA-Americans-Favorite-Ting-To-Do","date":"2019-04-28T07:49:03.000Z","updated":"2019-04-28T13:59:11.331Z","comments":true,"path":"2019/04/28/VOA-Americans-Favorite-Ting-To-Do/","link":"","permalink":"http://yoursite.com/2019/04/28/VOA-Americans-Favorite-Ting-To-Do/","excerpt":"","text":"Americans’Favorite Thing To DoAmericans’s favorite activity has long been said to be baseball. But a new study by the U.S. government suggests that is not true. The Bureau of Labor Statistics says Americans seem to enjoy watching television more than anything else. 美国人最喜欢的运行据说是棒球,但美国政府的一项新研究表明,事实并非如此.美国劳工统计局说,美国人似乎最喜欢看电视. Researchers examined how Americans age 15 and older spent their free time during the years 2013 to 2017. They learned that Americans spend almost three hours every day watching TV. 研究人员调查了15岁及以上的美国人在2013年至2017年期间是如何度过空闲时间的.他们了解到美国人每天几乎花三个小时看电视. The activity includes watching movies,recorded program.and live broadcasts. 观看的电视内容包括电影,录制节目和现场直播. So who watches television the most? People over the age of 65,researchers found.Older people clock in at more than four and a half hours of television every day. 那么哪个群体看电视最多呢? 研究人员发现,是年龄超过65岁的老人,老年人每天去看电视的时间超过四个半小时. Parents with small children spent the least amount of time in front of the tube,as TV is sometimes called. 有小孩的父母花在电视机前的时间最少(电视有时也被称为”TV”) Researchers discovered something else,too : Men watch about 30 minutes more television than women each day. 研究人员还发现另一件事: 男性平均每天看电视的时间比女性多30分钟. I’m Kelly Jean Kelly. 重点词汇 bureau (n) 局,处. labor (n) 劳动,工作. statistics (n) 统计,统计学. examine (v) 检查,调查.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:A Lifetime of Exercise Slows Aging Process","slug":"VOA-A-Lifetime-of-Exercise-Slows-Aging-Process","date":"2019-04-27T08:20:30.000Z","updated":"2019-04-28T01:49:49.101Z","comments":true,"path":"2019/04/27/VOA-A-Lifetime-of-Exercise-Slows-Aging-Process/","link":"","permalink":"http://yoursite.com/2019/04/27/VOA-A-Lifetime-of-Exercise-Slows-Aging-Process/","excerpt":"","text":"A Lifetime of Exercise Slows Aging ProcessFrom VOA learning English,this is the Health&amp;Lifestyle report. 这里是美国之音——健康&amp;生活方式节目. If you have been meaning to add more exercise to your daily routine,you may want to start sooner rather than later. 如果你已经打算每天增加点锻炼,或许你应该尽早开始. A 2018 study has found a lifetime of regular exercise and activity can slow down the aging process. 2018年的一项研究发现,在人的一生中,定期锻炼和参加活动可以减缓衰老过程. Researchers at Britain’s University of Birmingham and King’s Collage London say that getting older should not necessarily mean becoming more weak or sick. Their research shows that a commitment to a life of movement and exercise my help us live ont only longer,but also healthier. 英国伯明翰大学和伦敦国王学院的研究人员说,年龄的增长不一定意味着变得更加虚弱.他们的研究表明,坚持运动和锻炼可以使我们的寿命加长,而且身体会更健康. For their study,the researchers looked at two groups. 关于他们的研究,研究人员观察了两个小组. The first group was made up of 125 non-professional cyclists between the ages of 55 to 79. This group included 84 healthy men and 41 healthy women. We will call this group the “cyclists”. 第一组由125名年龄在55至79岁之间的非职业自行车手组成.该组包括84名健康男性和41名女性.我们将这个组称为: “自行车运动组.” Researchers then found 130 people to make up a second group. Within this group,75 people were aged 57 to 80. The other 55 were between the ages of 20 and 36. The people in this group were also healthy,but they did not exercise regularly. We will call this group the “non-exercisers”. 研究人员随后找了130人组成第二组.在这一组中,有75人年龄在57岁至80岁之间.其他55人年龄在20岁至36岁之间.这一群体的人也很健康,但他们没有定期锻炼.我们将这个小组称为: “非运动组”. Smokers,heavy drinkers of alcohol and people with other health issues were not included in the study. 吸烟者,酗酒者以及有其他健康问题的人士未参与此次研究. Then,researchers gave both groups a series of tests. They testd their muscle mass,muscular strength,percentage of body fat,cholesterol levels and the strength of their immune system. And male participants had their testosterone levels checked. 然后,研究人员对这两组进行了一系列的测试.他们测试他们的肌肉质量,肌肉力量,身体脂肪的百分比,胆固醇水平和他们的免疫系统的强度.还检查了男性参与者的睾酮水平. The the researchers compared the result of the two groups. 然后研究人员比较了两组的结果. Result showed that the cyclists did not experience body changes usually equated with a normal aging process. For example,they did not lose muscle mass or strength. Also,their body fat and cholesterol levels did not increase with age. 结果表明,骑自行车的人没有经历身体变化,通常等同于正常的老化过程.例如: 他们的肌肉质量或力量没有减少.此外,他们的身体脂肪和胆固醇指标并没有随着年龄增加而上升. The male cyclists’ testosterone levels had also remained high. Researchers say this may mean that they avoided at least one major symptom of male menopause. 男性骑行者的睾酮水平也一直很高.研究人员说: 这可能意味着他们至少避免了男性更年期的一个主要症状. The reseachers also found something they had not expected. The study showed that the immune systems of the cyclists did not seem to age either. For this,they looked at an organ called the thymus. The thymus makes immune cells called T-cells. 研究人员还发现他们没有预料的事情.该研究表明,骑自行车的免疫系统似乎也没有老化.为此,他们观察了一个称为胸腺的器官.胸腺制造的免疫细胞称为T细胞. The University of Arizona’s biology department explains on its website that T-cells are a type of white blood cell and are made in our bone marrow. 亚利桑那大学生物系在其网站上解释说,T细胞是一种白血球,在我们的骨髓中生成. As the article says: “There are two types of T-cells in your body: Helper T-cells and Killer T-cells. Killer T-cells do the work of destorying the infected cells. The Helper T-cells coordinate the attack.” 正如文章所说: “你体内有两种类型的T细胞: 辅助型T细胞和杀伤型T细胞. 杀伤型T细胞的工作是消灭感染的细胞.辅助型T细胞协调攻击.” Starting at about the age of 20,the thymus of most people starts to get smaller. It also starts to make fewer T-cells. 从大约20岁开始,大多数人的胸腺开始变小.所产生的T细胞也开始相应的减少. Howerver,in this study,the T-cell production by the thymuses of the cyclists had not slowed down with age. They were making as many T-cells as those of a young person. 然而,在这项研究中,骑自行车者的胸腺产生的T细胞没有随着年龄增加而减慢.他们正在制造与年轻人一样多的T细胞. Janet Lord is director of the Institute of Inflammation and Ageing at the University of Birmingham. In a press statement,she offers the words of Hippocrates,often called the “father of medicine.” 珍妮特爵士是伯明翰大学炎症和老化研究所所长.在新闻发布会上,她引用了通常被称为”医学之父”的希波克拉底的话. She write: “Hippocrates in 400 BC said that exercise is man’s best medicine,but his message has been lost over time and we are an increasingly sedentary society.” 她写到: “公元前400年希波克拉底说: 运动是人类最好的药物,但随着时间的流逝,他的话渐渐被大家所遗忘,我们正处在一个日益就久坐的社会.” Professor Stephen Harridge is director of the Center of Human &amp; Aerospace PhysiologicalSciences at King’s College London. He addressed the common question of what came first——the chicken or the egg? In this case,the question became,”Which camej first——the healthy behavior or the good health?” 斯蒂芬哈里教授是伦敦国王学院人体与航天生理学中心主任.他解释了一个老生常谈的问题——先有鸡还是先有蛋?在这种情况下,这个问题变成了: “有着健康行为,会有一个健康的身体.还是有了健康的身体才会进行健康的行为.” When talking about the findings of the study,he said “the cyclists do not exercise because they are healthy,but that they are healthy because they have been exercising for such a large portion of their lives.” 在谈到这项研究的结果时,他说: “骑自行车的人之所以健康,并不是因为他们身体健康,而是因为他们“在生命的大部分时间里一直在锻炼.” The researchers advise us all to find an exercise that we like and to make physical activity a priority in our lives. 研究人员建议我们所有人都要找到自己喜欢的运动,并将身体活动作为我们生活中的优先事项. They published their findings in Aging Cell. The study is part of ongoing research by the two universities. 他们在《老龄细胞》发表了他们的研究.这项研究是两所大学正在进行研究的一部分. And that’s the Health&amp;Lifestyle report.I’m Anna Matteo. 重点词汇 commitment (n) 承诺,保证. routine (n) [计]程序,日常工作. movement (n) 运动,活动. muscle (n) 肌肉,力量. mass (n) 块,团. percentage (n) 百分比,百分率. cholesterol (n) [生化]胆固醇. participant (n) 参与者,关系者. cyclist (n) 骑自行车的人. participant (n) 参与者. testosterone (n) 睾酮,睾丸素. symptom (n) 症状,征兆. menopause (n) 更年期,活动终止期. organ (n) 器官,机构. thymus (n) 胸腺. marrow (n) 髓,骨髓. inflammation (n) [病理]炎症. Hippocrates (n) 希波克拉底(希腊的名医-称医药之父) professor (n) 教授,教师. aerospace (n) 航空宇宙.[航]航空航天空间. physiological (n) 生理学的,生理的. portion (n) 部分,一份. priority (n) 优先,优先权. equate (v) 使相等,视为平等. remain (v) 保持,留下,剩余. avoid (v) 避免,避开. coordinate (v) 协调. immune (a) 免疫的. infected (a) 被感染的. sedentary (a) 久坐的,坐惯的. ongoing (a) 不间断的,进行的. 重点短语 be made up : 由..组成,被构成. equate with : 把..等同,使相等,同等相待. at least : 至少","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"文件上传与下载","slug":"文件上传与下载","date":"2019-04-26T02:28:32.000Z","updated":"2019-04-28T04:18:25.057Z","comments":true,"path":"2019/04/26/文件上传与下载/","link":"","permalink":"http://yoursite.com/2019/04/26/文件上传与下载/","excerpt":"","text":"学习笔记 : Java web之文件的上传与下载文件上传如何实现文件上传Apache组织提供了一个开源组件Commons-FileUpload( 依赖于common-io ),该组件可以方便地将multipart/form-data类型请求中的各种表单解析出来,并实现一个或多个文件的上传,同时也可以限制上传文件的大小等内容..并且性能优异,使用简单. FileUpload组件是通过Servlet来实现文件上传功能的,其工作流程如下图所示. 文件上传相关APIFileItem InterfaceFileItem接口用于封装单个表单字段元素的数据,一个表单字段元素对应一个FileItem对象. DiskFileItemFactory ClassDiskFileItemFactory类用于将请求的消息实体中的每一个文件封装成单独的FileItem对象.如果上传的文件比较小,将直接保存在内存中,如果上传的文件比较大,则会以临时文件的形式,保存在磁盘的临时文件中,默认情况下,文件保存在内存/磁盘临时文件夹的临界值为10240,既10KB. ServletFileUpload ClassServletFileUpload类是Apache组件处理文件上传的核心高级类,通过使用parseRequest(HttpServletRequest)方法可以将HTML中每个表单提交的数据封装成一个FileItem对象,然后以List列表的形式返回. 文件上传案例 JSP页面代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;file&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;upload the specified the file&lt;/h3&gt; &lt;hr&gt; &lt;form action=\"UploadServlet2\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div align=\"center\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"id\"/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;照片&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"image\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;%-- 文件上传结果 --%&gt; &lt;% String result = (String)request.getAttribute(\"result\"); if(result!=null)&#123; out.println(\"&lt;script&gt;alert(' \"+result+\" ')&lt;/script&gt;\"); &#125; %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Servlet类 : 获取表单及其上传文件的信息.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package pers.huangyuhui.file.servlet;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadBase.SizeLimitExceededException;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.commons.io.filefilter.SuffixFileFilter;@WebServlet(\"/UploadServlet2\")public class UploadServlet2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public UploadServlet2() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html;charset=utf-8\"); String message = \"上传失败 !\";// 上传结果 // FileItemFactory fileItemFactory = new DiskFileItemFactory(); DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(); fileItemFactory.setSizeThreshold(1024 * 1024);// // 设置将上传的文件以临时文件的形式保存在磁盘的临界值 // 默认情况下,采用的是系统默认的临时文件路径,可以通过该方式获取: System.getProperty(\"java.io.tmpdir\"); fileItemFactory.setRepository(new File(\"D:\\\\Java web\\\\temporary files\"));// 将上传的文件以临时文件的形式保存在指定的目录下 // 判断请求消息中的内容是否是: multipart/form-data类型 if (ServletFileUpload.isMultipartContent(request)) &#123; // 文件上传的核心高级类 ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); servletFileUpload.setSizeMax(1024 * 20); // 设置请求消息实体内容(既上传数据)的最大尺寸限制: 20KB try &#123; // 将HTML中每个表单提交的数据封装成一个FileItem对象,然后以List列表的形式返回 List&lt;FileItem&gt; fileItems = servletFileUpload.parseRequest(request); // 限制上传的文件类型 String[] suffixs = new String[] &#123; \".exe\", \".bat\", \".c\", \".java\", \".sh\", \"html\", \".css\", \".js\" &#125;; SuffixFileFilter suffixFileFilter = new SuffixFileFilter(suffixs); // 遍历集合 File file = null; String sno = null; String sname = null; String fileName = null; for (FileItem fileItem : fileItems) &#123; String item = fileItem.getFieldName(); if (fileItem.isFormField()) &#123;// 普通文本表单字段 if (item.equals(\"id\")) &#123; sno = fileItem.getString(); &#125; else if (item.contentEquals(\"name\")) &#123; sname = fileItem.getString(); &#125; else &#123; System.out.println(\"others value ..\"); &#125; &#125; else &#123;// 文件表单字段 fileName = fileItem.getName(); file = new File(request.getSession().getServletContext().getRealPath(\"/upload/\" + fileName)); if (suffixFileFilter.accept(file)) &#123; message = \"禁止上传此类型文件 !\"; &#125; else &#123; file.getParentFile().mkdirs();// 创建目录 fileItem.write(file);// 上传文件 message = \"success to upload !\"; System.out.println(\"id: \" + sno + \"\\nname: \" + sname + \"\\nthe file name: \" + fileName + \"\\nthe file path: \" + file.getAbsolutePath()); // 上传者及文件信息 &#125; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; message = \"error : please choose the specified file !\"; &#125; catch (SizeLimitExceededException e) &#123; message = \"error : the file size exceeds limit !\"; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 将提示信息保留在request对象中 request.setAttribute(\"result\", message); request.getRequestDispatcher(\"upload.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 略.. 文件下载文件下载程序流程浏览器通常会直接处理响应的实体内容,这时需要在HTTP响应消息中设置两个响应消息头字段,指定接收程序处理数据内容的方式为下载方式,当点击”下载”超链接时,系统将请求提交到对应的Servlet.在该Servlet中,程序流程如下 : 根据该地址创建文件字节输入流. 通过该流读取下载文件的内容. 将读取的内容通过输出流写到目标文件中. HTTP中设置两个响应消息头,具体如下.1234//设定接收程序处理数据的方式Content-Disposition: attachment;filename=//设定实体内容的MIME类型Content-Type: application/x-msdownload 文件下载案例 JSP页面代码 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"&gt; &lt;title&gt;down the file&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;&lt;/h3&gt; &lt;a href=\"DownloadServlet?filename=文件.png\"&gt; Click to download this file .. &lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Servlet类 : 设置所要下载的文件以及文件在浏览器中打开的方式. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.file.servlet;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.tomcat.util.codec.binary.Base64;@WebServlet(\"/DownloadServlet\")public class DownloadServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public DownloadServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); // 获取需要下载的文件名 String fileName = request.getParameter(\"filename\"); // 设定接收程序处理数据的方式( MIME type : application/octet-stream ) response.addHeader(\"Content-Type\", \"application/octet-stream\"); /* * 根据不同浏览器进行不同的编码处理,以防乱码 */ // User-Agent: 首部包含了一个特征字符串,用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号. String agent = request.getHeader(\"User-Agent\"); if (agent.toLowerCase().indexOf(\"firefox\") != -1) &#123; response.addHeader(\"Content-Disposition\", \"attachment;filename==?UTF-8?B?\" + new String(Base64.encodeBase64(fileName.getBytes(\"UTF-8\"))) + \"?=\"); &#125; else &#123; // 设定实体内容的MIME类型并使用encode(String s, Charset charset)解决乱码问题: Google Chrome,Microsoft Eage .. response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"UTF-8\")); &#125; // 读取文件 InputStream inputStream = getServletContext().getResourceAsStream(\"/resource/\" + fileName); // 获取response对象的输出流 OutputStream outputStream = response.getOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1) &#123; outputStream.write(buffer, 0, len); &#125; outputStream.close(); inputStream.close(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 程序运行结果 : 略..","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"JSP 标准标签库","slug":"JSP-标准标签库","date":"2019-04-26T02:24:15.000Z","updated":"2019-04-28T07:34:47.279Z","comments":true,"path":"2019/04/26/JSP-标准标签库/","link":"","permalink":"http://yoursite.com/2019/04/26/JSP-标准标签库/","excerpt":"","text":"学习笔记 : Java web之JSTLJSTL介绍从JSP 1.1规范开始,JSP就支持使用自定义标签,使用自定义标签大大降低了JSP页面的复杂度.同时增加了代码的重用性.因此市面上出现了许多由不同厂商定制的功能相同的标签,继而导致网页制作者无从选择的问题.为了解决该问题,Sun公司制定了一套标准标签库(Java Server Pages Standard Tag Library),简称JSTL.其为一个JSP标签集合,封装了JSP应用的通用核心功能. JSTL标签库 Core : 核心标签库,它包含实现Web应用中通用操作的标签. SQL : 数据库标签库,用于访问数据库和对数据库中的数据进行操作的标签. XML : 操作XML文档的标签库,它包含对XML文档中的数据进行操作的标签. Functions : 函数标签库,提供了一套自定义EL函数,包含JSP网页制作者经常要用到的字符串操作. JSTL的使用例如 : 测试&lt;c:out&gt;标签,需要使用taglib指令导入Core标签库.代码如下 :1&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; 在上述代码中,taglib指令的uri属性用于指定引入标签库描述文件中的URL, 其prefix属性用于指定引入标签库描述符文件的前缀.在JSP文件中使用这个标签时都要使用这个前缀.","categories":[],"tags":[{"name":"Java web","slug":"Java-web","permalink":"http://yoursite.com/tags/Java-web/"}]},{"title":"VOA:Researchers Find Clues that Depression May Speed Brain Aging","slug":"VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging","date":"2019-04-25T22:51:42.000Z","updated":"2019-04-28T01:49:08.602Z","comments":true,"path":"2019/04/26/VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging/","link":"","permalink":"http://yoursite.com/2019/04/26/VOA-Researchers-Find-Clues-that-Depression-May-Speed-Brain-Aging/","excerpt":"","text":"Researchers Find Clues that Depression May Speed Brain AgingMemory and thinking skills naturally slow with age. Scientists are now looking inside living brains to tell if depression might speed aging. The scientists report that some of the signs they have found are worrisome. 随着年龄增长,人的记忆力和思维能力也随之减退.科学家正在研究活人大脑的内部情况,以判断抑郁症是否会加速大脑老化.科学家报告称,他们发现一些迹象令人十分担忧. Depression has long been linked to some cognitive problems. Depression late in life even may increase the risk of developing Alzheimer&#39;s disease. Yet how depression might harm the ability to remember things and things and think clearly is not yet known. 长期以来,抑郁症就与一些认知障碍相关联.在晚年,抑郁症甚至可能增加患增加阿尔兹海默病的风险.而然,关于抑郁症会如何损害记忆力及清晰的思维能力,目前尚不清楚. One pssibility : Brain cells communicate by sending messages across connections called synapses. Generally,good cognition is linked to more and stronger synapses. With a weakening of congnitive ability,those connections slowly shrink and die. But unitl recently,scientists could count synapses only in brain tissue collected after the person dies. 一种可能是: 脑细胞间通过被称为突触的连接进行交流.一般来说,良好的认知能力表明突触数量多且强健.随着认知能力的退化,突触会慢慢萎缩并消亡.但直到最近,科学家还仅能通收集逝者的大脑组织来计算出突触的数量. Yale University scientists used a new method to study the brains of living people. They discovered that patients with depression had a lower density of synapses than healthy people of the same age. 耶鲁大学科学家采用了一种新方法来研究活人的大脑.他们发现,抑郁症患者的突触密度比同龄的健康人群要低. The lower the density,the more severe the signs of depression. Yele University neuroscientist Irna Esterlis says this is especially true of problems with loss of interest in activities patients once enjoyed. She spoke at a meeting of the American Association for the Advancement of Science. 突触密度越低,患抑郁症的迹象越严重.耶鲁大学神经学家伊琳娜·埃斯特曾在美国科学促进会的一次会议发言上说: 病人对曾经喜欢的活动失去兴趣的问题尤其如此. Esterlis was not studying just older adults,but people of all ages,including those too young for any cognitive changes to be noticeable. She was working from a theory that early damage can build up. 埃斯特里并不仅仅是在研究老年人,而是所有年龄段的人群,包括那些非常年轻,无法注意到任何认知变化的人群.她的研究建立在”早起伤害会不断积累”这一理论上. “We think depression might be accelerating the normal aging,”she said. 她说: “我们认为抑郁症可能正加速正常衰老.” Her studies are small. To prove if depression really does increase the risk of cognitive problem as we age would require more investigation. Jovier Evans is a scientist with the U.S. National Institute of Mental Health. He proposed a study of synaptic density on larger numbers of people as they get older,to see if and how it changes over time in those with and without depression. 她进行的是小型研究.要证明随着年龄的增长,抑郁症确实会增加认知障碍的风险需要进行更多的调查.乔维尔·埃文斯是美国国家心理健康研究所的科学家.他提出一项研究: 针对更多的人群,研究他们随着年龄的增长,突触密度的变化,以此来判断在那些患抑郁症和无抑郁症的人群中,随着时间的推移,突触密度是否改变以及如何改变. Eaterlis has announced plans for a larger study to do that. Volunteers would be injected with a radioactive substance that links up to a protein in the vesicles,or storage containers,used by synapses. Then each volunteer would be given an imaging test,known as a PET scan. During the test,areas with synapses light up,enabling researchers to see how many are in different parts of the brain. 埃斯特里已宣布要进行大规模对的研究计划.志愿者将注射放射性物质,该物质与囊泡中的蛋白质或突触使用的储存容器相连.然后,每位志愿者将进行影像检查,也就是PET扫描.检查期间,突触区域会亮起来,这样研究人员就能够看到大脑的不同部位有多少突触. Esterlis said there are no medications that target synapse damage. 埃斯特里表示目前没有专门治疗突触损伤的药物. Doctor Mary Sano directs the Mount Sinai Alzheimer’s Disease Research Center in New York. She was not involved in the new research. 玛丽·萨诺医生是纽约西奈山阿尔茨海默病研究中心的负责人.她没有参与这项新研究. Sano warned that normal cognitive aging is complex process that involves other health problems,such as heart disease. It might be that depression does not worsen synaptic weakening. It could just makes the problem more noticeable,she said. 萨诺提醒说,正常的认知衰退是个复杂的过程,设计其他健康问题,比如心脏病.也有可能抑郁症不会加速突触退化.她说,抑郁症可能只是让问题更显而易见. With depression “at any age,there’s a hit on the brain. At an older age hit may be more visible because there may already be some loss,” she explained. 患抑郁症 “在任何年纪,都会对大脑造成伤害.对较大年纪的人群而言,这种伤害可能更明显,因为他们的大脑可能已有一些损伤.” I’m Ashley Thompson. 重点词汇 cognition (n) 认识,认识能力. depression (n) 抑郁症,精神忧郁. Alzheimer (n) 阿尔茨海默病. synapse (n) 突触. tissue (n) 组织. density (n) 密度. neuroscientist (n) 神经系统科学家. association (n) 协会,联盟. theory (n) 理论,原理. aging (n) 老化,陈化. investigation (n) 调查,调查研究. substance (n) 物质,实质. vesicle (n) 泡,囊. target (n) 目标,指标. accelerate (a) 加速,加快. visible (a) 看的见得. severe (a) 严峻的,严厉的. noticeable (a) 显著的,显而易见的. cognitive (a) 认知的,认识的. synaptic (a) 突触的. radioactive (a) [核]放射性的,有辐射的. complex (a) 复杂的,合成的. shrink (v) 收缩,畏缩. 重点短语 build up : 增进,加强. link up : 会合,连接. involved in : 参与,涉及.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"JSP 自定义标签","slug":"JSP-自定义标签","date":"2019-04-25T03:26:47.000Z","updated":"2019-04-25T13:39:56.617Z","comments":true,"path":"2019/04/25/JSP-自定义标签/","link":"","permalink":"http://yoursite.com/2019/04/25/JSP-自定义标签/","excerpt":"","text":"JSP 自定义标签入门 什么是JSP自定义标签?自定义标签可以有效地将HTML代码与Java代码分类,从而使不懂Java编程的HTLML设计人员也可以编写出功能强大的JSP页面.JSP复规范中定义了多个用于开发自定义标签的接口和类,它们都位于javax.servlet.jsp.tagext包中,这些接口和类的继承关系如下所示. 标签分类在JSP2.0之前,所有的标签都需要实现Tag接口,这样的标签称为: 传统标签( javax.servlet.jsp.tagext.Tag ). 后来为了简化标签的开发,JSP2.0规范又定义了一种新类型的标签,称为简单标签( javax.servlet.jsp.tagext.SimpleTag ) 自定义标签的开发步骤 编写标签处理器Tag接口和SimpleTag接口定义了JSP页面与标签处理器类之间的通信规则.如果JSP引擎在编译JSP页面时遇到了自定义标签,传统标签将会调用标签处理器的doStartTag()方法,简单标签将会调用标签处理器类的doTag()方法. 编写标签库描述符文件要想让JSP引擎在遇到自定义标签时,能找到其所对应的标签处理器,还必须编写是一个标签描述符( Tag Library Descriptor )文件.简称: TLD文件. 注意: 自定义标签的根标签(&lt;taglib&gt;)使用的是schema约束.其标签内容可以从 : &lt;Tomcat安装目录&gt;\\webapps\\examples\\WEB-INF\\jsp2\\jsp2-example-taglib.tld中复制即可. 在JSP页面导入和使用自定义标签TLD文件编写完成后,就可以在JSP文件中使用自定义标签.在使用自定义标签之前,首先需要使用taglib指令来引入TLD文件. 传统标签 Tag 接口 Tag接口定义了JSP页面与标签处理器之前的通信规则,当JSP容器将JSP页面翻译成Servlet源文件时,如果遇到JSP标签,会创建标签处理器类的实例对象.然后依次调用标签处理器的如下方法.1setPageContext() ——&gt; setParent() ——&gt; doStartTag() ——&gt; doEndTag() ---&gt; release() IterationTag 接口 在自定义标签的开发过程中,其可以对标签体的内容进行重复处理. TagSupport类实现了该接口,简化了程序的编写. BodyTag 接口 在实现自定义标签时,其可以根据需要对标签体的内容进行处理后再向浏览器输出. 案例-实现一个传统自定义标签描述 : 开发一个显示IP地址的自定义标签 编写完成标签功能的标签处理器类 123456789101112131415161718192021222324252627282930package pers.huangyuhui.tag.handler;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.TagSupport;/** * @ClassName: IpTag * @Description: 传统标签处理器 * @author: HuangYuhui * @date: Apr 25, 2019 4:06:28 PM * */public class IpTag extends TagSupport &#123; private static final long serialVersionUID = -8446674958888389920L; @Override public int doStartTag() throws JspException &#123; String IP = pageContext.getRequest().getRemoteAddr(); try &#123; pageContext.getOut().write(\"访问用户的IP地址为 : \" + IP); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doStartTag(); &#125;&#125; 编写TLD文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 标签库的版本号 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;!-- 标签库的名称 --&gt; &lt;short-name&gt;TraditionalTag&lt;/short-name&gt; &lt;!-- 标签库的URI --&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;!-- 注册一个自定义的标签 --&gt; &lt;tag&gt; &lt;!-- 指定自定义标签的注册名称 --&gt; &lt;name&gt;ipTag&lt;/name&gt; &lt;!-- 指定标签的标签处理器类 --&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.IpTag&lt;/tag-class&gt; &lt;!-- 指定标签的类型 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写JSP文件,并导入和使用自定义标签 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%-- 导入自定义的标签库描述符文件 --%&gt;&lt;%@taglib uri=\"https://yubuntu0109.github.io\" prefix=\"yu\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;yu:ipTag/&gt; &lt;/body&gt;&lt;/html&gt; 简单标签 SimpleTag 接口 SimpleTag接口中的方法和传统标签中定义的签名有所区别,但是功能却基本一致,例如: 都实现了给标签处理器传递pageContext对象和父标签处理器对象的功能.而且JSP容器执行简单标签处理器的顺序也和执行传统标签处理器的顺序一致.简单标签处理器的执行流程如下所示:1JSP容器实例化标签处理器类 ——&gt; setJspContext() ——&gt; setParent() ——&gt; 设置属性的setter方法 ——&gt; setJspBody() ——&gt; doTag() JspFragment 类 JSP容器在处理简单标签时,会把标签体内容用一个JspFragment对象表示,并调用标签处理器对象的setJspBody()方法将JspFragment对象传递给标签处理器对象,标签开发者可以根据需要调用JspFragment对象的方法来决定是否输出标签体,或者循环多次输出标签体等.其中JspFragment的invoke(Write out)方法是简单标签开发中最重要的一个方法,它用于控制如何执行标签体的内容. SimpleTagSupport 类 该类实现了SimpleTagSupport接口,继而使得简单标签处理器的编写变得简化. 案例-实现一个自定义简单标签描述 : 自定义简单标签,实现重复执行标签体的功能. 编写标签处理器类 123456789101112131415161718192021222324252627282930313233package pers.huangyuhui.tag.handler;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.JspFragment;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: SimpleIterate * @Description: 简单标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 4:52:19 PM * */public class SimpleIterate extends SimpleTagSupport &#123; private int num; public void setNum(int num) &#123; this.num = num; &#125; @Override // 对标签进行逻辑处理 public void doTag() throws JspException, IOException &#123; // 获取标签体 JspFragment jspFragment = this.getJspBody(); for (int i = 0; i &lt; num; i++) &#123; jspFragment.invoke(null); &#125; &#125;&#125; 编写简单标签库描述符文件 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;!-- 标签库的版本号 --&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;!-- 标签库的名称 --&gt; &lt;short-name&gt;SimpleTag&lt;/short-name&gt; &lt;!-- 标签库的URI --&gt; &lt;uri&gt;/SimpleTag&lt;/uri&gt; &lt;!-- 注册一个自定义的标签 --&gt; &lt;tag&gt; &lt;name&gt;simpleIterate&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.SimpleIterate&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;!-- 用于描述自定义标签的属性 --&gt; &lt;attribute&gt; &lt;!-- 指定属性的名称 --&gt; &lt;name&gt;num&lt;/name&gt; &lt;!-- 指定在JSP页面调用自定义标签时是否必须设置这个属性 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写JSP文件,并导入和使用自定义标签 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib uri=\"/SimpleTag\" prefix=\"yu\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;yu:simpleIterate num=\"5\"&gt; Hello SimpleTag !&lt;br&gt; &lt;/yu:simpleIterate&gt; &lt;/body&gt;&lt;/html&gt; 案例-模拟JSTL的&lt;c:choose&gt;,&lt;c:when&gt;,&lt;c:otherwise&gt;标签描述 : 通过模仿JSTL核心标签库中的&lt;c:choose&gt;,&lt;c:when test=””&gt;,&lt;c:otherwise&gt;标签,开发一套自己的标签 : &lt;yu:choose&gt;,&lt;yu:when test=&quot;&quot;&gt;,&lt;yu:otherwise&gt; 编写标签&lt;yu:choose&gt;的标签处理器类 : ChooseTag.java 1234567891011121314151617181920212223242526272829303132package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: ChooseTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:15:53 PM * */public class ChooseTag extends SimpleTagSupport &#123; // 作为标识符用于控制&lt;yu:when&gt;和&lt;yu:otherwise&gt;的标签体是否执行 private boolean flag; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; @Override public void doTag() throws JspException, IOException &#123; this.getJspBody().invoke(null); &#125;&#125; 编写标签&lt;yu:when test=&quot;&quot;&gt;的标签处理器类 : WhenTag.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspTagException;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: WhenTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:19:01 PM * */public class WhenTag extends SimpleTagSupport &#123; // 用于接收标签中`test`属性传入的值 private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; // 获得父类标签对象 JspTag tag = this.getParent(); // 判断父标签是否为: ChooseTag if (!(tag instanceof ChooseTag)) &#123; throw new JspTagException(\"ERROR : OUT OF CHOOSE TAG\"); &#125; // 将父类标签对象强转成`ChooseTag`类型 ChooseTag chooseTag = (ChooseTag) tag; // 判断`WhenFlag`为true且父标签中的`flag`为false时执行该标签体 if (test &amp;&amp; !(chooseTag.isFlag())) &#123; this.getJspBody().invoke(null); // 执行完标签体后,将父标签中的`flag`置为true,防止其它嵌套标签体继续执行 chooseTag.setFlag(true); &#125; &#125;&#125; 编写&lt;yu:otherwise&gt;的标签体处理器类 : OtherwiseTag.java 123456789101112131415161718192021222324252627282930313233343536373839404142package pers.huangyuhui.tag.handler.choose;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspTagException;import javax.servlet.jsp.tagext.JspTag;import javax.servlet.jsp.tagext.SimpleTagSupport;/** * @ClassName: OtherwishTag * @Description: 标签处理器 * @author: HuangYuhui * @date: Apr 24, 2019 5:46:33 PM * */public class OtherwiseTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; // 获得父标签对象 JspTag jspTag = this.getParent(); // 判断父标签是否是: ChooseTag if (!(jspTag instanceof ChooseTag)) &#123; throw new JspTagException(\"ERROR : OUT OF CHOOSE TAG\"); &#125; // 将父类标签对象强转成`ChooseTag`类型 ChooseTag chooseTag = (ChooseTag) jspTag; // 判断父标签中的`flag`为false时,执行该标签体 if (!chooseTag.isFlag()) &#123; this.getJspBody().invoke(null); // 执行完标签体后,将父标签中的`flag`置为true,防止其它嵌套标签体继续执行 chooseTag.setFlag(true); &#125; &#125;&#125; 编写TLD文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;模拟JSTL的choose,when,otherwish标签&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;SimpleTag&lt;/short-name&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;!-- choose tag --&gt; &lt;tag&gt; &lt;name&gt;choose&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.ChooseTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; &lt;!-- when tag --&gt; &lt;tag&gt; &lt;name&gt;when&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.WhenTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;!-- 注意: 属性名一定要和该标签的处理器类中的属性名一致 ! 否则抛出异常: Unable to find setter method for attribute: xxx .. --&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;!-- otherwise tag --&gt; &lt;tag&gt; &lt;name&gt;otherwise&lt;/name&gt; &lt;tag-class&gt;pers.huangyuhui.tag.handler.choose.OtherwiseTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 编写两个JSP文件,对三个自定义标签进行测试. 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=\"center\"&gt;请选择你热爱的运动哟 (づ￣3￣)づ╭❤～&lt;/h3&gt; &lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form action=\"choose_when_otherwise.jsp\"&gt; &lt;input type=\"radio\" name = \"hobby\" value=\"badminton\"/&gt;羽毛球 &lt;input type=\"radio\" name = \"hobby\" value=\"footall\"/&gt;足球 &lt;input type=\"radio\" name = \"hobby\" value=\"basketball\"/&gt;篮球 &lt;input type=\"radio\" name = \"hobby\" value=\"others\"/&gt;其它&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%-- 导入自定义的标签库描述符文件 --%&gt;&lt;%@taglib uri=\"https://yubuntu0109.github.io\" prefix=\"yu\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试自定义标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;yu:choose&gt; &lt;yu:when test=\"$&#123;param.hobby=='badminton' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 羽毛球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:when test=\"$&#123;param.hobby=='footall' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 足球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:when test=\"$&#123;param.hobby=='basketball' &#125;\"&gt; &lt;p&gt;你热爱的运动是: 篮球&lt;/p&gt; &lt;/yu:when&gt; &lt;yu:otherwise&gt; &lt;p&gt;哎哟 ~ 难道你只会coding ! ヾ(◍°∇°◍)ﾉﾞ&lt;/p&gt; &lt;/yu:otherwise&gt; &lt;/yu:choose&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"VOA:5 Habits of Very Successful People","slug":"VOA-5-Habits-of-Very-Successful-People","date":"2019-04-25T02:08:13.000Z","updated":"2019-04-25T14:06:53.457Z","comments":true,"path":"2019/04/25/VOA-5-Habits-of-Very-Successful-People/","link":"","permalink":"http://yoursite.com/2019/04/25/VOA-5-Habits-of-Very-Successful-People/","excerpt":"","text":"5 Habits of Very Successful PeopleFrom VOA Learning English,this is Health&amp;Lifestyle report. 欢迎收听VOA慢速英语健康及生活方式报道. Having success and being able to meet one’s goals requires knowledge,a sense of direction,hard work and resources. Some people might add to that list luck,connections and perhaps a strong belief in yourself. 获得成功以及达到某人的目标需要知识,方向感,努力付出和资源.一些人也许会将幸运,关系和自信加入其中. We accomplish our goals one step at a time,doing a little each day. So,using your day effectively is important. 我们一步步完成自己的目标,每天完成一点.所以高效率地过好每天很重要. On many websites——from Forbes magazine and Fast Commpany to health and physical fitness sites——productivity experts share advice on how to achieve your career and life goals. Most of the experts agree on one thing: Starting your day on the right foot is most important. 很多网站上,从福布斯杂志,快递公司到健康网站,专家都分享如何能够实现职业和生活目标的建议.很多专家都同意一点: 每一天开一个好头最重要. Collected from these websites,here are five ideas on how to start your day off right. 根据这些网站整理出五点,关于如何做到开门大吉. Get up an hour early. 第一: 早起一小时. People who get up early in the morning have a jump on the day. For starters,they’s awake! And some studies show that our willpower and attention span are strongest in the morning. In fact,the morning may be the most productive part of your day. 早起的人们在那一天就已经领先一步.首先,他们已经清醒了.一些研究显示,我们的意志力和注意力在早上最集中.事实上,早晨可能是你一天当中效率最高的时候. In American English,we like to say,”The early bird gets the worm.” Here,if you’re a bird,the worm is the reward. So,this expression means that people who rise up early have a head start and,therefore,are more likely to succeed. 在美式英语中,我们喜欢说: “早起的鸟儿有虫吃.” 如果你是一只鸟,虫子就是你早起的回报.这个表达是指早起的人们捷足先登,因此更可能成功. Inventor,philosopher and writer Benjamin Franklin would probably agree. Americans like to use Franklin’s memorable expressions. One of them is “Early to bed,early to rise,makes a man healthy,wealthy and wise.” 发明家,哲学家及作家的本杰明·富兰克林可能会同意这一点.美国人喜欢引用富兰克林的经典语录.其中一条是: “早睡早起会让人聪明,富有及智慧.” Of course,there are exceptions. People who are “night owls“ do their best work and their best thinking at night. 当然也有例外.”夜猫子”型的人在晚上的工作效率最高.思维最活跃. Drink a glass of with lemon juice. 第二: 喝一杯柠檬水. While your coffee is being prepared or waiting for your tea water to heat up,drink a glass of water with lemon juice. 当你在煮咖啡或蒸茶时,先喝一杯柠檬水. Why? Health experts say that drinking a combination of lemon juice and water first thing in the morning jump-starts the body’s metabolism. Not only does it jump start your body’s cells,but this kind keeps them moving throughout the day. 为什么呢? 健康专家表示,早上先喝一杯柠檬会激活身体的新陈代谢.不仅会激活你身体的细胞,还会让这些细胞整天保持运转. Don’t answer emial or jump into social media as soon as you get up. 第三: 一起床不要先回邮件或查看社交媒体. Your coffee or tea is ready. So,you decide to look at your email quickly or open up your Facebook account. Well,don’t. This is a great way to forget about the day ahead. 你的咖啡或茶煮好了.你决定先快速浏览一遍邮件或打开你的社交账户.不要这么做.这会让你忘记这是全新的一天. We’ve all done it. You see a Facebook post from a friend you haven’t seen in a long time. He is angry about some political issue and the heated discussion pulls you in. Before you know it,an hour has passed,you’re angry with lawmakers and it’s not even nine in the morning yet! You hurry out the door so as not to be later for work. This is not the best way to start your day. 我们都这么做过.你看到很久不见的朋友发了一条状态.他对某个政治问题感到很气愤,然后拉你进入热烈的讨论.不知不觉中,一个小时过去了,你对立法者感到很生气,这时早上还不到九点.你为了避免上班迟到而急匆匆地冲出门外.这绝不是开启一天的最佳方式. Exercise ! Some people may disagree with this one. Exercising in the morning may not be for everyone. Some people like to exercise after work or at night. 一些人可能不同意.在早上锻炼并不适合所有人.一些人喜欢下班后或晚上锻炼. Physical fitness experts and trainers often suggest some form of exercise in the morning because the middle of the day is busy time for most people. By the day’end,you may not have the time or energy to exercise. How many times have you finished work and said to yourself. “I’m too tired to exercise! I’ll do it tomorrow.” 健身专家和教练通常会建议在早上做一些形式的运动,因为白天对大多数人来说就是最繁忙的时候.白天结束后,你可能就没有时间或精力去运动了.有多少次你下班后告诉自己: “我太累了,不能再锻炼了,明天再去锻炼吧!” Exercising in the morning prevents that from happening. 在早上锻炼可以防止这一点. Think about your day…at night. 第五,在晚上思考你白天做的事情. Meditate,visualize——whatever you call it——take time at the day to think back on all the things that have happened. Give thanks,if you want. And spend a little time to think about tomorrow. Some people who talk about “living in the present” may criticize this. But it may help you to prepare if you take a few minutes to think about what you need to do the next day. 冥想,思考——无论你将其称为什么—— 一天结束前花点时间想想今天发生过的事.感恩这一天.然后花点时间想想明天.一些坚持”活在当下”的人可能会批判这一点.但如果你能花几分钟想想第二天需要做些什么,可能会帮助你提前进行准备继而提高效率. Also,know that your day will probably change. You probably won’t have time to do everything you planned. But that’s fine. If you did one thing, that means you are one step closer in reaching one of your goals. And if you follow this advise,at least you’ve already gotten your exercise out of the way ! 同时要知道,这一天也许会发生某些变化,你也许没有时间做完你所计划的所有的事,但这也没关系.如果你做完一件事,就离你完成这个目标近了一步.如果你遵循这些建议,至少你不会忘了锻炼. And that’s the Health&amp;Lifestyle report.I’m Anna Matteo. 重点词汇 willpowr (n) 意志力,毅力. perhaps (n) 假定,猜想. magazine (n) 杂志. productivity (n) 生产力,生产率,生产能力. willpower (n) 意志力,毅力. owl (n) 猫头鹰,惯于晚上活动的人. span (n) 跨度,跨距,范围. worm (n) 虫,蠕虫. inventor (n) 发明家,[专利]发明人. philosopher (n) 哲学家,哲人. lawmaker (n) 立法者. combination (n) 结合,组合. metabolism (n) [生理]新陈代谢. memorable (a) 显著的,难忘的,值得纪念的. political (a) 政治的,党派的. meditate (v) 考虑,计划,冥想. visualize (v) 形象,想像,设想. criticize (v) 批评,评论,苛求.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"详解Java对象的引用及赋值","slug":"详解Java对象的引用及赋值","date":"2019-04-23T10:21:00.000Z","updated":"2019-04-23T14:16:50.974Z","comments":true,"path":"2019/04/23/详解Java对象的引用及赋值/","link":"","permalink":"http://yoursite.com/2019/04/23/详解Java对象的引用及赋值/","excerpt":"","text":"细节 : 详解Java中对象的引用及赋值问题引入 前言 前些天学习数据结构与算法时特意写了一篇名为详解Linked-list的实现方式及其应用的文章,其中循环链表的代码中就淋漓尽致地体现了Java中对象的引用与赋值 循环链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221package pers.huangyuhui.linkedlist;/** * @ClassName: CircularLinkedList * @Description: 操作循环链表 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 16, 2019 7:25:36 PM * */public class CircularLinkedList&lt;T&gt; &#123; // get the length of the circular linked list public int getLength(ListNode&lt;T&gt; headNode) &#123; int length = 0; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; if (currentNode == headNode) &#123; break; &#125; &#125; return length; &#125; // traverse the node of the circular linked list public void traverseNode(ListNode&lt;T&gt; headNode) &#123; System.out.println(\"\\n### [headNode]-address : \" + headNode + \"\\n\"); ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" -&gt; \"); currentNode = currentNode.getNext(); if (currentNode == headNode) &#123; break; &#125; &#125; System.out.print(\"headNode(\" + currentNode.getData() + \")\\n\"); &#125; // add new node at the tail of linked list public void insertAtListTail(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; //// 注意: 由于`currentNode`无变化,导致`currentNode.getNext() != headNode`继而进入进入死循环 !//// // currentNode.setNext(currentNode.getNext()); currentNode = currentNode.getNext(); &#125; newNode.setNext(newNode); if (headNode == null) &#123; headNode = newNode; &#125; else &#123; newNode.setNext(headNode); currentNode.setNext(newNode); &#125; &#125; // add new node at the header of linked list public ListNode&lt;T&gt; insertAtListHeader(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; currentNode = currentNode.getNext();// 尾节点 &#125; newNode.setNext(newNode);// 指针指向自身 if (headNode == null) &#123; headNode = newNode; &#125; newNode.setNext(headNode); currentNode.setNext(newNode); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = newNode; return headNode; &#125; // add the new node by the specified index public ListNode&lt;T&gt; insertNodeByIndex(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); return null; &#125; else if (position == 1) &#123; insertAtListHeader(headNode, newNode); &#125; else if (position == getLength(headNode)) &#123; insertAtListTail(headNode, newNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待插节点的前节点 currentNode = currentNode.getNext();// 待插节点 &#125; temp.setNext(newNode); newNode.setNext(currentNode); &#125; return headNode; &#125; // delete the last node public void deleteLastNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; temp = headNode; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (currentNode.getNext() != headNode) &#123; temp = currentNode; // 尾节点的前一个节点 currentNode = currentNode.getNext(); &#125; temp.setNext(headNode); currentNode = null; &#125; // delete the header node public ListNode&lt;T&gt; deleteHeaderNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return null; &#125; while (currentNode.getNext() != headNode) &#123; // currentNode.setNext(currentNode.getNext());//死循环 currentNode = currentNode.getNext(); &#125; currentNode.setNext(headNode.getNext()); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = headNode.getNext(); return headNode; &#125; // delete the node by the specified index public ListNode&lt;T&gt; deleteNodeByIndex(ListNode&lt;T&gt; headNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular linked list is empty !\"); return null; &#125; else if (position == 1) &#123; deleteHeaderNode(headNode); &#125; else if (position == getLength(headNode)) &#123; deleteLastNode(headNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待删节点的前节点 currentNode = currentNode.getNext();// 待删节点 &#125; temp.setNext(currentNode.getNext()); &#125; return headNode; &#125; // Test public static void main(String[] args) &#123; // 初始化链表头结点 CircularLinkedList&lt;Integer&gt; list = new CircularLinkedList&lt;&gt;(); ListNode&lt;Integer&gt; headNode = new ListNode&lt;&gt;(); headNode.setData(1);// 初始化链表头结点 headNode.setNext(headNode);// 节点指针指向自身 // 初始化待插入的链表节点 ListNode&lt;Integer&gt; a = new ListNode&lt;&gt;(); a.setData(2); ListNode&lt;Integer&gt; b = new ListNode&lt;&gt;(); b.setData(3); ListNode&lt;Integer&gt; c = new ListNode&lt;&gt;(); c.setData(4); ListNode&lt;Integer&gt; d = new ListNode&lt;&gt;(); d.setData(100); ListNode&lt;Integer&gt; e = new ListNode&lt;&gt;(); e.setData(101); ListNode&lt;Integer&gt; f = new ListNode&lt;&gt;(); f.setData(0); // 向链表的尾部添加三个节点 System.out.print(\"the origin node: \"); list.insertAtListTail(headNode, a); list.insertAtListTail(headNode, b); list.insertAtListTail(headNode, c); list.traverseNode(headNode); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 向链表中添加两个头结点( 头结点被更新 ) System.out.print(\"add two header node: \"); ListNode&lt;Integer&gt; newHeadNode = list.insertAtListHeader(headNode, d); // 注意: 由于`头结点`已在`insertAtListHeader`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode2 = list.insertAtListHeader(newHeadNode, e); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 在链表的指定位置上插入新的节点 System.out.print(\"Insert the new node at position 3: \"); list.insertNodeByIndex(headNode, f, 3); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表的尾节点 System.out.print(\"delete the tail node: \"); list.deleteLastNode(newHeadNode2); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 注意: 由于`头结点`已在`deleteHeaderNode`中已更新所以要向`traverseNode`传入新的头结点对象 ListNode&lt;Integer&gt; newHeadNode3 = list.deleteHeaderNode(newHeadNode2); System.out.print(\"delete the header node: \"); list.traverseNode(newHeadNode3); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表中指定位置的节点 ListNode&lt;Integer&gt; newHeadNode4 = list.deleteNodeByIndex(newHeadNode3, 4); System.out.print(\"delete the fourth node: \"); list.traverseNode(newHeadNode4); System.out.println(\"the length of the list: \" + list.getLength(headNode)); &#125;&#125; 程序运行结果 123456789101112131415161718192021222324252627282930the origin node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@16f656121 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(1)the length of the list: 4add two header node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 6Insert the new node at position 3: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 7delete the tail node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@311d617d101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(101)the length of the list: 6delete the header node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@7c53a9eb100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(100)the length of the list: 5delete the fourth node: ### [headNode]-address : pers.huangyuhui.linkedlist.ListNode@7c53a9eb100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; headNode(100)the length of the list: 4 基本数据类型作为参数传递 示例程序 12345678910111213public class test &#123; public static void main(String[] args) &#123; int i = 1; System.out.println(\"before change, i=\" + i); change(i); System.out.println(\"after change, i=\" + i); &#125; private static void change(int i) &#123; i = 5; &#125;&#125; 程序运行结果 12345678910111213141516171819202122232425262728before change, i=1after change, i=1``` 3. *结论* *当`基本数据类型`作为参数传递时,传递时的是`实参的副本`,既传的是`值`,无论在函数中怎么操作这个副本,实参的值是不会被改变的.*### 对象作为参数传递1. *第一个示例程序*```javapublic class test &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"Hello\"); System.out.println(\"before change: \" + sb); change(sb); System.out.println(\"after change: \" + sb); &#125; private static void change(StringBuffer stringBuffer) &#123; stringBuffer.append(\" world !\"); &#125;&#125; 程序运行结果 12before change: Helloafter change: Hello world ! 探究结论从上述程序运行结果可知sb所指的对象的值被改变了!那么我们是否就可以认为Java中的对象作为参数传递时,传递的是该对象的引用呢 ? 那我们再来看第二个示例程序. 第二个示例程序 12345678910111213141516public class test &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"Hello\"); System.out.println(\"before change: \" + sb); change(sb); System.out.println(\"after change: \" + sb); &#125; private static void change(StringBuffer stringBuffer) &#123; stringBuffer = new StringBuffer(\"Hi\"); stringBuffer.append(\" world !\"); &#125;&#125; 程序运行结果 如果上面的推论:(Java中对象作为参数传递时,实际传递的是该对象的引用)是正确的,那么在调用change函数后,原对象的值应该会被改变,既变为:Hi World !,但是,该程序的运行结果如下 !!!12before change: Helloafter change: Hello 可知原对象(sb)的值并没有被改变,这是为什么呢? 下面让我们来分析一下其中的原因吧嘿嘿 ~ 结论分析 当我们执行StringBuffer sb = new StringBuffer(&quot;Hello&quot;)时,我们便创建了一个指向新建对象new StringBuffer(&quot;Hello&quot;)的引用sb,如下所示.1sb ——————&gt; [Hello] 在第二个示例程序中,当我们调用change函数后,实际上,形参stringBuffer也指向了实参sb所指的对象! 如下所示.1sb ——————&gt; [Hello] &lt;—————— stringBuffer 那么当我们执行stringBuffer.append(&quot;world!&quot;)后,便通过对象的引用(stringBuffer)修改了对象的值,使之修改成了: Hello world !,如下所示:1sb ——————&gt; [Hello world !] &lt;—————— stringBuffer 但是在第二个示例程序中的change函数中,我们又新建了一个对象:new StringBuffer(&quot;Hi&quot;)(该操作实际上是在内存中开辟了一块在原对象地址之外的新区域),这让形参stringBuffer实际指向了这个新建的对象,并将新对象的值设置为了Hi world !,如下所示:12sb ——————&gt; [Hello]stringBuffer ——————&gt; [Hi World !] 综上所述,可以得出结论: 在Java中,当对象作为参数传递时,实际上传递的是一份&quot;引用&quot;的拷贝 ! 总结在Java中, = 不能看成一个赋值语句,因为它并不是把一个对象赋给另一个对象的过程,它的执行过程实质上是将右边对象的地址传给了左边的引用,使得左边的引用指向了右边的对象.Java表面上看起来没有指针,但它的引用实质上就是一个指针,引用里面存放的并不是对象,而是存放该对象的地址,使得该引用指向了该对象.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"VOA:One in Five Deaths Linked to Unhealthy Diet","slug":"VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet","date":"2019-04-23T01:06:07.000Z","updated":"2019-04-24T02:43:09.057Z","comments":true,"path":"2019/04/23/VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet/","link":"","permalink":"http://yoursite.com/2019/04/23/VOA-One-in-Five-Deaths-Linked-to-Unhealthy-Diet/","excerpt":"","text":"One in Five Deaths Linked to Unhealthy DietIn 2017,eleven million deaths worldwide were linked to people eating diets high in sugar,salt and processed meat. 2017年,全国范围内有1100个死亡案例与摄入含糖,含盐,加工肉制品最高的食物有关. Those foods were partly to blam for heart disease,cancer and diabetes,a new study found. 上述食物是导致心脏病,癌症,糖尿病的部分原因,这是一项新研究的发现. The study is called the Global Burden of Disease,It followed eating trends in 195 countries 1990 to 2017. The findings were reported in the publication The Lancet. 该研究名为”全国疾病负担研究”.该研究在1990-2017年间跟进了195个国家的饮食趋势.该研究的发现成果以报告的形式发布在了《柳叶刀》杂志上. Researchers considered 15 dietary elements,such as diets low in fruits,vegetables,whole grains and milk. They also looked at diets high in red meat,processed meat,sugar-sweetend drinks and sodium. 研究人员考量了15中饮食元素,比如水果,蔬菜,全谷类,牛奶含量少的食谱.研究人员还考量了红肉,加工肉制品,含糖饮料,含钠量高的食谱. The study found that Uzbekistan had the highest percentage of diet-related deaths. 该研究发现: 乌兹别斯坦因食谱而导致死亡的比例是最高的. Israel had the lowest proportion of diet-related deaths, while the United Stated reted 43rd in the study. 以色列则恰恰相反,美国则名列第43位. Consumption of foods such as nuts and seeds,milk and whole gains was on average too low,the researchers found. 研究人员发现,平均来看,坚果,种子,牛奶,全谷类的摄入太低. Chris Murrary is director of the Institute for Health Metrics and Evaluation at the University of Washington,which led the work. 克里斯·默里是华盛顿大学健康指标和评估研究所的负责人,他也是这项研究的负责人. “Poor diet is reponsible for more deaths than any other risk factor in the world,”he said. 他表示,”食谱不健康是导致死亡案例增加的罪魁祸首,比其他的风险都要致命.” The study found people are only 12 percent of the recommended amount of nuts and seeds——an average intake of 3 grams a day. For good health,experts say,you should eat 21 grams of nuts and seeds every day. 研究发现,人们摄入坚果和种子的总量只达到了推荐摄入量的12%——平均每天只有3克.多位专家表示,为了保持身体健康,每天应该摄入21克的坚果和种子类食物. The study also found that people drank more than 10 times the recommened amount of sugary drinks. 该研究还返现:含糖饮料的摄入量是推荐摄入量的10倍以上. Another study published in January suggested an “ideal diet” for the health of people and the planet would a doubling of the consumption of nuts,fruits,vegetables and legumes. Such a diet would also include reducing by half the amount of meat and sugar consumed. 一月份发布的另一个研究提出了一份”理想食谱”来保证人类的身体健康,而且全国范围内的所有人都应该加倍摄入坚果,水果,蔬菜,豆类食品.这样的健康食谱还应该包括将肉类和糖分摄入量减少一半. I’m John Russell. 重点单词 trend (n) 潮流,趋势. proportion (n) 比例. consumption (n) 摄入,消耗. factor (n) 因素. legume (n) 豆类,豆科植物. diabetes (n) 糖尿病,多尿症. percentage (n) 百分比,百分率,百分数. grain (n) 粮食,颗粒,[作物]谷物. sodium (n) [化学]钠. proportion (n) 比例,占比.部分. Consumption (n) 消费,消耗. nut (n) 坚果. director (n) 主任,主管,导演. metric (n) 度量标准. evaluation (n) 评价,[审计]评估,估价. factor (n) 因素,要素. intake (n) 摄取量,通风口. consumption (n) 消费,消耗. dietary (a) 饮食的,饭食的,规定食物的. sugary (a) 含糖的,甜的. consume (v) 消耗,消费. recommend (v) 推荐. diet-related 与饮食有关的.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"自定义EL函数防止HTML注入","slug":"自定义EL函数防止HTML注入","date":"2019-04-22T10:19:18.000Z","updated":"2019-04-22T13:02:32.602Z","comments":true,"path":"2019/04/22/自定义EL函数防止HTML注入/","link":"","permalink":"http://yoursite.com/2019/04/22/自定义EL函数防止HTML注入/","excerpt":"","text":"学习笔记 : 自定义EL函数防止HTML注入防止HTML注入前 JSP程序代码 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;`HTML`注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;form action=\"ResultServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; 姓 名: &lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 留 言: &lt;textarea rows=\"6\" cols=\"50\" name=\"message\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"submit\"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Servlet程序代码 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.el.test;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ResultServlet * @Description: 跳转页面 * @author: HuangYuhui * @date: Apr 21, 2019 3:03:53 PM * */@WebServlet(\"/ResultServlet\")public class ResultServlet extends HttpServlet &#123; private static final long serialVersionUID = 6692198599916433288L; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"UTF-8\"); String name = req.getParameter(\"username\"); String message = req.getParameter(\"message\"); req.setAttribute(\"name\", name); req.setAttribute(\"message\", message); req.getRequestDispatcher(\"result.jsp\").forward(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 所跳转的JSP页面的程序代码 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; 用户名: $&#123;name &#125;&lt;br&gt; 留言内容: $&#123;message &#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行结果示例图 JSP页面 HTML注入结果 防止HTML注入后 过滤HTML中特殊字符的程序代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package pers.huangyuhui.el.util;/** * @ClassName: HTMLFilter * @Description: 过滤特殊字符 * @author: HuangYuhui * @date: Apr 21, 2019 3:42:04 PM * */public class HTMLFilter &#123; public static String filter(String message) &#123; if (message == null) &#123; return null; &#125; // copy char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case '&lt;': result.append(\"&amp;lt;\"); break; case '&gt;': result.append(\"&amp;gt;\"); break; case '&amp;': result.append(\"&amp;amp;\"); break; case '\"': result.append(\"&amp;quot;\"); break; default: result.append(content[i]); &#125; &#125; return result.toString(); &#125;&#125; 描述自定义EL函数的mytaglib.tld文件 &lt;taglib&gt;元素是tld文件的根元素,用于声明该JSP文件使用了标签库,不需要对其进行修改,只需要从目录&lt;Tomacat安装目录&gt;\\webapps\\examples\\WEB-INF\\jsp2\\jsp2-example-taglib.tld中复制即可. 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt; &lt;uri&gt;https://yubuntu0109.github.io&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; pers.huangyuhui.el.util.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; JSP页面的程序代码 &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;%-- uri: 既tld文件中&lt;uri&gt;元素的内容. prefix: 为引用的tld文件定义一个\"代号\"(作为自定义EL函数的前缀) --%&gt; &lt;%@taglib prefix=\"demo\" uri=\"https://yubuntu0109.github.io\" %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;防止`HTML`注入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; 姓名: ${name }&lt;br&gt; 留言内容: ${demo:filter(message) } &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 运行效果示例图","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"VOA:Paris`Notre-Dame Cathedral Burning","slug":"VOA-Paris-Notre-Dame-Cathedral-Burning","date":"2019-04-22T01:26:31.000Z","updated":"2019-04-24T02:51:41.423Z","comments":true,"path":"2019/04/22/VOA-Paris-Notre-Dame-Cathedral-Burning/","link":"","permalink":"http://yoursite.com/2019/04/22/VOA-Paris-Notre-Dame-Cathedral-Burning/","excerpt":"","text":"Paris’ Notre-Dame Cathedral BurningA major fire began to burn on Monday at France’s world-famous Notre-Dame de Paris Cathedral. 周一,法国著名的巴黎圣母院大教堂发生大火. Flames could be seen rising through the top of the monument. It tall,narrow spire later collapsed. 可以看到纪念碑的顶部火焰冲天,又高又窄的尖塔随后倒塌了. The cathedral dates back to the 12th century. Frech writer Victor Hugo used it as the setting of his famous story,The Hunchback of Notre-Dame,first published in 1831. 这座大教堂可追溯到12世纪.法国作家维克多·雨果把它作为其著名小说《巴黎圣母院》的背景,该书于1831年首次出版. The capthedral is one of world’s most famous tourist sites. About 12 million people visit Notre-Dame each year. It’s sits in the center of Paris,along the Seine River. 这座大教堂是世界上最著名的旅游景点之一.每年大约有1200万人参观巴黎圣母院.它位于巴黎市中心,塞纳河沿岸. The mayor of Paris,Anne Hidalgo wrote on Twitter Monday,”A terrible fire is underway at Notre-Dame Cathedral in Paris.” Hidalgo added that Paris firefighters were still trying to contain the fire. She urged people to stay away from the area. 巴黎市长安妮·伊达尔戈周一在推特上表示:”巴黎圣母院发生可怕的火灾.” 伊达尔戈补充说,巴黎消防员仍在努力控制火势.她督促人们远离该区域. As the cathedral’s roof continued to burn. a police officer near the scene told Reuters news agency, “Everying is collapsing.“ 随着大教堂的屋顶火势不断地蔓延,一名靠近现场的警官告诉路透社,”一切都在坍塌.” French President Emmanuel Macron delayed a planned scheduled speech to the nation because of the fire. The speech was to present his answers to the yellow vest crisis that has taken over the country since November. 法国总统艾玛纽埃尔·马克龙因火灾推迟了原定的全国讲话.此次演讲是为了回应自去年11月以来席卷全国的黄背心危机. Macron arrived at the scene of the fire Monday nigth. 马克龙于周一晚上抵达火灾现场. The cause off the fire was not immediately knownn. France 2 television reported that police was treating it as accidental. 火灾发生的原因尚不清楚.法国第二电视台报道说,警方认为这是一起意外事故. Workers had been renovating parts of Notre-Dame. Parts of the monument surrounded by metal and wood support structure. The cathedral’s bronze statues had been removed last week for repairs. 此前,人工们一直在修缮巴黎圣母院的部分建筑.纪念碑的一部分被金属和木头组成的支护结构包围.大教堂的青铜雕像上周已被移走进行修复. Notre-Dame’s first stone was laid in 1163 by Pope Alexander III,It’s main spire was added during repairs in the 19th century. 巴黎圣母院的第一块基石是1163年由教皇亚历山大三世奠基的.它的主尖塔是在19世纪修缮时加上去的. 重点词汇 cathedral (n) 大教堂. flame (n) 火焰. spire (n) 尖顶,塔尖. tourist (n) 旅游者,观光者. statue (n) 雕像,塑像. Seine (n) 塞纳河(法国北部河流，流经巴黎) agency (n) 代理,中介,代理处,经销处. vest (n) 背心,汗衫. crisis (n) 危机,危险期,决定性时刻. metal (n) 金属,合金. statue (n) 雕像,塑像. mayor (n) 市长. monument (n) 纪念碑,历史遗迹,不朽的作品. accidental (a) 意外的,偶然的. narrow (a) 狭窄的,有限的. underway (a) 进行中的,起步的. bronze (a) 青铜色的,青铜制的. urged (v) 怂恿,催促. collapsed (v) 倒塌,崩溃. contain (v) 控制,容纳. continue (v) 继续,延续. collapse (v) 崩溃,塌陷. delay (v) 延期,耽搁. treat (v) 对待,处理. renovate (v) 更新,修复. 重点短语 urged to do sth : 催促做某事. news agency : 通讯社,新闻通讯社. take over : 接管,接收.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:The Woman Behind the Image of the Black Hole","slug":"VOA-The-Woman-Behind-the-Image-of-the-Black-Hole","date":"2019-04-21T13:51:03.000Z","updated":"2019-05-12T14:17:25.222Z","comments":true,"path":"2019/04/21/VOA-The-Woman-Behind-the-Image-of-the-Black-Hole/","link":"","permalink":"http://yoursite.com/2019/04/21/VOA-The-Woman-Behind-the-Image-of-the-Black-Hole/","excerpt":"","text":"The Woman Behind the Image of the Black HoleTrying to capture an image of a black hole is like trying to take a picture of an orange sitting on the surface of the moon from Earth——with your smartphone. 试图捕捉黑洞的一张图片就好比在地球上试图用智能手机去拍摄在月f球表面放着的一个橙子. That is what Dr.Katie Bouman said two years ago during her TED talk called “How to take a picture of a black hole.” 这是两年前凯蒂·布曼博士在她的TED演讲《如果拍一张黑洞的照片》中所说的话. Bouman is 29 years old. She received her doctoral degrees in computer science and enginnering from the Masschusetts Institute of Technology. She later became a postdoctoral researcher with the international Event Horizon Telescope,or EHT,project. The project scientists produced a black hole image from data collected from a series of telecopes around the world. Together,they formed an Earth-sized “virtual” telescope——on powerful enough to do what had once seemed impossible. 布曼今年29岁,她在麻省理工学院获得了计算机科学和计算机工程博士学位.后来,她成为了国际事件视界望远镜(简称EHT)项目的博士后研究院.研究该项目的科学家们从世界各地各种望远镜收集的数据中的得出了一张黑洞图像.他们一起组成了一个地球大小的虚拟望远镜,这个望远镜强大到足以让他们完成曾经看起来不可能完成的任务. This week,the team of scientists,led by Sheperd S.Doeleman of Harvard University,released to the public the first-ever image of a black hole. 本周,由哈佛大学的谢泼德S.杜勒曼领导的科学家团队向公众发布了史上第一张黑洞图片. Soon after,another image was spreading over ssocial media and the news. It’s showed a smiling Bouman with the black hole image on her computer screen. She wrote on Facebook, “Watching in disbelief as the first image I ever made of a black hole was in the process of being reconstructed.” 不久之后,另一个照片在社交媒体和新闻上传播开来.照片上布曼在微笑,她后面的电脑屏幕上是黑洞的图像.她的脸书上写到: “看着我制作的第一张黑洞图片正在重新,这简直难以置信.” Bouman led a team that helped create an algorithm,or set of computer processes that turned the huge amout of telescopic data into one image. 布曼领导者的团队帮助创建了一种算法,或一组计算机处理程序,其能将望远镜观察到的大量数据转换为一张图像. Bouman quickly became a symbol for woman in science. 布曼很快成为了科学界女性的象征. One especially pupular Twitter post showed a side-by-side picture of Bouman with hard drives of black hole image data next to another woman scientist: Margarget Hamilton. In 1969,Hamilton helped write on-board computer code for NASA’s Apollo space program. 一条特别受欢迎的推特帖子展示了一张布曼与另一位女科学家玛格丽特·汉密尔顿并列的照片,布曼的硬盘里存有黑洞图像数据.1969年,汉密尔顿为美国宇航局的阿波罗太空计划编写了随行对计算机代码. Twitter user Tammy Emma Pepin wrote of Bouman,”Here’s to more women in science——getting their credit and being remembered in history.” 推特用户塔米·艾玛·佩平这样评论布曼: “让更多的科学女性获得荣誉,并被载入史册.” And Twitter user Pooja Chandrakekar,who recently completed her studies in engineering at Harvard,wrote, “So many young girls will see Dr.Katie Bouman as an inspiration and go on to make their own discoveries in space,physis,and computer science. A historic moment not just for science,but for women in science.” 推特用户普贾·钱德拉斯卡最近最哈佛大学工程学系毕业,她写到: “很多年轻女性都因凯蒂·布曼博士而大受鼓舞,决定在太空,物理和计算机科学领域做深入研究.这不仅是科学界的历史性时刻,也是科学领域中女性的历史时刻.” But Boman herself quickly noted that she was not the only one responsible for the image off the black hole. She posted on Facebook, “No one algorithm or person made this image,it required the amazing talent of a team of scientists from around the globe and years of hard work…” 但布曼本人很快指出,她并不是黑洞图像的唯一功臣. 她在Facebook上写到: “并不是什么算法或者人制作了这幅图像.这幅图像的的问世得益于世界各地的科学家团队的惊人才能和多年的辛勤工作···” After the press event Wednesday,Bouman spoke with members of the media. She said she is looking forward to developing more algorithms and methods that will help lead to an even better,sharper image of a black hole. 周期三的新闻发布会后,布曼对媒体说,她期待着开发更多的算法和方法,以帮助生成一幅更好,更清晰的黑洞图像. Bouman will begin her teaching career at the California Institute of Technology later this year. 今天晚些时候,布曼将在加州理工学院开始地她的教学生涯. I’m Ashley Thompson. 重点词汇 symbol (n) 象征. inspiration (n) 鼓舞. talent (n) 才能. telescope (n) 望远镜. disbelief (n) 怀疑,不信. engineering (n) 工程,工程学. horizon (n) [天]地平线,视野. surface (n) 表面,表层,外观. press (n) 压,按.新闻,出版社. sharper (n) 骗子,赌棍,欺诈犯. virtual (a) 虚拟的. postdoctoral (a) 博士后的. doctoral (a) 博士的,博士学位的. historic (a) 有历史意义的,历史上著名的. reconstruct (v) 重建,改造,修复,重现. on-board 随行. side-by-side 并肩的,并行的. 重点短语 Event Horizon Telescope : 视界望远镜. released to : 发布. Brightness sharper : 亮度更清晰.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:咖啡到底好不好?研究人员也说不清","slug":"VOA-咖啡到底好不好-研究人员也说不清","date":"2019-04-19T10:45:07.000Z","updated":"2019-04-24T02:44:13.023Z","comments":true,"path":"2019/04/19/VOA-咖啡到底好不好-研究人员也说不清/","link":"","permalink":"http://yoursite.com/2019/04/19/VOA-咖啡到底好不好-研究人员也说不清/","excerpt":"","text":"Large Review of Coffee Studies Finds…Not Much NewFrom VOA Learning English,this is the Health&amp;Lifestyle report. 这里是美国之音慢速英语与健康报道. Which is more popular —— coffee or tea ?If you are on Team Coffee,you team may be ahead. 如果你站在咖啡队,那就加一分. The well-known U.S. coffee shop Starbucks just opened its largest store in the land of tea: China! 美国著名的咖啡店星巴克在茶叶之国中国开了一家最大的门店! The Shanghai Starbucks is 2,700 square meters and employs more than 400 people. 上海星巴克占地2700平方米,员工400多人. But nw for the health question: Is coffee good for us ? 但现在从健康出发,咖啡对我们有好处吗? There have been many studies on the health benefits of coffee. Recently,researchers at the University of Southampton&#39;s Faculty of Medicine in Great Britain looked at results from 201 observational coffee studies and 17 clinical trial of coffee 有很多关于咖啡对健康的益处的研究.最近,英国南安普顿大学医学院的研究人员对咖啡进行了研究,他们观察了201项观测性研究和17项临床试验的结果. With this “umbrella review“ researchers wanted to find a clear answer on whether coffee is good for us or not. 在”撒网式研究”的帮助下,研究人员想找到一个明确的答案: 咖啡对我们是否有益. They discovered that coffee drinkers had a lower risk of heart and liver disease and some cancers. Coffee drinkers also had a lower risk of dying from stroke. 它们发现和咖啡的人患心脏病,肝病和一些癌症的风险较低.喝咖啡的人死于中风的风险也较低. However,their findings are uncertain. The researchers could not prove coffee was the cause of these lowered risks. 然而,他们的发现还不确定,研究人员不能证明咖啡是降低这些风险的原因. One of the researchers of this umbrella review is Robin Poole. Poole’s team notes that their umbrella review included mainly observational data. Therefore,they could not prove any cause and effect relationship. “撒网式研究”的其中一位研究人员是罗宾·普尔.普尔的团队注意到,它们的”撒网式研究”主要是观测数据.因此他们无法证明任何因果关系. The National Institutes of Health in the United States define an “observational uncontrolled study” as a study where “researchers simply watch what happens to a series of people in one group.”,There is no control group. 根据美国国家卫生研究院的定义,”不受控制的观测性研究”指的是”研究人员仅观察一组人中一部分人的情况”的研究.这种研究没有试验控制组. Still,researchers found that the benefits of moderate coffee drinking seem to outweght the risks. Their report says drinking coffee “was more often associated with benefit than harm.” 不过,研究人员发现,适度应用咖啡的好处似乎大于风险.它们的报告指出,喝咖啡”好处多于坏处”. Poole calls these findings “Handline benefits.” 普尔称这些发现为”看得见的益处”. There are some headline benefits such as a lower risk of dying from any cause,a lower risk of dying from heart disease and stroke and lower risk of developing heart diease in the first place. 有一些看得见的益处,比如降低死亡的风险,降低死于心脏病和中风的风险,以及降低患早期心脏病的风险.对于这些结果,每天喝三到四杯咖啡就可以带来最大的好处. Poole means that if people read only the headline,they may think that the result are simply positive. But he warns that the coffee story is much more complicated. 普尔的意思是：如果人们只看表面,他们可能会认为结果是积极的.但他提醒我们,咖啡要复杂得多. He advises people to not drink more than four cups a day. And not everyone should drink so much coffee. 他建议人们每天最多和四杯咖啡,而且不是每个人都应该喝这么多. Researchers found that: Too much coffee during pregnancy can be dangerous. 研究人员发现: 怀孕期间喝太多咖啡会很危险. People,esecially woman,whose bones break easily should limit how much coffee they drink. 人们,尤其是女性,骨头容易骨折,应该限制她们饮用咖啡的量. People with abnormal heart beat patterns are advised to drink decaffeinated coffee. 心脏跳动不规律的人建议饮用无咖啡因的咖啡. In addition,the scientists point out that the research was only about coffee. Yet many coffee drinkers don’t just drink coffee. They put sugar into it. They add milk or cream. They may have a baked treat on the side. 此外,科学家们指出这项研究是关于咖啡的.然而,许多和咖啡的人并不只是喝咖啡.他们往里面放糖.他们家牛奶或奶油.他们还可能还同时吃一些烘焙食品. Researcher Robin Poole warns that to get the full health benefits of coffee,keep it simple.Drinking it black is the healthiest. And skip the pastries. 研究人员罗宾·普尔提醒我们,要想充分享受咖啡的健康益处,要尽量简单.喝黑咖啡是最健康的.糕点就放弃吧. It’s not about the sugar and the syrups and the biscuits,cakes and pastries. And we should urge people who are already drinking moderate amounts of coffee——about the three or four cups per day mark——to enjoy it,but try and make it as healthy as possible because standard health message still apply to those other things. 这本身与糖,糖浆,饼干,蛋糕和糕点无关,我们会监督那些已经喝了适量咖啡的人——大约每天喝三到四杯咖啡——可以尽情享受这些食物,但是尽量保持健康饮食,因为标准的健康饮食也同样适用于其他食物. The researchers found that the greatest benefit to drinking coffee seemed to be in fighting livers diseases. Based on that finding. They are planning a clinical test using coffee as a treatment for cirrhosis,a serious liver disease. 研究人员发现和咖啡最大的好处似乎是对抗肝脏疾病.基于这一发现,他们计划用咖啡来对肝硬化进行临床试验,肝硬化是一种严重的肝病. But the final takeaway is the same as before: if you drink coffee,keep it simple and don’t eat the pastries or other baked treats that often come with a cup of coffee. 但最终的结论还是和以前一样: 如果你和咖啡,保持简单,不要同时吃糕点或其他烘焙食品. And if you’re not coffee drinker,you don’t need to start drinking coffee to be healthier. 如果你不喝咖啡,你也不必用喝咖啡来保持健康. And that’s the Health &amp; Lifestyle report. I’m Anna Matteo. 这就是健康与生活报道,我是安娜·马特奥. The coffee versus tea argument is always interesting. Let us know In the Comments Section,which drink you prefer. 人们对咖啡和茶总是争论不休.欢迎在评论区留言.告诉我们你更喜欢咖啡还是茶. 重点单词 Starbuck (n) 星巴克(咖啡公司). trial (n) 试验,审讯,努力,磨炼. liver (n) 肝脏,生活者,居民. stroke (n) 中风. Institute (n) 学会,协会,学院. dying (n) 死,死亡. pregnancy (n) 怀孕,丰富,多产. pastry (n) 油酥点心,面粉糕饼. syrup (n) 糖浆,果汁,含药糖浆. biscuit (n) 小点心,饼干. amount (n) 数量,总额,总数. cirrhosis (n) 硬化,[内科]肝硬化. observational (a) 观测的,根据观察的. clinical (a) 临床的,诊所的. moderate (a) 稳健的,温和的,适度的,中等的,有节制的. associated (a) 关联的,联合的. complicated (a) 难懂的,复杂的. decaffeinated (a) 无因咖啡的. abnormal (ad) 反常的,不规则的,变态的. baked (v) 烤的,烘焙的. urge (v) 力劝,催促,驱策,推进. 重点短语 Southampton’s Faculty of Medicine : 南安普敦医学院 clinical trial : 临床试验,诊治试验. associated with : 与..有关系,与..相联系. amounts of : 大量的,相当数量的. final takeaway : 最终的结论.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"详解Linked list的实现方式及其应用","slug":"详解Linked-list的实现方式及其应用","date":"2019-04-19T03:54:07.000Z","updated":"2019-04-25T22:50:07.712Z","comments":true,"path":"2019/04/19/详解Linked-list的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/04/19/详解Linked-list的实现方式及其应用/","excerpt":"","text":"链表链表的定义链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的.链表由一系列结点(链表中每一个元素称为结点)组成,结点可以在运行时动态生成.每个结点包括两个部分: 一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域. 链表的使用场景 数据量较小. 不需要预先知道数据规模. 适应于频繁的插入操作. 链表的实现方式单向链表 首先定义一个链表 123456789101112131415161718192021222324252627282930package pers.huangyuhui.linkedlist;/** * @ClassName: ListNode * @Description: 单向链表 * @author: HuangYuhui * @date: Apr 15, 2019 8:59:50 PM * */public class SinglyListNode&lt;E&gt; &#123; private E data; private SinglyListNode&lt;E&gt; next;// the pointer public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public SinglyListNode&lt;E&gt; getNext() &#123; return next; &#125; public void setNext(SinglyListNode&lt;E&gt; next) &#123; this.next = next; &#125;&#125; 操作单向链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package pers.huangyuhui.linkedlist;/** * @ClassName: SinglyLinkedList * @Description: 操作单向链表 * @author: HuangYuhui * @date: Apr 15, 2019 8:54:46 PM * */public class SinglyLinkedList&lt;T&gt; &#123; SinglyListNode&lt;T&gt; headNode; public void createLinkedList() &#123; headNode = new SinglyListNode&lt;T&gt;(); // headNode.setData(0);// attention: the header node is zero default &#125; // get the header node of the linked list public T getHeaderNode() &#123; return headNode.getData(); &#125; // get the length of the linked list public int getListLength(/* ListNode headNode */) &#123; int length = 0; SinglyListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; &#125; return length; &#125; // add a new node into the linked list by specified position public SinglyListNode&lt;T&gt; insertInLinked(SinglyListNode&lt;T&gt; nodeToInsert, int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the linked list is empty !\"); return nodeToInsert; &#125; int size = getListLength(); if (position &gt; size + 1 || position &lt; 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to \" + (size + 1)); return headNode; &#125; if (position == 1) &#123; nodeToInsert.setNext(headNode); headNode = nodeToInsert; return nodeToInsert; &#125; else &#123; int count = 1; SinglyListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext();// 待插节点的前节点 count++; &#125; SinglyListNode&lt;T&gt; currentNode = previousNode.getNext();// 待插节点的后节点 nodeToInsert.setNext(currentNode); previousNode.setNext(nodeToInsert); &#125; return headNode; &#125; // delete the node by the specified position in the linked node public boolean deleteNodeFromLinkedList(/* ListNode headNode, */ int position) &#123; int size = getListLength(); if (position &gt; size || position &lt; 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to\" + (size + 1)); return false; &#125; if (position == 1) &#123; SinglyListNode&lt;T&gt; currentNode = headNode.getNext(); headNode = currentNode; return true; &#125; else &#123;// 删除中间或表尾结点 int count = 1; SinglyListNode&lt;T&gt; previousNode = headNode.getNext(); while (count &lt; position) &#123; previousNode = previousNode.getNext(); // 找到待删节点的前节点 count++; &#125; SinglyListNode&lt;T&gt; currentNode = previousNode.getNext();// 待删节点 previousNode.setNext(currentNode.getNext()); currentNode = null; &#125; return true; &#125; // delete the singly linked list public boolean destroyLinkedList(/* ListNode headNode */) &#123; if (headNode == null) &#123; System.err.println(\"Error: the singly linked list is empty !\"); return false; &#125; System.out.print(\"delete the node: \"); while (headNode != null) &#123; System.out.print(headNode.getData() + \" , \"); headNode = headNode.getNext(); &#125; System.out.println(); return true; &#125; // Iterate through all the data in the linked list public boolean traverseNode( /* ListNode headNode */) &#123; if (headNode == null) &#123; System.err.println(\"Error: the linked node is empty !\"); return false; &#125; SinglyListNode&lt;T&gt; currentNode = headNode; System.out.print(\"All of node: \"); while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" , \"); currentNode = currentNode.getNext(); &#125; System.out.println(); return true; &#125; // Test public static void main(String[] args) &#123; SinglyLinkedList&lt;String&gt; list = new SinglyLinkedList&lt;String&gt;(); // 定义待插入链表的节点 SinglyListNode&lt;String&gt; a = new SinglyListNode&lt;String&gt;(); a.setData(\"A\"); SinglyListNode&lt;String&gt; b = new SinglyListNode&lt;String&gt;(); b.setData(\"B\"); SinglyListNode&lt;String&gt; c = new SinglyListNode&lt;String&gt;(); c.setData(\"C\"); // 向单向链表中添加新的节点 list.createLinkedList(); list.insertInLinked(a, 1); list.insertInLinked(b, 2); list.insertInLinked(c, 1); System.out.println(\"The size of linked list: \" + list.getListLength()); System.out.println(\"The header node : \" + list.getHeaderNode()); list.traverseNode(); System.out.println(\"Delete the node which the position is first: \" + list.deleteNodeFromLinkedList(1)); list.traverseNode(); System.out.println(\"Delete all of node: \" + list.destroyLinkedList()); System.out.println(\"The size of linked list: \" + list.getListLength()); list.traverseNode(); &#125;&#125; 程序运行结果 123456789The size of linked list: 4The header node : CAll of node: C , A , B , null , Delete the node which the position is first: trueAll of node: A , B , null , delete the node: A , B , null , Delete all of node: trueThe size of linked list: 0Error: the linked node is empty ! 双向链表 定义链表 123456789101112131415161718192021222324252627282930313233343536373839package pers.huangyuhui.linkedlist;/** * @ClassName: BidirectionalLinkList * @Description: 双向链表 * @author: HuangYuhui * @date: Apr 16, 2019 2:31:09 PM * */public class DoubleListNode&lt;E&gt; &#123; private E data; private DoubleListNode&lt;E&gt; next;// the pointer private DoubleListNode&lt;E&gt; previous; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public DoubleListNode&lt;E&gt; getNext() &#123; return next; &#125; public void setNext(DoubleListNode&lt;E&gt; next) &#123; this.next = next; &#125; public DoubleListNode&lt;E&gt; getPrevious() &#123; return previous; &#125; public void setPrevious(DoubleListNode&lt;E&gt; previous) &#123; this.previous = previous; &#125;&#125; 操作双向链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package pers.huangyuhui.linkedlist;/** * @ClassName: CircularList * @Description: 操作循环链表 * @author: HuangYuhui * @date: Apr 16, 2019 2:28:27 PM * */public class DoubleLinkedList&lt;T&gt; &#123; DoubleListNode&lt;T&gt; headNode; // initialize the circular list public void createCircularList() &#123; headNode = new DoubleListNode&lt;T&gt;();// Attention: the header node is empty default // headNode.setData(0); &#125; // get the length of the circular list public int getLength() &#123; int length = 0; DoubleListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; &#125; return length; &#125; // get the header node of the double linked list public T getHeaderNode() &#123; if (headNode == null) &#123; System.err.println(\"Error: the double linked list is empty !\"); return null; &#125; return headNode.getData(); &#125; // add new node into the double linked list by the specified position public DoubleListNode&lt;T&gt; insertNode(DoubleListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the double linked list is empty !\"); &#125; int size = getLength(); if (position &lt; 1 || position &gt; size + 1) &#123; System.err.println(\"Position of node to insert is invalid. The vaild inputs are 1 to \" + (size + 1)); return headNode; &#125; if (position == 1) &#123; newNode.setNext(headNode); headNode.setPrevious(newNode); headNode = newNode;// 更新头结点 return headNode; &#125; else &#123; int count = 1; DoubleListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext(); count++; &#125; DoubleListNode&lt;T&gt; currentNode = previousNode.getNext();// 找到待插位置的节点 newNode.setNext(currentNode); if (currentNode != null) &#123;// 如果待插位置的节点不是尾节点 currentNode.setPrevious(newNode); &#125; previousNode.setNext(newNode); newNode.setPrevious(previousNode); &#125; return headNode; &#125; // delete node by the spcified position in the double linked list public boolean deleteNode(int position) &#123; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return false; &#125; if (position == 1) &#123; DoubleListNode&lt;T&gt; secondNode = headNode.getNext(); secondNode.setPrevious(null); headNode = secondNode;// as the header node &#125; else &#123; int count = 1; //// `previousNode`与`headNode`操作的是同一个对象哟 ! //// DoubleListNode&lt;T&gt; previousNode = headNode; while (count &lt; position - 1) &#123; previousNode = previousNode.getNext();// 待删节点的前节点 count++; &#125; DoubleListNode&lt;T&gt; currentNode = previousNode.getNext();// 待删节点 DoubleListNode&lt;T&gt; laterNode = currentNode.getNext();// 待删节点的后节点 previousNode.setNext(laterNode); if (laterNode != null) &#123; laterNode.setPrevious(previousNode); currentNode = null; &#125; &#125; return true; &#125; // Iterate through all the data in the linked list public void traverseNode() &#123; DoubleListNode&lt;T&gt; node = headNode; if (node == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (node != null) &#123; System.out.println(\"the node: \" + node.getData()); node = node.getNext(); &#125; &#125; // destroy the double linked list public void destroyList() &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); &#125; while (headNode != null) &#123; System.out.println(\"delete the node: \" + headNode.getData()); headNode = headNode.getNext(); &#125; &#125; // Test public static void main(String[] args) &#123; // CircularList&lt;Integer&gt; list = new CircularList&lt;Integer&gt;(); DoubleLinkedList&lt;Character&gt; list = new DoubleLinkedList&lt;Character&gt;(); // 初始化待插节点 DoubleListNode&lt;Character&gt; a = new DoubleListNode&lt;Character&gt;(); a.setData('a'); DoubleListNode&lt;Character&gt; b = new DoubleListNode&lt;Character&gt;(); b.setData('b'); DoubleListNode&lt;Character&gt; c = new DoubleListNode&lt;Character&gt;(); c.setData('c'); // 向双向链表中添加新节点 list.createCircularList(); list.insertNode(a, 1); list.insertNode(b, 2); list.insertNode(c, 3); System.out.println(\"-------- traverse --------\"); list.traverseNode(); System.out.println(\"--------------------------\"); System.out.println(\"The header node: \" + list.getHeaderNode()); System.out.println(\"The length of the circular list: \" + list.getLength()); System.out.println(\"Delete the node which the position is one: \" + list.deleteNode(1)); System.out.println(\"-------- traverse --------\"); list.traverseNode(); System.out.println(\"--------------------------\"); System.out.println(\"The header node: \" + list.getHeaderNode()); System.out.println(\"The length of the circular list: \" + list.getLength()); System.out.println(); list.destroyList(); System.out.println(\"The header node: \" + list.getHeaderNode()); &#125;&#125; 程序运行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-------- traverse --------the node: athe node: bthe node: cthe node: null--------------------------The header node: aThe length of the circular list: 4Delete the node which the position is one: true-------- traverse --------the node: bthe node: cthe node: null--------------------------The header node: bThe length of the circular list: 3delete the node: bdelete the node: cdelete the node: nullThe header node: nullError: the double linked list is empty !``` #### 循环链表1. *定义一个链表*```javapackage pers.huangyuhui.linkedlist;/** * @ClassName: CircularListNode * @Description: 循环链表 * @author: HuangYuhui * @date: Apr 17, 2019 9:52:23 AM * */public class ListNode&lt;T&gt; &#123; private T data; private ListNode&lt;T&gt; next; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ListNode&lt;T&gt; getNext() &#123; return next; &#125; public void setNext(ListNode&lt;T&gt; next) &#123; this.next = next; &#125;&#125; 操作循环链表的示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219package pers.huangyuhui.linkedlist;/** * @ClassName: CircularLinkedList * @Description: 操作循环链表 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 16, 2019 7:25:36 PM * */public class CircularLinkedList&lt;T&gt; &#123; // get the length of the circular linked list public int getLength(ListNode&lt;T&gt; headNode) &#123; int length = 0; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; currentNode = currentNode.getNext(); length++; if (currentNode == headNode) &#123; break; &#125; &#125; return length; &#125; // traverse the node of the circular linked list public void traverseNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode != null) &#123; System.out.print(currentNode.getData() + \" -&gt; \"); currentNode = currentNode.getNext(); if (currentNode == headNode) &#123; break; &#125; &#125; System.out.print(\"headNode(\" + currentNode.getData() + \")\\n\"); &#125; // add new node at the tail of linked list public void insertAtListTail(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; //// 注意: 由于`currentNode`无变化,导致`currentNode.getNext() != headNode`继而进入进入死循环 !//// // currentNode.setNext(currentNode.getNext()); currentNode = currentNode.getNext(); &#125; newNode.setNext(newNode); if (headNode == null) &#123; headNode = newNode; &#125; else &#123; newNode.setNext(headNode); currentNode.setNext(newNode); &#125; &#125; // add new node at the header of linked list public ListNode&lt;T&gt; insertAtListHeader(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode) &#123; ListNode&lt;T&gt; currentNode = headNode; while (currentNode.getNext() != headNode) &#123; currentNode = currentNode.getNext();// 尾节点 &#125; newNode.setNext(newNode);// 指针指向自身 if (headNode == null) &#123; headNode = newNode; &#125; newNode.setNext(headNode); currentNode.setNext(newNode); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = newNode; return headNode; &#125; // add the new node by the specified index public ListNode&lt;T&gt; insertNodeByIndex(ListNode&lt;T&gt; headNode, ListNode&lt;T&gt; newNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular list is empty !\"); return null; &#125; else if (position == 1) &#123; insertAtListHeader(headNode, newNode); &#125; else if (position == getLength(headNode)) &#123; insertAtListTail(headNode, newNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待插节点的前节点 currentNode = currentNode.getNext();// 待插节点 &#125; temp.setNext(newNode); newNode.setNext(currentNode); &#125; return headNode; &#125; // delete the last node public void deleteLastNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; temp = headNode; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); &#125; while (currentNode.getNext() != headNode) &#123; temp = currentNode; // 尾节点的前一个节点 currentNode = currentNode.getNext(); &#125; temp.setNext(headNode); currentNode = null; &#125; // delete the header node public ListNode&lt;T&gt; deleteHeaderNode(ListNode&lt;T&gt; headNode) &#123; ListNode&lt;T&gt; currentNode = headNode; if (headNode == null) &#123; System.err.println(\"Error: the circular list is empty !\"); return null; &#125; while (currentNode.getNext() != headNode) &#123; // currentNode.setNext(currentNode.getNext());//死循环 currentNode = currentNode.getNext(); &#125; currentNode.setNext(headNode.getNext()); // 注意: 此时链表头结点已更新! 所以应该返回更新后的头节点继而避免遍历时出现死循环!!! headNode = headNode.getNext(); return headNode; &#125; // delete the node by the specified index public ListNode&lt;T&gt; deleteNodeByIndex(ListNode&lt;T&gt; headNode, int position) &#123; if (headNode == null) &#123; System.out.println(\"Error: the circular linked list is empty !\"); return null; &#125; else if (position == 1) &#123; deleteHeaderNode(headNode); &#125; else if (position == getLength(headNode)) &#123; deleteLastNode(headNode); &#125; else &#123; ListNode&lt;T&gt; currentNode = headNode; ListNode&lt;T&gt; temp = headNode; for (int i = 0; i &lt; position - 1; i++) &#123; temp = currentNode;// 待删节点的前节点 currentNode = currentNode.getNext();// 待删节点 &#125; temp.setNext(currentNode.getNext()); &#125; return headNode; &#125; // Test public static void main(String[] args) &#123; // 初始化链表头结点 CircularLinkedList&lt;Integer&gt; list = new CircularLinkedList&lt;&gt;(); ListNode&lt;Integer&gt; headNode = new ListNode&lt;&gt;(); headNode.setData(1);// 初始化链表头结点 headNode.setNext(headNode);// 节点指针指向自身 // 初始化待插入的链表节点 ListNode&lt;Integer&gt; a = new ListNode&lt;&gt;(); a.setData(2); ListNode&lt;Integer&gt; b = new ListNode&lt;&gt;(); b.setData(3); ListNode&lt;Integer&gt; c = new ListNode&lt;&gt;(); c.setData(4); ListNode&lt;Integer&gt; d = new ListNode&lt;&gt;(); d.setData(100); ListNode&lt;Integer&gt; e = new ListNode&lt;&gt;(); e.setData(101); ListNode&lt;Integer&gt; f = new ListNode&lt;&gt;(); f.setData(0); // 向链表的尾部添加三个节点 System.out.print(\"the origin node: \"); list.insertAtListTail(headNode, a); list.insertAtListTail(headNode, b); list.insertAtListTail(headNode, c); list.traverseNode(headNode); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 向链表中添加两个头结点 System.out.print(\"add two header node: \"); ListNode&lt;Integer&gt; newHeadNode = list.insertAtListHeader(headNode, d); // 注意: 由于`头结点`已在`insertAtListHeader`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode2 = list.insertAtListHeader(newHeadNode, e); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 在链表的指定位置上插入新的节点 System.out.print(\"Insert the new node at position 3: \"); list.insertNodeByIndex(headNode, f, 3); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表的尾节点 System.out.print(\"delete the tail node: \"); list.deleteLastNode(newHeadNode2); list.traverseNode(newHeadNode2); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 注意: 由于`头结点`已在`deleteHeaderNode`中已更新所以要向`traverseNode`传入新的头结点 ListNode&lt;Integer&gt; newHeadNode3 = list.deleteHeaderNode(newHeadNode2); System.out.print(\"delete the header node: \"); list.traverseNode(newHeadNode3); System.out.println(\"the length of the list: \" + list.getLength(headNode)); // 删除链表中指定位置的节点 ListNode&lt;Integer&gt; newHeadNode4 = list.deleteNodeByIndex(newHeadNode3, 4); System.out.print(\"delete the fourth node: \"); list.traverseNode(newHeadNode4); System.out.println(\"the length of the list: \" + list.getLength(headNode)); &#125;&#125; 程序运行结果 123456789101112the origin node: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(1)the length of the list: 4add two header node: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 6Insert the new node at position 3: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; headNode(101)the length of the list: 7delete the tail node: 101 -&gt; 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(101)the length of the list: 6delete the header node: 100 -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 3 -&gt; headNode(100)the length of the list: 5delete the fourth node: 100 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; headNode(100)the length of the list: 4 推荐书籍 上述示例程序主要参考本书籍：《数据结构与算法经典问题解析》—— 纳拉辛哈·卡路曼希[著] 很认真的说这是我大二至今看过的最好的一本关于数据结构与算法的书籍哟 ! 其针对不同问题提供多个具有不同复杂度的解决方案.兼顾自学教材和面试辅导的不同需求呢 !","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Data Structures and Algorithms","slug":"Data-Structures-and-Algorithms","permalink":"http://yoursite.com/tags/Data-Structures-and-Algorithms/"}]},{"title":"VOA:Google`s Lookout App Helps Blind People Experience the World","slug":"VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World","date":"2019-04-18T00:12:55.000Z","updated":"2019-05-05T23:20:15.780Z","comments":true,"path":"2019/04/18/VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World/","link":"","permalink":"http://yoursite.com/2019/04/18/VOA-Google-s-Lookout-App-Helps-Blind-People-Experience-the-World/","excerpt":"","text":"谷歌推出Lookout 应用帮助盲人看世界Google has launched a new app desgined to help blind people explore their surroundings. 谷歌推出了一款新应用,旨在帮助盲人探索周围环境. The free app,called Lookout,is currently available to users in the United States who own a Google Pixel device. The company says it hopes to bring Lookout to more devices and additional countries soon. 这款名为Lookout的免费应用,目前在美国拥有Google Pixel设备的用户都可以使用.谷歌公司表示,希望尽快让更多设备和国家可以使用Lookout应用. The app was first announced at Google’s I/O developer conference in May 2018. Since then,the company says it has been testing and working to improve te quality of its results. 该应用程序于2018年5月在谷歌的I/O开发者大会上首次发布.自那以后,该公司表示一直进行测试,并努力提高其结果质量. The app uses technology similar to Google Lens. That produt uses machine learning to recognize text and objects through device’s camera. Users can then receive information about or take actions related to the text and recognized objects. 该应用程序所使用的技术与Google Lens类似,Google Lens通过设备上的相机利用机器学习技术来识别文本和物体,然后,用户可以通过接收有关文本和可识别物体的信息继而采取相应的行动. Lookout builds on this same technology,but aims to provide assistance to people who are blind or have low vision. Lookout基于同样的技术,但这款应用旨在为盲人或视力低下的人提供帮助. The app users a devices’s camera to recognize text and objects and then provide voice descriptions about what is sees. 该应用程序使用设备的摄像头来识别文本和物体,然后提供对所见内容的语音描述. Lookout is not designed to describe everything,but instead seeks to search out things that people would most likely care about. The app can learn to judge what things are most important to a person over time. Lookout应用程序并不会对所有事务进行描述,而是寻找人们最关心的事情.随着时间的推移,这个应用程序可以学会判断什么是对用户来说是最重要的事情. Google says the app operates best when the wears a device around the neck or inside a pocket,with the camera lens pointed outward. 谷歌表示,当用户将设备戴在脖子上或放入口袋里,摄像头朝外时,应用程序运行效果最好. Lookout was thress main settings for people to use. Lookout应用有三种主要模式可供人们使用. The Explore setting is designed to provide assistance for people carrying out daily activities or for identifying things in new place. A Shopping setting can capture products and help users identify their money. The Quick Read setting can help users go through their email,read signs or identify other printed materials. 探索模式旨在为人们进行日常活动或识别新地方的事物提供帮助,购物模式可以捕获产品并帮助用户识别产品价格.快速阅读模式可以帮助用户浏览邮件,读取指示牌或识别其他印刷材料. User can control parts of the app through a fingeprint sensor. For example,the sensor can be used to change operating settings or go through recent result captured by the camera. The app has three different detail levels that can be activated to provide more or less information about objects. 用户可以通过指纹传感器控制应用程序的部分功能.例如,传感器可以用来改变操作模式或查看相机最近拍到的结果.这款应用提供三种不同的信息详细程序,激活后可以提供物体或多或少的信息. There are other apps and devices designed to assist these people,too. 还有其他的应用和设备为这些人提供帮助. Microsoft’s free Seeing AI app works similary to Google Lookout. Microsoft calls its system——launched for iPhone users in 2017 -a “talking camera for the blind.”,Seeing AI can recognize text,objects and people and speaks results to users. 微软的免费Seeing AI应用程序的工作原理与谷歌的Lookout应用乐类似.微软称其于2017年为iPhone用户推出的系统为: “盲人的语音相机”.Seeing AI可以识别文本,物体和人,并向用户播报结果. Microsoft says the system can provide audio sounds that relate to current light levels around the user. A recently released version also reportedly lets uers put their fingers over a photo of something to get a sense of how the object feels. The app produces smail vibrations sounds to help this process. 微软表示,该系统可以提供与当前用户周围光线水平相关的音频.据报道,最近发布的一个版本还允许用户将手指放在物体的照片上,以感知照片中的物体.这款应用程序会产生微小的震动和声音,为这一过程提供帮助. Another free app,called Be My Eyes,connects blind or low-sight individuals with sighted volunteers through live video calls. 另一款名为: “Be My Eyes”的免费应用程序通过实时的视频通话,将盲人或视力较低的人与视力正常的志愿者联系起来. I’m Bryan Lynn. 重点单词 lens (n) 透镜,镜头,眼睛中的水晶体. material (n) 材料,原料,物资,布料. sensor (n) 传感器. vibration (n) 振动,犹豫,心灵感应. 重点短语 over time : 随着时间的过去,久而久之,加班,超时.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"VOA:Napping May Improve Learning,Memory","slug":"VOA-Napping-May-Improve-Learning-Memory","date":"2019-04-17T00:44:57.000Z","updated":"2019-04-17T15:22:04.689Z","comments":true,"path":"2019/04/17/VOA-Napping-May-Improve-Learning-Memory/","link":"","permalink":"http://yoursite.com/2019/04/17/VOA-Napping-May-Improve-Learning-Memory/","excerpt":"","text":"VOA : 午休对学习记忆有益From VOA Learning English,this is the Health &amp; Lifestyle Report. 这里是美国之音慢速英语健康和生活报道. March 16 is International Sleep Day. 3月16日是国际睡眠日. And we should all celebrate the act of sleeping. Studies have shown that a good night’s rest helps us stay healthy,both mentally and physically. And researchers say sleep is probably the best tool we have for memeory and learning. 我们大家都应该庆祝睡眠这一行为.研究表明,晚上睡得好有益身心健康,研究人员说睡眠对记忆与学习来说也许是最佳的工具. Michael Twery is director of National Center on Sleep Disorders Research at Americal’s National Institutes of Health.Twery is an expert on the sicence of sleep and sleep disorders. He told me that a good night’s sleep helps to lean better. 迈克尔·特维里是美国国立卫生研究院睡眠絮乱研究中心的负责人,他是睡眠与睡眠障碍科学方面的专家,他跟我说晚间好的睡眠有助于学习. Getting a good night’s sleep is important for the learning and memory process. It’s important because it stores the training exercises and the learning exercises into our more permanent memory while we’re sleeping 7-8 hours in bed. And then the next morning when you wake up,your mind is better prepared to act on that information. 睡个好觉对于学习和记忆来说很重要,睡眠能够更加长久地存储我们的训练与学习信息,因为当我们睡七八个小时的时候,第二天早上起来时,你的大脑可以更好地准备处理那些信息. But what about getting durig the middle of the day? Short periods of sleep my help our brains work better,or so says a recent study on mapping. 不过在中午休息会如何? 最近,一项关于睡眠的调查表明,短时间睡眠有助于大脑的运转. Past studies have shown that mapping can help babies and young children learn better And napping can help brain performance in older adults. 以前的研究表明,宝宝和儿童午休有助于学习.对于年纪稍长的成年人来说,午休能够让大脑更好地运转. Taking a nap may also help this group of people fight off age-related memory loss. 午休也许能够帮助这些年轻人应对因年龄增长带来的记忆衰退. Many Americans do nap. But one-third of all adult in the United States are also chronically tired,notes the U.S. Centers for Disease Control and Prevention(CDC). It found that 50 million to 70 million Americans have chronic sleep disorders. 许多美国人都有午休的习惯.不过,美国疾病控制和预防中心指出,三分之一的美国成年人都有慢性疲劳,有5000万到7000万的美国人患有慢性睡眠絮乱症. So,someone who naps as a way of paying off a sleep debt may not experience the same improvements from mapping as a healthy,well-rested person would. 所以,同样是午休,缺乏睡眠的人与睡眠充足的健康人士相比,效果没有那么好. Also,many people may not want to admit that they take naps. They may think that napping shows they are weak or lack energy. They only children,the very old,sick or lazy people nap is not an uncommon opinion. 很多人也不想承认他们有午休的习惯.他们也许认为午休说明自己身体很弱,没有精力.人们普遍认为,只有小孩,老人,多病的人和懒人才会午休. In fact,we Americans somethimes do a very strange thing. Some brag about how few hours of sleep they need each night. 事实上,美国人有时候会做一件非常奇怪的事,有人会吹嘘自己一晚休息的时间是如果如何得少. Health experts suggest that adults get seven to eight hours of sleep each night. People who claim they only sleep four or five hours a night,they may think thery are somehow stronger than the average human - superhuman,if you will. 健康专家建议成年人一晚睡七到八个小时.那些说自己一晚只睡四五个小时的人,他们自认为比常人更加强壮——或者说是超人. However,that may be changing. Many offices now offer napping rooms and napping cafes are appearning in many U.S. cities,including Washington,D.C. 然而,情况不同的.美国城市许多办公室都在提供午休的房间和休息咖啡室,包括华盛顿地区. While resting in the middle of the work day may seem like a luxury to Americans,napping is very much part of normal,everyday life in other parts of the world. 工作日午睡对于美国人来说也许很奢侈,但是对于全世界上其它国家与地区来说,午睡是日常生活的一部分. Take China,for example: While it depends on the age and job,China,generally speaking,is a land of nappers. 就拿中国来说吧,午睡因年龄和职业而异,中国可以说是一个”午睡之国”. So,researchers receently looked at information provided by nearly 3000 Chinese adults,aged 65 year or older. They wanted to learn if napping after a min-day meal,a tradition in many areas,had any effect on the mental performance of the subjects. 所以,近期研究人员查阅了由3000名65岁及以上的中国人所提供的信息.他们想知道午餐(许多地区的传统)是否会对身体有影响. First,the researchers asked the people if they napped and for how long. Then based on their answers,researchers put them into four groups: non-nappers(0 minutes),short nappers(less than 30 minutes),moderate nappers(30-90 minutes),and extended nappers(more than 90 minutes). 首先,研究人员问这些参与调查的人是否会午睡?睡多久?然后,根据他们的回答,把他们分为四组:不午睡的人,睡很短时间的人(少于30分钟),睡眠时间适中的人(30-90分钟),睡时间很长的人(超过90分钟). Nearly 60 percent of those 3,000 people said they did take a nap after lunch and that their naps lasted anywhere from 30 to 90 minutes. Most of the subjects who said they napped said said they napped from about an hour. 在这3000人当中,近60%说自己午饭之后会午休30到90分钟.大多数会午睡的人一般都睡一个小时左右. The study found that people who took an hour-long map did much better on mental tests than those who did not nap. The hour-long nappers also did better on the test than those who napped for shorter and longer periods. In this study,it seems that the most effective nap lasted for about an hour,but not much longer. 研究发现,午休一个小时的体能检验结果比不午休的人好.睡一个小时的人比午休时间短于一小时或长于一小时的人测验结果更好.在这次研究中,似乎最佳睡眠时长是一个小时左右,但别睡太长时间. These researchers reported their findings in Journal of the American Geriatrics Society. 这些研究人员在《美国老年学会杂志》上发布了他们的研究成果. Keep in mind,however,that these are the findings for those over the age of 65. 不过,要记住,这些研究成果是针对年龄在65岁以上的人. Yet Doctor Michael Twery notes that an hour long nap may be to long for young.healthy adults.”Currently,we’re recommending that we try to sleep for about 30 minutes or less. And 30 minutes is enough to remove the pressure to sleep and will help us feel more awake. If we nap longer,we will get trapped into those deeper layers of sleep,which can ben hard to get out of.” 不过迈克尔·特维里博士指出,对于身体健康的年轻人来说,午休一个小时或许太长了,”目前,我们建议大家睡30分钟或者更短,30分钟足够缓解睡眠压力,也会让我们更清醒.如果我们睡更长,会陷入深度睡眠,这样就很难醒过来了.” The feeling Twery described is called sleep inertia——the period when you awake from a very deep sleep. For a time.you are unable to think clearly. 特维里把这种感觉称为睡眠惯性——从深度睡眠中醒过来的那段时间.短时间之内,你无法清楚地思考. So sleep inertia is when someone is being awakened from deep sleep,Some individuals may find it hard to change instantly from that deep sleep——where everything is a bit foggy and confused to the fully awake state. We may be little bit clumsy. We may not have all our thoughts in order when we wake from deep sleep. 所以睡眠惯性就是人们从深度睡眠中醒过来,有些人会发现很难从深度睡眠中马上改变过来.或许我们有一点笨拙,从深度睡眠中醒过时来我们的思维并不是很清楚. The National Sleep Foundation also warns that if you have trouble falling asleep at night,limit your daytime nap to under 45 minutes. Also nap before 3 p.m. in the afternoon. 美国国家睡眠基金会警告称,如果晚上很难入眠,白天睡觉的时间要控制在45分钟之内,并且在下午三点之前进行午休. And that’s the Health &amp; Lifestyle report. I’m Anna Matteo. 以上就是今天的健康和生活报道,我是安娜·马泰奥. 重点词汇 luxury (n) 奢侈品. institute (n) 学会,协会,学院. disorder (n) 混乱,骚乱. expert (n) 专家,行家,能手 period (n) 周期,期间. inertia (n) 惯性,惰性,迟钝. individual (n) 个人,个体. nap (n/v) 午休. brag (v) 吹嘘. permanent (a) 永久的,永恒的,不变的. foggy (a) 有雾的,模糊的,朦胧的. mental (a) 精神的,脑力的,疯的. extended (a) 延伸的,扩大的,长期的. clumsy (a) 笨拙的. chronic (a) 慢性的. lazy (a) 懒的. mentally (ad) 精神上,智力上,心理上. chronically (ad) 长期地,慢性地,习惯性地. age-relate 年龄相关,与年龄相关. well-rested 休息充分的. 重点短语 fight off : 击退,排斥,竭力避免. be confused to : 迷惑,被混淆了.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"一款瞄准大学生的交友软件:TinderU","slug":"一款瞄准大学生的交友软件-TinderU","date":"2019-04-16T00:50:23.000Z","updated":"2019-04-16T11:11:40.413Z","comments":true,"path":"2019/04/16/一款瞄准大学生的交友软件-TinderU/","link":"","permalink":"http://yoursite.com/2019/04/16/一款瞄准大学生的交友软件-TinderU/","excerpt":"","text":"TinderU App Amins to Help College Student Find Frends,Partner —— August 26, 2018It is back-to-school season in the United States,Mang youg adults are headed to colloges and universities. 有又到了美国开学季.不少年轻人就要踏进大学校园. A new app might make their social lives as busy as their academic schedules. 一款新应用可能会让他们的社交生活和学业日程一样繁忙. The popular dating app Tinder has just launched TinderU.The tool is designed to help students find friends,study partners and, possibly, love. 热门约会应用Tinder刚刚推出了TinderU.该工具旨在帮助学生找出友谊,学习伙伴,还有爱情哟 ~(怎么感觉我好需要呀..) On TinderU,users can look at pictures and information about other students at their university and other schools nearby.Just like on Tinder,if you see somebody you think you might like,you swipe right to “match” with that person,If you are not interested,you swipe left to pass. 在TinderU上,用户可以看到本科生及周边学校学生的照片和信息.如同Tinder一样,如果你看到了自己可能感兴趣的人,就可以在屏幕上右滑,和对方”配对”.如果你不感兴趣就向左滑. Only college students attending four-year schools can use TinderU.Online and for-profit colleges and universities are not included at this time,All that TinderU requires of users is a .edu email address. 目前,只有就读于四年制大学的在校学生才可以使用TinderU,在线和盈利性学院的学生不包含在内.TinderU仅需要用户提供一个.edu邮箱地址就可以啦. Tinder launched in 2012 in Los Angeles,California. It’s widely used around the world.The app is especially popular among people aged 18 to 34. Tinder于2012年在加州洛杉矶推出,此后,在全世界得到了广泛应用.这款软件在18岁到34岁的人群中特别流行. Some people argue TinderU will destroy traditional socializing on college campuses.And they say student don’t need the app because they meet other students face-to-face each day. 一些人认为TinderU会破坏大学校园里的传统社交活动.他们认为学生们不需要这个应用程序,因为他们每天都要和其他学生面对面. But the experience of starting college can be overwhelming for some.Mang students become independent for the first time in th their lives when they go to college.They often do not know a single person in that new environment.Tinder supporters say the app can help users find like-minded people to talk and, maybe, ask out on a date. 然而,上大学的经历对一些人来说可能是难以承受的.因为对于许多学生而言,人生的第一次独立是从踏进学生生活的那一刻开始的.在那种新环境中,他们往往一个人也不认识.Tinder的支持者说:,这款应用可以帮助用户找到志同道合的朋友,他们可以一起聊天,还可以出去约会. The Tinder website says Tinder is in 190 countries,It averages 1.6 billion matches a day and reponsible for one million dates each week. I’m Caty Weaver. 重点词汇 schedule (n) 时间表. swipe (v) 滑动屏幕. match (v) 匹配. argue (v) 辩论,争论.证明,说服. overwhelming (adj) 压倒性的. for-profit (adj) 以盈利为目的,营利性,经营性 . (n) 营利性的机构 like-minded (adj) 志趣相投的,具有相似意向或目的. 重点短语 be headed to : 前往.","categories":[],"tags":[{"name":"VOA","slug":"VOA","permalink":"http://yoursite.com/tags/VOA/"}]},{"title":"Naming Notations","slug":"Naming-Notations","date":"2019-04-15T08:13:07.000Z","updated":"2019-04-15T08:56:48.688Z","comments":true,"path":"2019/04/15/Naming-Notations/","link":"","permalink":"http://yoursite.com/2019/04/15/Naming-Notations/","excerpt":"","text":"Java 命名规范Java总体命名规范 项目名全部小写. 包名全部小写. 类名首字母大写,其余组成词首字母依次大写. 变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写. 常量名全部大写. 所有命名规则必须遵循以下规则 : 名称只能由字母、数字、下划线、$符号组成. 不能以数字开头. 名称不能使用Java中的关键字. 坚决不允许出现中文及拼音命名. Java包名命名规范 Java的包名由小写单词组成,包的路径符合所开发的系统模块的定义,以便通过包名可得知其属于哪个模块,从而方便到对应包里找相应的实现类. 常规包名为了保障每个Java Package命名的唯一性,在Java编程规范中要求开发人员在自己定义的包名前加上唯一的前缀.由于互联网上的域名称是不会重复的,所以多数开发人员采用自己公司在互联网上的域名称作为自己程序包的唯一前缀.例如 : com.sun.swt... 公司项目 com : 公司项目,copyright由项目发起的公司所有. 包名 : com.公司名.项目名.模块名.. 团队项目 team : 团队项目,指由团队发起,并由该团队开发的项目,copyright属于该团队所有. 包名 : team.团队名.项目名.模块名.. 自定义包名一般公司命名为com.公司名.项目名.模块名....那我们个人的项目又怎么命名呢? 个人的英语单词有individual、personal、private、one-man,进一步对以上四个单词词意进行分析并在保证了唯一性,继而使用每个单词的前4个字母作为前缀,与com也做了区分.示例如下所示: indi : 个体项目,指个人发起,但非自己独自完成的项目,可公开或私有项目,copyright主要属于发起者. 包名 : indi.发起者名.项目名.模块名.. pers : 个人项目,指个人发起,独自完成,可分享的项目,copyright主要属于个人. 包名 : pers.个人名.项目名.模块名.. priv : 私有项目,指个人发起,独自完成,非公开的私人使用的项目,copyright属于个人. 包名 : priv.个人名.项目名.模块名.. onem : 与indi相同，推荐使用indi.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java reflection","slug":"Java-reflection","date":"2019-04-15T00:39:07.000Z","updated":"2019-04-19T02:16:02.199Z","comments":true,"path":"2019/04/15/Java-reflection/","link":"","permalink":"http://yoursite.com/2019/04/15/Java-reflection/","excerpt":"","text":"Java Reflection概念Reflection(反射)是被认为动态语言的关键,反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息,并能直接操作任意对象的内部属性及方法. 应用动态代理 反射机制提供的功能 在运行时判断任意一个对象所属的类. 在运行时构造人任意一个类的对象. 在运行时判断任意一个类所具有的成员变量和方法. 在运行时调用任意一个对象的成员变量和方法. 生成动态代理(体现动态语言的特性). 反射相关的主要API java.lang.Class : 代表一个类. java.lang.reflect.Method : 代表类的方法. java.lang.reflect.Field : 代表类的成员变量. java.lang.reflect.Constructor : 代表类的构造方法. … 反射的简单应用示例 首先创建一个存储用户信息的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package pers.huangyuhui.reflection.bean;/** * @ClassName: UserInfo * @Description: 用户信息 * @author: HuangYuhui * @date: Apr 15, 2019 9:03:40 AM * */public class UserInfo &#123; public String name; private String sex; private int age; public UserInfo() &#123; super(); &#125; public UserInfo(String name, String sex, int age) &#123; super(); this.name = name; this.sex = sex; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"UserInfo [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\"; &#125; public void showClassInfo() &#123; System.out.println(\"ClassInfo: Store the user information .\"); &#125; public void introduce(String s) &#123; System.out.println(s + \" my name is: \" + name + \" age: \" + age + \" sex: \" + sex); &#125;&#125; 其次利用反射获取该类中的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package pers.huangyuhui.reflection.bean.test;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import org.junit.Ignore;import org.junit.jupiter.api.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: UserInfoTest * @Description: 用`反射`获取`UserInfo`类中信息 * @author: HuangYuhui * @date: Apr 15, 2019 9:10:08 AM * */public class TestUseInfoByReflection &#123; // 不使用反射 : 创建`UserInfo`类对象,并调用其中的属性及方法 // @Test @Ignore public void commonTest() &#123; UserInfo userInfo = new UserInfo(); userInfo.setName(\"Java reflection\"); userInfo.setAge(1); userInfo.setSex(\"Male\"); userInfo.showClassInfo(); userInfo.introduce(\"Hello !\"); &#125; // 使用反射: 创建`UserInfo`类对象,并调用其中的属性及方法 @Test public void reflectionTest() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException &#123; // 下述两行代码体现了: `UserInfo userInfo = new UserInfo();`的工作 Class&lt;UserInfo&gt; class1 = UserInfo.class; // 创建运行时类`UserInfo`类的对象 UserInfo userInfo = class1.newInstance(); System.out.println(userInfo); /* * 通过`getField`调用别`public`修饰的`name`属性并为其赋值 */ java.lang.reflect.Field fieldName = class1.getField(\"name\");// `name`被`public`修饰,否则抛出: NoSuchFieldException fieldName.set(userInfo, \"Java reflection\"); System.out.println(userInfo); /* * 通过`getField`调用被`private`修饰的`age,sex`属性并为其赋值 */ Field fieldAge = class1.getDeclaredField(\"age\"); Field fieldSex = class1.getDeclaredField(\"sex\"); // 将此对象的 accessible 标志设置为指示的布尔值.值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查. // 值为 false 则指示反射的对象应该实施 Java 语言访问检查.实际上setAccessible是启用和禁用访问安全检查的开关, // 并不是为true就能访问为false就不能访问 ! false时使用对象会抛出 : IllegalAccessException . // 由于JDK的安全检查耗时较多,所以通过`setAccessible(true)`的方式关闭安全检查就可以达到提升反射速度的目的 . fieldAge.setAccessible(true); fieldSex.setAccessible(true); fieldAge.set(userInfo, 2); fieldSex.set(userInfo, \"male\"); System.out.println(userInfo); /* * 通过``调用对象指定的方法 */ java.lang.reflect.Method method = class1.getMethod(\"showClassInfo\"); // return: the result of dispatching the method represented bythis object on obj // with parameters args. method.invoke(userInfo); Method method2 = class1.getMethod(\"introduce\", String.class); method2.invoke(userInfo, \"Hello !\"); &#125;&#125; 程序运行结果如下 12345UserInfo [name=null, sex=null, age=0]UserInfo [name=Java reflection, sex=null, age=0]UserInfo [name=Java reflection, sex=male, age=2]ClassInfo: Store the user information .Hello ! my name is: Java reflection age: 2 sex: male 详解反射的源头 : Class在Object类中定义了以下的方法,此方法被所有子类继承 :12@HotSpotIntrinsicCandidate public final native Class&lt;?&gt; getClass(); 该返回值的类型是一个Class类,此类是Java反射的源头,实际上所谓的反射从程序的运行结果来看也也很理解,既: 可以通过对象反射求出类的名称. 正常方式 : 引入需要的包类名称 ——&gt; 通过new实例化 ——&gt; 取得实例化对象 反射方式 : 实例化对象 ——&gt; getClass() ——&gt; 得到完整的包类名称 getClass()的使用 示例程序如下 123456789101112131415161718192021222324package pers.huangyuhui.reflection.bean.test;import org.junit.jupiter.api.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: TestUserInfoByReflection2 * @Description: 学习反射源头: `Class`类 * @author: HuangYuhui * @date: Apr 15, 2019 11:58:34 AM * */public class TestUserInfoByReflection2 &#123; @Test public void getClassTest() &#123; UserInfo userInfo = new UserInfo(); // getClass() return: The Class object that represents the runtimeclass of this object. // 通过`运行时类`的对象,调用其`getClass()`返回其运行时类 Class&lt;?&gt; class1 = userInfo.getClass(); System.out.println(class1); &#125;&#125; 程序运行结果如下 1class pers.huangyuhui.reflection.bean.UserInfo //`运行时`类 运行时类 : example.java ——编译器(javac.exe)——&gt; example.class ——JVM类加载器——&gt; example.class被加载到内存(此时example.class就是一个运行时类,存放在缓存区,且运行时类本身就是一个Class实例并只加载一次 !) 获取Class类的实例的四种方式获取Class类的实例后我们可以进行如下的操作: 创建对应的运行时类的对象. 调用对应的运行时类的完整结构( 属性,方法,构造器 ). 获取对应的运行时类的完整结构( 属性,方法,构造器,父类,所在的包,异常,注解… ). 获取Class类实例的四种方式的示例程序如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package pers.huangyuhui.reflection.bean.test;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: GetClassObj * @Description: 获取`Class`类实例的四种方式 * @author: HuangYuhui * @date: Apr 15, 2019 12:34:21 PM * */public class GetClassObj &#123; // @Test // 第一种方式: 通过调用运行时类本身的`.class`属性 public void firstWayTest() &#123; Class&lt;UserInfo&gt; class1 = UserInfo.class; Class&lt;String&gt; class2 = String.class; // the result: class pers.huangyuhui.reflection.bean.UserInfo System.out.println(class1); // the result: class java.lang.String System.out.println(class2); &#125; // @Test // 第二种方式: 通过`运行时类`的对象获取 public void secondWayTest() &#123; UserInfo userInfo = new UserInfo(); Class&lt;? extends UserInfo&gt; class1 = userInfo.getClass(); // getName() return: the name of the class or interfacerepresented by this object. // the result: pers.huangyuhui.reflection.bean.UserInfo System.out.println(class1.getName()); &#125; // @Test // 第三种方式: 通过`Class`的静态方法获取 public void thirdWayTest() throws ClassNotFoundException, NoSuchMethodException, SecurityException, NoSuchFieldException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; Class&lt;?&gt; class1 = Class.forName(className); // the result: public java.lang.String // pers.huangyuhui.reflection.bean.UserInfo.name System.out.println(class1.getField(\"name\")); &#125; @Test // 第四种方式: 通过类加载器获取 public void fourthWayTest() throws ClassNotFoundException, NoSuchMethodException, SecurityException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; ClassLoader classLoader = this.getClass().getClassLoader(); // Invoking this method is equivalentto invoking loadClass(name,false). Class&lt;?&gt; class1 = classLoader.loadClass(className); // the result: public void pers.huangyuhui.reflection.bean.UserInfo.introduce(java.lang.String) System.out.println(class1.getMethod(\"introduce\", String.class)); &#125;&#125; 类加载器ClassLoader概念类加载器的作用:把类(class)装载进内存.如下示例1Java源文件(*.java) ——Java编译器——&gt; 字节码文件(*.class) ——类加载器+字节码效验器+解释器——&gt; 操作系统平台 JVM规范定义了两种类型的类加载器:启动类加载器(bootstrap)和用户自定义加载器(user-defined class loader).JVM在运行时会产生三个类加载器 引导类加载器. JVM自带的类加载器,负责Java平台核心库,用来加载核心类库,该加载器无法直接获取. 扩展类加载器. 负责jar包或将指定目录下的jar包装入工作库. 系统类加载器. 负责java-classpath或java.class.path所指的目录下的类与jar包装入工作.(最常用) 三个类加载器的示例程序如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.reflection.classloader;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: ClassLoader * @Description: 类加载器`Classloader` * @author: HuangYuhui * @date: Apr 15, 2019 5:37:30 PM * */public class TestClassLoader &#123; @Test public void systemClassLoaderTest() throws ClassNotFoundException &#123; /* * 获取`系统类加载器` */ ClassLoader classLoader = ClassLoader.getSystemClassLoader(); // getName() Returns: name of this class loader,or null if this class loader is // not named. // the result: jdk.internal.loader.ClassLoaders$AppClassLoader@28c97a5 System.out.println(classLoader); /* * 获取`系统类加载器`的父类加载器(`平台类加载器: getPlatformClassLoader`) */ ClassLoader classLoader2 = classLoader.getParent(); // the result: jdk.internal.loader.ClassLoaders$PlatformClassLoader@7bedc48a System.out.println(classLoader2); /* * 查看自定义类`UserInfo`由哪个加载器加载 */ Class&lt;UserInfo&gt; class1 = UserInfo.class; ClassLoader classLoader3 = class1.getClassLoader(); // the result: jdk.internal.loader.ClassLoaders$AppClassLoader@28c97a5 // 由运行结果可知,该自定义类被`系统加载器`加载 System.out.println(classLoader3); /* * 查看`java.lang.Object`(核心类库)由哪一个加载器加载 */ Class&lt;?&gt; class2 = Class.forName(\"java.lang.Object\"); ClassLoader classLoader4 = class2.getClassLoader(); // the result: null // 运行结果为`null`,说明该类被`引导类加载器`加载 ! // `引导类加载器`: `JVM`自带的类加载器,负责Java平台核心库,用来加载核心类库,该加载器无法直接获取 System.out.println(classLoader4); &#125;&#125; 类的加载过程当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通知如下三个步骤来对该类进行初始化. 类的加载 : 将类的Class文件读入到内存,并为之创建一个java.lang.Class对象,此过程由类加载器完成. 类的链接 : 将类的二进制数据合并到JRE中. 类的初始化 : JVM负责对类进行初始化. 类加载器的应用 利用ClassLoader读取指定包下的配置文件(如果不使用类加载器配置文件只能放在项目目录下..).程序示例如下 : 1234567891011121314151617181920212223242526272829303132333435363738package pers.huangyuhui.reflection.classloader;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;/** * @ClassName: ReadConfigFileInfo * @Description: 利用`ClassLoad` * @author: HuangYuhui * @date: Apr 15, 2019 6:29:39 PM * */public class ReadConfigFileInfo &#123; @Test public void classLoaderTest() throws IOException &#123; Properties properties = new Properties(); // 如果不使用`ClassLoader`,读取当前工程下的配置文件的方式如下: // FileInputStream fileInputStream = new FileInputStream(new File(\"user.properties\")); ClassLoader classLoader = this.getClass().getClassLoader(); // return: An input stream for reading the resource. InputStream inputStream = classLoader .getResourceAsStream(\"pers\\\\huangyuhui\\\\reflection\\\\classloader\\\\user.properties\"); // Reads a property list (key and element pairs) from the inputbyte stream. properties.load(inputStream); System.out.println(\"singer: \" + properties.getProperty(\"singer\") + \"\\nsong: \" + properties.getProperty(\"song\")); &#125;&#125; 在pers.huangyuhui.reflection.classloader包下创建配置文件user.properties 12singer=Justin Biebersong=Love yourself 程序运行结果如下 12singer: Justin Biebersong: Love yourself newInstance()创建运行时类的对象条件创建类的对象: 调用Class对象的newInstance()方法,要求如下： 类必须有一个无参数的构造器. 类的构造器的访问权限需要足够. 示例程序123456789101112131415161718192021222324252627282930package pers.huangyuhui.reflection.newinstance;import org.junit.Test;import pers.huangyuhui.reflection.bean.UserInfo;/** * @ClassName: NewInstanceTest * @Description: 使用`newInstance()`创建运行时类的对象 * @author: HuangYuhui * @date: Apr 16, 2019 10:08:37 PM * */public class NewInstanceTest &#123; @Test public void test() throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; String className = \"pers.huangyuhui.reflection.bean.UserInfo\"; Class&lt;?&gt; class1 = Class.forName(className); @SuppressWarnings(\"deprecation\") // 使用`newInstance()`创建对应的运行时类的对象时实际上是调用了运行时类的空参构造器. UserInfo userInfo = (UserInfo) class1.newInstance(); // the result: UserInfo [name=null, sex=null, age=0] System.out.println(userInfo); &#125;&#125; 通过反射调用类的完整结构 获取属性 略 获取方法 略 获取构造器 略 反射的应用之动态代理动态代理介绍 概念动态代理是指客户通过代理类来调用其它对象的方法,并且是在程序运行时根据需要动态创建目标类的代理对象. 使用场合调试及远程方法调用等.. 设计模式的原理使用一个代理将对象包装起来,然后使用该代理对象取代原始对象.任何对原始对象的调用都要通过代理.代理对象决定是否以及何时将方法调用转到原始对象上. 静态代理程序示例为了与动态代理相比较,静态代理程序示例如下.不难发现: 如果添加不同接口则需要不同的代理类来完成其代理!很繁琐!!12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package pers.huangyuhui.reflection.proxy;interface ClothFactory &#123; void createCloth();&#125;//被代理类class NikeClothFactory implements ClothFactory &#123; @Override public void createCloth() &#123; System.out.println(\"Create the cloth ..\"); &#125;&#125;//代理类class ProxyFactory implements ClothFactory &#123; NikeClothFactory nikeClothFactory; public ProxyFactory(NikeClothFactory nike) &#123; this.nikeClothFactory = nike; &#125; @Override public void createCloth() &#123; System.out.println(\"This is static proxy ..\"); nikeClothFactory.createCloth(); &#125;&#125;/** * @ClassName: StaticProxy * @Description: 静态代理 * @author: HuangYuhui * @date: Apr 18, 2019 10:31:27 AM * */public class StaticProxy &#123; public static void main(String[] args) &#123; NikeClothFactory nikeClothFactory = new NikeClothFactory(); ProxyFactory proxyFactory = new ProxyFactory(nikeClothFactory); proxyFactory.createCloth(); //程序运行结果如下所示 : // This is static proxy .. // Create the cloth .. &#125;&#125; 动态代理程序示例 反射是动态语言的关键,程序示例如下 :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package pers.huangyuhui.reflection.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;interface Subjet &#123; void action();&#125;//被代理类class RealSubject implements Subjet &#123; @Override public void action() &#123; System.out.println(\"被代理类执行的动作 ..\"); &#125;&#125;//实现动态代理的核心类class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 给被代理的对象实例化 public Object dynamicInit(Object object) &#123; this.obj = object; // `动态`地创建指定代理类的对象并返回 return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; @Override // 当通过代理类的对象发起对被重写的方法调用时,都会转换为对如下`invoke`方法的调用 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object object = method.invoke(obj, args); return object; &#125;&#125;/** * @ClassName: DynamicProxy * @Description: 动态代理 * @author: HuangYuhui * @date: Apr 18, 2019 11:03:54 AM * */public class DynamicProxy &#123; public static void main(String[] args) &#123; MyInvocationHandler myInvocationHandler = new MyInvocationHandler(); RealSubject realSubject = new RealSubject(); // `dynamicInit`方法动态的返回一个同样实现了 `Real ...`所在类实现的接口`Subject`的代理类的对象 Object object = myInvocationHandler.dynamicInit(realSubject); // 此时`subject`为代理类的对象 Subjet subjet = (Subjet) object; // 调用`action`时会转到对`InvocationHandler`接口的实现类的`invoke`方法的调用 subjet.action(); // 为证明动态代理的特性,再实现一个接口的代理类的对象 NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory clothFactory = (ClothFactory) myInvocationHandler.dynamicInit(nikeClothFactory); clothFactory.createCloth(); //程序运行结果如下所示 : //被代理类执行的动作 .. //Create the cloth .. &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java annotation","slug":"Java-annotation","date":"2019-04-14T01:43:16.000Z","updated":"2019-04-14T14:54:41.226Z","comments":true,"path":"2019/04/14/Java-annotation/","link":"","permalink":"http://yoursite.com/2019/04/14/Java-annotation/","excerpt":"","text":"Java注解 (元数据)注解的概念及作用 从JDK1.5开始,Java支持在源文件中嵌入补充信息,这类信息被称为注解(annotation).注解不会改变程序的动作,因此也就不会改变程序的语义,但是在开发和部署期间,各种工具可以使用这类信息,例如: 源代码生成器可以处理注解! 注: 如果没有注解信息处理流程(如:通过反射查询注解),则注解毫无意义 ! 说明: 其实术语元数据(metadata),但是注解这个名称更具有描述性并且更常用. 声明注解 注解是一种代码级别的说明.它与类,接口,枚举在同一个层次,它可以声明在包,类,字段,方法,局部变量,方法参数等的前面,用来对这些元素进行说明,注释.. 注解的分类 特殊的注解 : 标记注解,单成员注解. 内置注解. 类型注解. 重复注解. 内置注解内置注解分类 java.lang.annotation包下的注解分别是 : @Retention,@Documnetd,@Target,@Inherited 以上四个注解被称为元注解,其作用是负责注解其它的注解,用来提供对其它annotation类型做说明. java.lang包下注解分别是 : @Override,@Deprecated,@FunctionalInterface,@SafeVarargs,@SuppressWarnings 注意: JDK8在java.lang.annotation中添加了Repeatable和Native注解.其中Repeatable支持重复注解,Native用于注解本机代码可以访问的域变量. 内置注解 : 非元注解 @SuppressWarnings注解使用详解如下图所示 @Override,@Deprecated,@SafeVarargs,SuppressWarnings程序示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package pers.huangyuhui.annotation.built_in_annotation;import java.util.ArrayList;/** * @ClassName: Built_in_annotations * @Description: 非元注解 * @author: HuangYuhui * @date: Apr 14, 2019 9:36:20 AM * */public class Built_in_annotations&lt;T&gt; &#123; @SuppressWarnings(\"unused\") private T[] args; // Type safety: Potential heap pollution via varargs parameter args.. // @SafeVarargs: 为标记注解,只能用于方法和构造方法,指示没有发生与可变长度参数相关的不安全动作. @SafeVarargs public Built_in_annotations(T... args) &#123; this.args = args; &#125; // @SafeVarargs: 该注解只能用于varargs方法或者声明为static或final的构造方法. @SafeVarargs public final void safeVarargsTest(T... args) &#123; for (@SuppressWarnings(\"unused\") T t : args) &#123; System.out.println(args); &#125; &#125; // @Override: 用于确保超类方法被真正地重写,而不是简单地重载. @Override public String toString() &#123; return super.toString(); &#125; // @Deprecated: 为标记注解,用于指示声明是过时的,并且已经被更新到的形式取代. @Deprecated public void deprecatedTest() &#123; &#125; // @SuppressWarnings: 用于抑制一个或多个编译器可能会报告的警告.使用以字符串形式表示的名称来指定要被抑制的警告. @SuppressWarnings(\"rawtypes\") public void supressWarningsTest() &#123; @SuppressWarnings(\"unused\") ArrayList arrayList = new ArrayList&lt;&gt;(); &#125;&#125; @FunctionalInterface程序示例 12345678910111213141516171819202122232425262728293031323334353637383940/** * @ClassName: functionalInterface * @Description: `学习@functionalInterface注解` * @author: HuangYuhui * @date: Apr 14, 2019 10:39:46 AM * *///`Java8`为函数式接口引入了一个新注解`@FunctionalInterface`,其主要用于编译错误检查,//加上该注释后当你写的接口不符合函数式定义时,编译器就会报错 !//注意: 是否添加`@FunctionalInterface`对于接口是不是函数式接口没有影响,//该注释只是提醒`编译器`去检查该接口是否仅仅包含一个抽象方法.@FunctionalInterfaceinterface functionalInterface &#123; // 注意: 函数式接口中只能有一个抽象方法 ! void myLambda(String message); // 函数式接口里是可以包含默认方法,因为默认方法不是抽象方法,其有一个默认实现, //所以是符合函数式接口的定义的. default void defaultMethod() &#123; // method body.. &#125; // 函数式接口里是可以包含静态方法,因为静态方法不能是抽象方法,是一个已经实现了的方法, //所以是符合函数式接口的定义的. static void staticMethod() &#123; // method body.. &#125; // 函数式接口里是可以包含Object里的public方法,这些方法对于函数式接口来说, // 不被当成是抽象方法(虽然它们是抽象方法).因为任何一个函数式接口的实现,默认都继承了Object类, //其包含了来自java.lang.Object里对这些抽象方法的实现! @Override boolean equals(Object object);&#125;//使用`@FunctionalInterface`注解的函数式接口继而可以使用`Lambda`表示式来表示该接口的一个实现.//(Java8 之前一般是使用匿名类实现的).//functionalInterface f = message-&gt;System.out.println(); 内置注解 : 元注解 使用@Target,@Retention自定义注解 12345678910111213141516171819202122232425import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @ClassName: MyTarget_annotation * @Description: 自定义注解 * @author: HuangYuhui * @date: Apr 14, 2019 11:12:54 AM * */@Target(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.CONSTRUCTOR &#125;)//用于指定可以应用注解的声明类型,被设计为只能注解其它注解.@Retention(RetentionPolicy.CLASS)//指定保留策略.public @interface MyTarget_annotation &#123; int id() default -1; //使用默认值 String name(); String[] address() default &#123; \"null\" &#125;;&#125; 使用自定义注解 123456789101112131415161718192021222324252627282930313233import pers.huangyuhui.annotation.myannotation.MyTarget_annotation;/** * @ClassName: TargetTest * @Description: 使用自定义注解 * @author: HuangYuhui * @date: Apr 14, 2019 11:38:23 AM * */@MyTarget_annotation(name = \"\")public class TargetTest &#123; // 由于声明的注解类型包含 : `CONSTRUCTOR`, 所以可以在构造方法前使用. @MyTarget_annotation(name = \"\") public TargetTest() &#123; // TODO Auto-generated constructor stub &#125; // 由于声明的注解类型包含 : `FIELD`, 所以可以在域变量前使用. @MyTarget_annotation(name = \"\") private String s; // 由于声明的注解类型包含 : `METHOD`, 所以可以在方法前使用. @MyTarget_annotation(id = 1, name = \"YUbuntu0109\", address = \"my address\") // 显式的定义注解值 public void testMethod() &#123; // 由于声明的注解类型包含 : `LOCAL_VARIABLE`, 所以可以在局部变量前使用. @SuppressWarnings(\"unused\") @MyTarget_annotation(name = \"\") int i; &#125;&#125; 使用反射获取注解 通过反射获取方法关联的注解 首先自定义一个注解 12345678910111213141516171819202122package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @ClassName: MyAnnotation * @Description: 自定义注解,用于通过反射获取注解信息的测试 * @author: HuangYuhui * @date: Apr 14, 2019 5:52:05 PM * */@Retention(RetentionPolicy.RUNTIME)//指定保留策略@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)public @interface MyAnnotation &#123; int id() default 1; String name() default \"default value\";&#125; 通过反射获取自定义注解信息 12345678910111213141516171819202122232425262728293031323334353637import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;/** * @ClassName: getAnnotationInfo * @Description: 通过反射获取方法关联的注解 * @author: HuangYuhui * @date: Apr 14, 2019 5:45:32 PM * */public class getAnnotationInfo &#123; @MyAnnotation(name = \"Hello annotation !\") public void fun(double d, String s) &#123; &#125; public static void main(String[] args) &#123; getAnnotationInfo getInfo = new getAnnotationInfo(); // 获取Class对象 Class&lt;?&gt; class1 = getInfo.getClass(); try &#123; // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息 Method method = class1.getMethod(\"fun\", double.class, String.class); // 通过调用`getAnnotation`获取与对象相关联的特定注解 MyAnnotation annotatioin = method.getAnnotation(MyAnnotation.class); System.out.println(\"id : \" + annotatioin.id() + \"\\nname : \" + annotatioin.name()); &#125; catch (NoSuchMethodException | SecurityException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序运行结果如下 12id : 1 name : Hello annotation ! 通过反射获取所有注解 首先自定义一个注解 1234567891011121314151617package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyAnnotation2 * @Description: 自定义注解,用于反射获取注解信息的测试 * @author: HuangYuhui * @date: Apr 14, 2019 6:09:15 PM * */@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation2 &#123; String description();&#125; 通过反射获取自定义注解信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package pers.huangyuhui.annotation.reflect;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;import pers.huangyuhui.annotation.myannotation.MyAnnotation2;/** * @ClassName: getAllAnnotationInfo * @Description: 通过反射机制获取所有注解 * @author: HuangYuhui * @date: Apr 14, 2019 6:10:29 PM * */@MyAnnotation()@MyAnnotation2(description = \"Test class\")public class getAllAnnotationInfo &#123; @MyAnnotation(id = 1, name = \"Hello annotation !\") @MyAnnotation2(description = \"Test method\") public void fun() &#123; &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException &#123; getAllAnnotationInfo allAnnotationInfo = new getAllAnnotationInfo(); // 通过`getAnnoations`获取该类所有注解信息 Annotation annotation[] = allAnnotationInfo.getClass().getAnnotations(); System.out.println(\"`getAllAnnotationInfo`类的所有注解 : \"); for (Annotation info : annotation) &#123; System.out.println(info); &#125; System.out.println(); // 通过调用Class泛型类提供的`getMethod`方法获取与方法相关的信息 Method method = allAnnotationInfo.getClass().getMethod(\"fun\"); // 通过调用`getAnnotation`获取与对象相关联的特定注解 annotation = method.getAnnotations(); System.out.println(\"方法`fun()`的所有注解 : \"); for (Annotation info : annotation) &#123; System.out.println(info); &#125; &#125;&#125; 程序运行结果如下 1234567`getAllAnnotationInfo`类的所有注解 : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation2(description=\"Test class\")方法`fun()`的所有注解 : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"Hello annotation !\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation2(description=\"Test method\") 标记注解 编写示例程序来判断标记注解是否存在 12345678910111213141516171819202122232425262728293031323334353637383940import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.reflect.Method;/** * @ClassName: TagTest * @Description: 标记注解 * @author: HuangYuhui * @date: Apr 14, 2019 6:57:26 PM * */@Retention(RetentionPolicy.RUNTIME)@interface MyMarker_annotation &#123;&#125;public class MarketTest &#123; @MyMarker_annotation public static void fun() &#123; MarketTest marketTest = new MarketTest(); try &#123; // 通过调用Class泛型类提供的`getMethod`方法获取与该方法相关的信息 Method method = marketTest.getClass().getMethod(\"fun\"); // 通过使用`AnnotatedElement`接口的`isAnnotationPresent`方法来确定自定义注解中是否存在`标记注解` if (method.isAnnotationPresent(MyMarker_annotation.class)) &#123; System.out.println(\"存在标记注解 !\"); &#125; &#125; catch (Exception e) &#123; System.err.println(\"Method not found !\"); &#125; &#125; public static void main(String[] args) &#123; fun(); &#125;&#125; 程序运行结果如下 1存在标记注解 ! 说明 : 因为标记注解没有成员,所以应用标记注解时,后面不需要有圆括号.如果提供空的圆括号,也不会报错,但不是必需的.类似地,对于所有成员都使用默认值(default)的注解也可以没有圆括号. 重复注解 要创建重复注解,必须创建容器注解 123456789101112131415161718package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyReapeatable_annotation * @Description: `重复注解`的容器注解 * @author: HuangYuhui * @date: Apr 14, 2019 8:08:21 PM * */@Retention(RetentionPolicy.RUNTIME)public @interface MyReapeatable_annotation &#123; // `value`成员指定的是重复注解类型的数组 MyAnnotation[] value();&#125; 创建重复注解 1234567891011121314151617181920212223package pers.huangyuhui.annotation.myannotation;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @ClassName: MyAnnotation * @Description: 重复注解 * @author: HuangYuhui * @date: Apr 14, 2019 5:52:05 PM * *///指定`@Repeatable`注解的`value`成员值为容器注解 : `MyReapeatable_annotation`@Repeatable(MyReapeatable_annotation.class)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; int id() default 1; String name() default \"default value\";&#125; 通过反射获取重复注解信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package pers.huangyuhui.annotation.myannotation_test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import pers.huangyuhui.annotation.myannotation.MyAnnotation;/** * @ClassName: RepeatTest * @Description: 通过反射获取`重复注解`的信息 * @author: HuangYuhui * @date: Apr 14, 2019 7:58:54 PM * */public class RepeatTest &#123; @MyAnnotation @MyAnnotation(id=2) @MyAnnotation(id=3,name=\"YUbuntu0109\") public static void testMethod() &#123; RepeatTest repeatTest = new RepeatTest(); try &#123; // 获取Class对象 Class&lt;?&gt; class1 = repeatTest.getClass(); // 通过调用Class泛型类提供的`getMethod`方法获取与该方法相关的信息 Method method = class1.getMethod(\"testMethod\"); // `getAnnotation`用于获取与指定对象关联的特定注解 // Annotation annotation = method.getAnnotation(MyReapeatable_annotation.class); // System.out.println(annotation); // 使用`getAnnotationsByType`来获取`MyAnnotation`重复注解 Annotation[] annotations = method.getAnnotationsByType(MyAnnotation.class); for (Annotation info : annotations) &#123; System.out.println(info); &#125; &#125; catch (NoSuchMethodException e) &#123; System.err.println(\"Error : Method not found !\"); &#125; &#125; public static void main(String[] args) &#123; testMethod(); &#125;&#125; 程序运行结果如下 1234567891011121314//程序运行结果 :@pers.huangyuhui.annotation.myannotation.MyReapeatable_annotation(value=&#123;@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1), @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=2), @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"YUbuntu0109\", id=3)&#125;)//程序运行结果(使用`getAnnotationsByType`来获取`MyAnnotation`重复注解) : @pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=1)@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"default value\", id=2)@pers.huangyuhui.annotation.myannotation.MyAnnotation(name=\"YUbuntu0109\", id=3)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"详解Stack的实现方式及其应用","slug":"详解Stack的实现方式及其应用","date":"2019-04-13T02:00:01.000Z","updated":"2019-04-16T11:16:37.312Z","comments":true,"path":"2019/04/13/详解Stack的实现方式及其应用/","link":"","permalink":"http://yoursite.com/2019/04/13/详解Stack的实现方式及其应用/","excerpt":"","text":"栈栈的定义 : 栈(Stack)是一个有序线性表,只能在表的一端(称为栈顶 : top)执行插入和删除操作.最后插入的元素将第一个被删除.所以,栈也称为后进先出(Last In Frist Out: LIFO)或先进后出(Fist In Last Out: FILO)线性表.注意点 : 两个改变栈的操作都有专用名称,一个称为入栈(psuh): 表示在栈中插入一个元素. 另一个称为出栈(pop): 表示从栈中删除一个元素.试图对一个空栈执行出栈的操作称为下溢(underflow). 试图对一个满栈执行入栈操作称为溢出(overflow). 通常溢出和下溢均被认为是异常.栈的应用 直接应用 符号匹配. 中缀表达式转换为后缀表达式. 计算后缀表达式. 实现函数的调用(包括递归). 求范围误差(极差). 网页浏览器中已访问页面的历史记录(后退back按钮). 文本编辑器中的撤销(undo)序列. HTML和XML文件中的标签(tag)匹配. 间接应用 作为一个算法的辅助数据结构(例如: 树的遍历算法). 其它数据结构的组件(例如: 模拟队列). 推荐学习方法 推荐小伙伴们一个数据结构可视化的网站,可以大大提高学习效率哟(っ•̀ω•́)っ✎⁾⁾⁾ GO ! 栈的实现方式 基于简单数组的实现栈 ：程序示例如下*123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * @ClassName: SimpleStack * @Description: 利用简单数组实现栈 * @author: HuangYuhui * @param &lt;T&gt; * @date: Apr 10, 2019 4:15:47 PM * */public class SimArrayStack&lt;T&gt; &#123; // the size of stack private int maxSize; // store the data private Object[] stackArray; // the top pointer of the stack private int topPointer; public SimArrayStack(int max) &#123; maxSize = max; topPointer = -1; stackArray = new Object[maxSize]; &#125; // push new data into the stack public T push(T element) &#123; stackArray[++topPointer] = element; return element; &#125; // peek the top data in the stack public Object peek() &#123; return stackArray[topPointer]; &#125; // determines whether the stack is empty public boolean isEmpty() &#123; return topPointer == -1; &#125; // pop the data in the stack public Object pop() &#123; return stackArray[topPointer--]; &#125; // pop all of data in the stack public boolean popAll() &#123; if (isEmpty()) &#123; return false; &#125; while (!isEmpty()) &#123; System.out.println(\"The element to be poped : \" + pop()); &#125; return true; &#125; // Iterate through all the data in the stack public void traverseElement() &#123; System.out.print(\"All of element in the stack : \"); for (int i = 0; i &lt; stackArray.length; i++) &#123; if (i != stackArray.length - 1) &#123; System.out.print(stackArray[i] + \" , \"); &#125; else &#123; System.out.print(stackArray[i]); &#125; &#125; System.out.println(); &#125; // Test public static void main(String[] args) &#123; // SimpleStack&lt;Character&gt; stack2 = new SimpleStack&lt;Character&gt;(6); SimArrayStack&lt;Integer&gt; stack = new SimArrayStack&lt;Integer&gt;(6); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); stack.push(6); stack.traverseElement(); System.out.println(\"The element to be poped : \" + stack.pop()); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Push a new element : \" + stack.push(7)); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of elements : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/* ## The program running results are as follows :All of element in the stack : 1 , 2 , 3 , 4 , 5 , 6The element to be poped : 6The top element : 5Push a new element : 7The top element : 7Determines whether the stack is empty : falseThe element to be poped : 7The element to be poped : 5The element to be poped : 4The element to be poped : 3The element to be poped : 2The element to be poped : 1Pop all of elements : trueDetermines whether the stack is empty : true */ 局限性 : 栈的最大空间必须预先声明且不能改变.试图对一个满栈执行入栈时操作将产生一个针对简单数组这种特定实现栈方式的异常 ! 基于动态数组的实现栈 ：程序示例如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * @ClassName: DynArrayStack * @Description: 利用动态数组实现栈 * @author: HuangYuhui * @date: Apr 11, 2019 5:49:02 PM * */public class DynArrayStack&lt;T&gt; &#123; private int topPointer; private int capacity; private Object[] array; public DynArrayStack() &#123; topPointer = -1; capacity = 1; array = new Object[capacity]; &#125; // determines whether the stack is empty public boolean isEmpty() &#123; return (topPointer == -1); &#125; // determines whether the stack is full public boolean isStackFull() &#123; return (topPointer == capacity - 1);// or return (topPointer==array.length); &#125; // peek the top data of the stack public Object peek() &#123; return array[topPointer]; &#125; // push a new data into the stack public T push(T element) &#123; if (isStackFull()) &#123; doubleStack(); &#125; array[++topPointer] = element; return element; &#125; // double the size of the array public void doubleStack() &#123; Object newArr[] = new Object[capacity * 2]; System.arraycopy(array, 0, newArr, 0, capacity); capacity *= 2; array = newArr; &#125; // pop the data from the stack public Object pop() &#123; if (isEmpty()) &#123; System.err.println(\"The Stack is overflow !\"); &#125; return array[topPointer--]; &#125; // pop all of data from the stack public boolean popAll() &#123; if (isEmpty()) &#123; return false; &#125; while (!isEmpty()) &#123; System.out.println(\"The element to be poped : \" + pop()); &#125; return true; &#125; // Iterate through all the data in the stack public void traverseElement() &#123; System.out.print(\"all of element in the stack : \"); for (int i = 0; i &lt; array.length; i++) &#123; if (i != array.length - 1) &#123; System.out.print(array[i] + \" , \"); &#125; &#125; System.out.println(); &#125; // delete the stack public void deleteStack() &#123; topPointer = -1; &#125; // Test public static void main(String[] args) &#123; DynArrayStack&lt;Character&gt; stack = new DynArrayStack&lt;Character&gt;(); stack.push('a'); stack.push('b'); stack.push('c'); stack.push('d'); stack.push('e'); stack.push('f'); stack.push('g'); stack.traverseElement(); System.out.println(\"The element to be poped : \" + stack.pop()); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Push a new element : \" + stack.push('h')); System.out.println(\"The top element : \" + stack.peek()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of elements : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/*## The program running results are as follows :all of element in the stack : a , b , c , d , e , f , g , The element to be poped : gThe top element : fPush a new element : hThe top element : hDetermines whether the stack is empty : falseThe element to be poped : hThe element to be poped : fThe element to be poped : eThe element to be poped : dThe element to be poped : cThe element to be poped : bThe element to be poped : aPop all of elements : trueDetermines whether the stack is empty : true */ 注意 : 倍增太多可能导致内存溢出 !上述程序中利用重复倍增技术)提高了程序的性能,其总时间开销T(n) ≈ O(n) . 相比采用: 当栈满时,每次将数组的大小增加1更加节省了push操作的总时间开销.其总时间开销T(n) ≈ O(n²) . 基于链表来实现栈 ：程序示例如下12345678910111213141516171819202122232425262728293031323334353637/** * @ClassName: ListNode * @Description: 定义链表 * @author: HuangYuhui * @date: Apr 11, 2019 7:01:35 PM * */public class ListNode&lt;T&gt; &#123; private T data; private ListNode&lt;T&gt; next; public ListNode(T d) &#123; this.data = d; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ListNode&lt;T&gt; getNext() &#123; return next; &#125; public void setNext(ListNode&lt;T&gt; next) &#123; this.next = next; &#125; @Override public String toString() &#123; return \"[\" + data + \"]\"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * @ClassName: ListStack * @Description: 利用链表实现栈 * @author: HuangYuhui * @date: Apr 11, 2019 6:59:46 PM * */public class ListStack&lt;E&gt; &#123; private ListNode&lt;E&gt; headNode; public ListStack() &#123; this.headNode = new ListNode&lt;E&gt;(null); &#125; // push a new node into the linked list public ListNode&lt;E&gt; push(E data) &#123; if (headNode == null) &#123; headNode = new ListNode&lt;E&gt;(data); &#125; else if (headNode.getData() == null) &#123; headNode.setData(data);// initialize header node. &#125; else &#123; ListNode&lt;E&gt; newNode = new ListNode&lt;E&gt;(data); // create a new node. newNode.setNext(headNode);// connect to the header node. headNode = newNode;// set the new node to header node. &#125; return headNode; &#125; // returns the top node of the linked list public E top() &#123; if (headNode == null) &#123; return null; &#125; else &#123; return headNode.getData(); &#125; &#125; // pop top node in the linked list public E pop() &#123; if (headNode == null) &#123; throw new EmptyStackException(); &#125; else &#123; E node = headNode.getData(); headNode = headNode.getNext();// Reset the header node. return node; &#125; &#125; // pop all of nodes in the linked list public boolean popAll() &#123; if (headNode == null) &#123; throw new EmptyStackException(); &#125; while (!isEmpty()) &#123; System.out.println(\"Pop all of nodes : \" + pop()); &#125; if (isEmpty()) &#123; return true; &#125; return true; &#125; // determine whether the linked list is empty public boolean isEmpty() &#123; if (headNode == null) &#123; return true; &#125; else &#123; return false; &#125; &#125; // Iterate through all the node in the linked list public void getNodeByLoop(ListNode&lt;E&gt; head) &#123; if (isEmpty()) &#123; throw new EmptyStackException(); &#125; System.out.print(\"All of nodes of the linked list: \"); while (head != null) &#123; if (head.getNext() != null) &#123; System.out.print(head.getData() + \" , \"); &#125; else &#123; System.out.print(head.getData()); &#125; head = head.getNext(); &#125; System.out.println(); &#125; // destroy the linked list public boolean destroyStack(/* ListNode&lt;E&gt; head */) &#123; ListNode&lt;E&gt; auxilaryNode = null, iterator = headNode; while (iterator != null) &#123; auxilaryNode = iterator.getNext(); iterator = null; iterator = auxilaryNode; headNode = iterator;// Set the node to be deleted as the header node. &#125; if (auxilaryNode == null) &#123; return true; &#125; return false; &#125; // Test public static void main(String[] args) &#123; // ListStack&lt;Integer&gt; stack = new ListStack&lt;Integer&gt;(); ListStack&lt;String&gt; stack = new ListStack&lt;String&gt;(); stack.push(\"A\"); stack.push(\"B\"); stack.push(\"C\"); stack.push(\"D\"); stack.push(\"E\"); stack.push(\"F\"); stack.push(\"G\"); stack.getNodeByLoop(stack.headNode); System.out.println(\"The node to be poped : \" + stack.pop()); System.out.println(\"The top node : \" + stack.top()); System.out.println(\"Push a new node : \" + stack.push(\"H\")); System.out.println(\"The top node : \" + stack.top()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Pop all of nodes(success ?) : \" + stack.popAll()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); System.out.println(\"Push a new node : \" + stack.push(\"I\")); System.out.println(\"Push a new node : \" + stack.push(\"J\")); System.out.println(\"Push a new node : \" + stack.push(\"K\")); System.out.println(\"Destroy the stack(success ?) : \" + stack.destroyStack()); System.out.println(\"Determines whether the stack is empty : \" + stack.isEmpty()); &#125;&#125;/*## The program running results are as follows :All of nodes of the linked list: G , F , E , D , C , B , AThe node to be poped : GThe top node : FPush a new node : [H]The top node : HDetermines whether the stack is empty : falsePop all of nodes : HPop all of nodes : FPop all of nodes : EPop all of nodes : DPop all of nodes : CPop all of nodes : BPop all of nodes : APop all of nodes(success ?) : trueDetermines whether the stack is empty : truePush a new node : [I]Push a new node : [J]Push a new node : [K]Destroy the stack(success ?) : trueDetermines whether the stack is empty : true */ 栈的各种实现方法的比较 递增策略和倍增策略的比较 通过分析完成n个push操作的总时间开销T(n)来比较递增策略和倍增策略的区别.从长度为1的数组表示的空栈开始,一次push操作的平摊时间等于一组push操作的总时间开销的平均值.记为 : T(n)/n 递增策略 : 实现push操作的平摊时间开销为O(n)[O(n²)/n] . 倍增策略 : 实现push操作的平摊时间开销为O(n)[O(n)/n] . 基于数组实现和基于链表实现的比较(a) ：基于数组实现的栈 各个操作都是常数时间开销. 每隔一段时间倍增操作的开销过大. (从空栈开始)n个操作的任意序列的平摊时间开销为O(n).(b) ：基于链表实现的栈 栈规模的增加和减少都是很简洁. 各个操作都是常数时间开销. 每个操作都要使用额外的空间和时间开销来处理指针. 栈的应用 举例1 ：将用户输入的字符反转 首先定义一个基于简单数组的栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @ClassName: SimpleStack * @Description: 栈 * @author: HuangYuhui * @date: Apr 10, 2019 8:50:56 PM * */public class SimpleStack &#123; // 栈的大小 private int maxSize; // 存储栈元素 private char[] stackArray; // 栈顶指针 private int topPointer; public SimpleStack(int max) &#123; maxSize = max; topPointer = -1; stackArray = new char[maxSize]; &#125; // 逐个向栈中压入元素 public void push(char c) &#123; stackArray[++topPointer] = c; &#125; // 逐个弹出栈中元素 public char pop() &#123; return stackArray[topPointer--]; &#125; // 弹出栈中所有的元素 public void popAll() &#123; while (!isEmpty()) &#123; System.out.println(\"pop element : \" + pop()); &#125; &#125; // 查看栈顶元素 public char peek() &#123; return stackArray[topPointer]; &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return topPointer == -1; &#125;&#125; 利用栈来反转字符 1234567891011121314151617181920212223242526272829303132333435363738/** * @ClassName: MyStack * @Description: 利用栈来反转字符串 * @author: HuangYuhui * @date: Apr 10, 2019 3:46:40 PM * */public class ReversalString &#123; private String input; private String output; public ReversalString(String in) &#123; this.input = in; &#125; // 反转字符 public String doReversal() &#123; int stackSize = input.length(); SimpleStack stack = new SimpleStack(stackSize); // 将字符逐个压入栈中 for (int i = 0; i &lt; input.length(); i++) &#123; char in = input.charAt(i); stack.push(in); &#125; // 将字符逐个从栈中取出 output = \"\"; while (!stack.isEmpty()) &#123; char out = stack.pop(); output += out; &#125; return output; &#125;&#125; 接收用户输入的字符并测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @ClassName: ReversalStringTest * @Description: 测试反转字符程序 * @author: HuangYuhui * @date: Apr 10, 2019 8:53:24 PM * */public class ReversalStringTest &#123; static BufferedReader bufferedReader; @Test public void reversalTest() throws IOException &#123; String input, output; while (true) &#123; System.out.println(\"Please enter a string : \"); // System.out.flush(); input = getString(); if (input.equals(\"exit\")) &#123; bufferedReader.close(); break; &#125; // 将字符串反转 ReversalString reversal = new ReversalString(input); output = reversal.doReversal(); System.out.println(\"Reversed : \" + output); &#125; &#125; @Test @Ignore // 测试BufferedString中的控制字符反转的方法 public void BufferedStringTest() &#123; StringBuffer stringBuffer = new StringBuffer(\"reverse\"); System.err.println(\"Reversed : \" + stringBuffer.reverse()); &#125; // 通过缓冲流中的'readLine'方法高效读入用户输入的数据 public static String getString() &#123; String s = null; bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try &#123; s = bufferedReader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125; 程序运行结果如下 : 1234567Please enter a string : my qq: 3083968068Reversed : 8608693803 :qq ymPlease enter a string : exit 举例 ：检查用户输入的运算符(括号匹配) 首先定义一个基于简单数组的栈(同上,略写) 利用栈中入栈和出栈操作匹配括号符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @ClassName: BracketChecker * @Description: 匹配括号 * @author: HuangYuhui * @date: Apr 10, 2019 9:58:36 PM * */public class BracketChecker &#123; private String input; public BracketChecker(String in) &#123; this.input = in; &#125; public void chekc() &#123; boolean flag_a = false; boolean flag_b = false; int stackSize = input.length(); SimpleStack stack = new SimpleStack(stackSize); for (int i = 0; i &lt; input.length(); i++) &#123; char in = input.charAt(i); switch (in) &#123; case '&#123;': case '(': case '[': case '&lt;': stack.push(in); break; case '&#125;': case ')': case ']': case '&gt;': // 括号匹配 if (!stack.isEmpty()) &#123; char out = stack.pop(); if ((in == '&#125;' &amp;&amp; out != '&#123;') || (in == ')' &amp;&amp; out != '(') || (in == ']' &amp;&amp; out != '[') || (in == '&gt;' &amp;&amp; out != '&lt;')) &#123; System.err.println(\"error : \" + in + \" at \" + i); &#125; else &#123; flag_a = true; &#125; &#125; else &#123; System.err.println(\"error : \" + in + \" at \" + i); flag_a = false; &#125; break; // 只检查括号 default: break; &#125; &#125; // 如果匹配成功,循环结束后栈中理应为空. if (!stack.isEmpty()) &#123; System.out.println(\"Error : missing right delimiter.\"); &#125; else &#123; flag_b = true; &#125; if (flag_a &amp;&amp; flag_b) &#123; System.out.println(\"Success !\"); &#125; &#125;&#125; 接收用户输入的运算符并测试匹配程序 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @ClassName: BracketCheckerTest * @Description: 测试匹配括号符程序 * @author: HuangYuhui * @date: Apr 10, 2019 9:58:55 PM * */public class BracketCheckerTest &#123; static BufferedReader bufferedReader; public static void main(String[] args) throws IOException &#123; String input; while(true) &#123; System.out.println(\"Please enter containing delimiters : \"); System.out.flush(); input = getString(); if(input.equals(\"exit\")) &#123; bufferedReader.close(); break; &#125; BracketChecker checker = new BracketChecker(input); checker.chekc(); &#125; &#125; // 通过缓冲流中的'readLine'方法高效读入用户的数据. public static String getString() &#123; String s = null; bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try &#123; s = bufferedReader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125; 程序运行结果如下 : 1234567891011121314151617181920Please enter containing delimiters : &#123;[&lt;a&gt;b]c)d&#125;efgerror : ) at 8error : &#125; at 10Please enter containing delimiters : &#123;([&lt;a&gt;b]c)defgError : missing right delimiter.Please enter containing delimiters : &#123;([&lt;a&gt;b]cd&#125;efgerror : &#125; at 10Error : missing right delimiter.Please enter containing delimiters : &#123;([&lt;a&gt;b]c)d&#125;efgSuccess !Please enter containing delimiters : exit","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Data Structures and Algorithms","slug":"Data-Structures-and-Algorithms","permalink":"http://yoursite.com/tags/Data-Structures-and-Algorithms/"}]},{"title":"A simple MVC example","slug":"A-simple-MVC-example","date":"2019-04-12T13:34:28.000Z","updated":"2019-04-12T14:48:18.260Z","comments":true,"path":"2019/04/12/A-simple-MVC-example/","link":"","permalink":"http://yoursite.com/2019/04/12/A-simple-MVC-example/","excerpt":"","text":"一个关于JSP的简单MVC案例 程序示例图如下所示 : Java bean : 封装用户的身份信息. 12345678910111213141516171819202122232425262728293031323334353637package pers.huangyuhui.servlet.bean;/** * @ClassName: UserInfo * @Description: 用户信息 * @author: HuangYuhui * @date: Apr 8, 2019 5:15:21 PM * */public class UserInfo &#123; private String name; private String password; public UserInfo(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 操作数据库的工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package pers.huangyuhui.servlet.util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: JDBCUtil * @Description: 操作数据库工具类 * @author: HuangYuhui * @date: Apr 8, 2019 5:08:24 PM * */public class JDBCUtil &#123; // initialize the driver of database. static &#123; try &#123; Class.forName(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // Return a database connection object. public static Connection getConnection() &#123; Connection connection = null; try &#123; connection = DriverManager.getConnection( \"jdbc:mysql://LOCALHOST/DatabaseName?\" + \"useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\", \"root\", \"DatabasePassword\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; // release the resource of connecting. public static void freeResource(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 控制器(controller) : 用于验证用户的登录信息并根据其结果作出相应的处理. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.servlet.controller;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import pers.huangyuhui.servlet.bean.UserInfo;import pers.huangyuhui.servlet.modImpl.DalidateUserInfo;@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LoginServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); String name = request.getParameter(\"userName\"); String password = request.getParameter(\"userPassword\"); UserInfo userInfo = new UserInfo(name, password); boolean result = new DalidateUserInfo().vaildateUserInfo(userInfo); if (result) &#123; // Sends a temporary redirect response to the client using thespecified redirect // location URL and clears the buffer. response.sendRedirect(\"weclome.jsp\"); &#125; else &#123; response.sendRedirect(\"error.jsp\"); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 用于操作用户信息的接口. 1234567891011121314package pers.huangyuhui.servlet.model;import pers.huangyuhui.servlet.bean.UserInfo;/** * @ClassName: LoginDao * @Description: 操作用户信息的接口 * @author: HuangYuhui * @date: Apr 8, 2019 5:53:53 PM * */public interface UserInfoDao &#123; public boolean vaildateUserInfo(UserInfo userInfo);&#125; 模型(model) : 实现了操作用户信息接口的类. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pers.huangyuhui.servlet.modImpl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import pers.huangyuhui.servlet.bean.UserInfo;import pers.huangyuhui.servlet.model.UserInfoDao;import pers.huangyuhui.servlet.util.JDBCUtil;/** * @ClassName: DalidateUserInfo * @Description: 验证用户的身份信息 * @author: HuangYuhui * @date: Apr 8, 2019 4:55:27 PM * */public class DalidateUserInfo implements UserInfoDao &#123; private static String sql = \"SELECT name,password FROM user WHERE NAME=? AND PASSWORD=?\"; // 节省JDBC连接资源. private static Connection connection = JDBCUtil.getConnection(); private PreparedStatement preparedStatement; private ResultSet resultSet; public boolean vaildateUserInfo(UserInfo userInfo) &#123; try &#123; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, userInfo.getName()); preparedStatement.setString(2, userInfo.getPassword()); resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; return true; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtil.freeResource(null, preparedStatement, resultSet); &#125; return false; &#125;&#125; 视图(view) : 用户登录界面.: 123456789101112131415161718192021222324252627282930&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login in&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=\"center\"&gt; &lt;form action=\"LoginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"userName\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"login in\" &gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 日记 : 今天做了大学第一个兼职!在一个购物广场旁折风车,串风车,固定风车…中午吃坐在地上吃盒饭时让我突然想起了四年前撤学外出的自己,难忘的是青春哟!计划把外快买书嘿嘿嘿..(っ•̀ω•́)っ✎⁾⁾⁾","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"jQuery 过滤器学习笔记","slug":"jQuery-过滤器学习笔记","date":"2019-04-10T01:59:17.000Z","updated":"2019-04-10T03:07:20.616Z","comments":true,"path":"2019/04/10/jQuery-过滤器学习笔记/","link":"","permalink":"http://yoursite.com/2019/04/10/jQuery-过滤器学习笔记/","excerpt":"","text":"jQuery 初学过滤器总结jQuery 过滤器分类 基础过滤器 内容过滤器 子元素过滤器 可见性过滤器 jQuery 基础过滤器 :header : 过滤器用于筛选所有标题元素.从’h1’到’h6’均在此选择范围内. :eq() : 过滤器用于选择指定序号为’n’的元素,序号从0开始. gt() : 过滤器用于选择大于序号为’n’的元素,序号从0开始. lt() : 过滤器用于选择所有小于序号为’n’的元素,序号从0开始. :first : 过滤器用于筛选第一个符合条件的元素. :last : 过滤器用于筛选最后一个符合条件的元素. even : 过滤器用于筛选符合条件的偶数个元素. odd : 过滤器用于筛选符合条件的奇数个元素. not() : 过滤器用于筛选所有不符合条件的元素. jQuery 基础过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 基础过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':header' : 过滤器用于筛选所有标题元素.从&lt;h1&gt;到&lt;h6&gt;均在此选择范围内 --&gt; $(document).ready(function() &#123; $(\":header\").css(\"background-color\", \"palegreen\"); &#125;); &lt;!--':eq()' : 过滤器用于选择指定序号为'n'的元素,序号从0开始 --&gt; &lt;!--'gt()' : 过滤器用于选择大于序号为'n'的元素,序号从0开始 --&gt; &lt;!--'lt()' : 过滤器用于选择所有小于序号为'n'的元素,序号从0开始 --&gt; $(document).ready(function() &#123; //'equal' : 影响的是第三行的列表选项元素&lt;li&gt;. $(\"li:eq(2)\").css(\"border\", \"1px solid #00FFFF\"); //'less than' : 影响的是第三行之后的所有列表选项. $(\"li:gt(2)\").css(\"border\", \"1px solid blue\"); //'greater than' : 影响的是第三行之前的所有列表选项. $(\"li:lt(2)\").css(\"border\", \"1px solid red\"); &#125;); &lt;!--':first' : 过滤器用于筛选第一个符合条件的元素 --&gt; &lt;!--':last' : 过滤器用于筛选最后一个符合条件的元素 --&gt; $(document).ready(function() &#123; //':first()' : 过滤器用于筛选第一个符合条件的元素. $(\"p:first\").css(\"border\", \"1px solid lawngreen\"); //':last()' : 过滤器用于筛选最后一个符合条件的元素. $(\"p:last\").css(\"background-color\", \"bisque\"); &#125;); &lt;!--'even' : 过滤器用于筛选符合条件的偶数个元素 --&gt; &lt;!--'odd' : 过滤器用于筛选符合条件的奇数个元素 --&gt; $(document).ready(function() &#123; //':even' : 过滤器用于筛选符合条件的偶数个元素. $(\"div#even_old tr:even\").css(\"background-color\", \"lightblue\"); //':odd' : 过滤器用于筛选符合条件的奇数个元素. $(\"div#even_old tr:odd\").css(\"background-color\", \"silver\"); &#125;); &lt;!--'not()' : 过滤器用于筛选所有不符合条件的元素 --&gt; $(document).ready(function() &#123; //注意:为避免冲突不能同时使用两行该过滤器,如果要同时除去两个段落元素可以使用如下语法规则. $(\":not(div#eq_gt_lt ul li,div#first_last p)\").css(\"border\", \"0.5px solid magenta\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 160px; height: 180px; border: 1px solid; float: left; margin: 10px; &#125; ul &#123; width: 80px; height: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 基础过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"eq_gt_lt\"&gt; &lt;ul&gt; &lt;li&gt;第一章&lt;/li&gt; &lt;li&gt;第二章&lt;/li&gt; &lt;li&gt;第三章&lt;/li&gt; &lt;li&gt;第四章&lt;/li&gt; &lt;li&gt;第五章&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"first_last\"&gt; &lt;p&gt;第一个段落元素&lt;/p&gt; &lt;p&gt;第二个段落元素&lt;/p&gt; &lt;p&gt;第三个段落元素&lt;/p&gt; &lt;/div&gt; &lt;div id=\"even_old\"&gt; &lt;table id=\"test\" border=\"1\" width=\"160\" height=\"180\"&gt; &lt;!-- &lt;caption&gt;table&lt;/caption&gt; --&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 基础过滤器示例图 jQuery 内容过滤器 :parent() : 用于选择包含子节点(子元素和文本)的元素,和:empty()恰相反哟. :empty() : 用于选择未包含子节点(子元素和文本的元素). :contains() : 用于筛选出所有包含指定文本内容的元素. :has() : 用于选择包含指定选择器的元素. jQuery 内容过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 内容过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':contains()' : 用于筛选出所有包含指定文本内容的元素 --&gt; $(document).ready(function() &#123; $(\"p:contains('瘦西湖')\").css(\"color\", \"red\"); &#125;); &lt;!--':empty()' : 用于选择未包含子节点(子元素和文本的元素) --&gt; $(document).ready(function() &#123; $(\"div#empty td:empty\").css(\"background\", \"darkgray\"); &#125;); &lt;!--':parent()' : 用于选择包含子节点(子元素和文本)的元素,和':empty()'恰相反哟 --&gt; $(document).ready(function() &#123; $(\"div#parent td:parent\").css(\"background-color\", \"lightblue\"); &#125;); &lt;!--':has()' : 用于选择包含指定选择器的元素 --&gt; $(document).ready(function() &#123; //选择包含&lt;strong&gt;标签的&lt;p&gt;元素. $(\"p:has(strong)\").css(\"background\", \"khaki\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 150px; height: 230px; border: 1px solid; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 内容过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"contains\"&gt; &lt;p&gt;大明寺&lt;/p&gt; &lt;p&gt;瘦西湖北门&lt;/p&gt; &lt;p&gt;观音山&lt;/p&gt; &lt;p&gt;瘦西湖南门&lt;/p&gt; &lt;p&gt;扬州动植物园&lt;/p&gt; &lt;p&gt;瘦西湖东门&lt;p&gt; &lt;/div&gt; &lt;div id=\"empty\"&gt; &lt;table border=\"1\" width=\"150\" height=\"230\"&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"parent\"&gt; &lt;table border=\"1\" width=\"150\" height=\"230\"&gt; &lt;tr&gt; &lt;th&gt;Header&lt;/th&gt; &lt;th&gt;Header&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"has\"&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;p&gt;这是&lt;strong&gt;段落&lt;/strong&gt;元素..&lt;/p&gt; &lt;p&gt;这是&lt;span&gt;段落&lt;/span&gt;元素..&lt;/p&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;p&gt;这是段落元素..&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 内容过滤器示例图 jQuery 子过滤器 :nth-child : 用于筛选页面上每个父元素中的第’n’个子元素.序号从1开始计数 :first-child : 过滤器用于筛选页面上每个父元素中的第一个子元素. :last-child : 过滤器用于筛选页面上每个父元素中的最后一个子元素. :only : 用于筛选所有在父元素中有且只有一个的子元素. jQuery 子过滤器示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 子过滤器总结&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':first-child' : 过滤器用于筛选页面上每个父元素中的第一个子元素 --&gt; $(document).ready(function() &#123; $(\"div#firstChild ul li:first-child\").css(&#123; fontWeight: \"bold\", color: \"red\" &#125;); &#125;); &lt;!--':last-child' : 过滤器用于筛选页面上每个父元素中的最后一个子元素 --&gt; $(document).ready(function() &#123; $(\"div#lastChild p:last-child\").css(&#123; fontWeight: \"bold\", color: \"#0000FF\" &#125;); &#125;); &lt;!--':only' : 用于筛选所有在父元素中有且只有一个的子元素 --&gt; $(document).ready(function() &#123; $(\"div#onlyChild ul li:only-child\").css(&#123; fontWeight: \"bold\", color: \"chartreuse\" &#125;); &#125;); &lt;!--':nth-child' : 用于筛选页面上每个父元素中的第'n'个子元素.序号从1开始计数 --&gt;// $(document).ready(function() &#123;// //筛选奇数项子元素.// $(\"ul#item01 li:nth-child(odd)\").css(\"color\", \"red\");// //选择第一个子元素.// $(\"ul#item02 li:nth-child(2)\").css(\"color\", \"red\");// //选择第3n+2个子元素.// $(\"ul#item03 li:nth-child(3n+2)\").css(\"color\", \"red);// &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 150px; height: 180px; border: 1px solid; float: left; margin: 10px; &#125; ul &#123; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h3&gt;jQuery 子过滤器总结&lt;/h3&gt; &lt;/center&gt; &lt;hr&gt; &lt;div id=\"firstChild\"&gt; &lt;ul&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Pear&lt;/li&gt; &lt;li&gt;Grape&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Bread&lt;/li&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"lastChild\"&gt; &lt;p&gt;段落元素01..&lt;/p&gt; &lt;p&gt;段落元素02..&lt;/p&gt; &lt;p&gt;段落元素03..&lt;/p&gt; &lt;p&gt;段落元素05..&lt;/p&gt; &lt;/div&gt; &lt;div id=\"onlyChild\"&gt; &lt;ul&gt; &lt;li&gt;第一个子元素&lt;/li&gt; &lt;li&gt;第二个子元素&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;唯一的子元素&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; 无标签的文本内容.. &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"nthChild\"&gt; &lt;ul id=\"item01\"&gt; &lt;!-- li:nth-child(odd): 筛选奇数项元素 --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"item02\"&gt; &lt;!-- li:nth-child(2): 筛选第2个元素 --&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;li&gt;e&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"item03\"&gt; &lt;!-- li:nth-child(3n+2): 筛选第3n+2个元素 --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 子过滤器示例图 jQuery 可见性过滤器 :hidden : 过滤器用于筛选出所有处于隐藏状态的元素. :visible : 过滤器用于筛选出所有处于可见状态的元素. jQuery 可见性过滤器示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 可见性选择器&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;!--':hidden' : 过滤器用于筛选出所有处于隐藏状态的元素 --&gt; &lt;!--':visible' : 过滤器用于筛选出所有处于可见状态的元素 --&gt; $(document).ready(function() &#123; //选择处于隐藏状态的div元素. //find(selector): 用于查找处于可见状态的元素.该方法可以返回符合条件的元素的对象数组. var hideDiv = $(\"body\").find(\"div:hidden\"); //选择处于隐藏状态的input元素. //$(div#test01): 表示在id=\"test01\"的div元素中查找. var hideInput = $(\"div#test01\").find(\"input:hidden\"); //选择处于可见状态的input元素. var visbleInput = $(\"div.test02\").find(\"input:visible\"); //选择处于可见状态的div元素. var visbleDiv = $(\"body\").find(\"div:visible\"); window.alert(\"处于隐藏状态的div元素有:\" + hideDiv.length + \"个!\\n处于隐藏状态的input元素有:\" + hideInput.length + \"个 !\" + \"\\n处于显示状态的div元素有 : \" + visbleDiv.length + \"个!\" + \"\\n处于显示状态的input元素有 : \" + visbleInput.length + \"个!\"); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;&lt;/h3&gt; &lt;hr&gt; &lt;!-- 隐藏状态的div元素 --&gt; &lt;div style=\"display: none\"&gt;display:none&lt;/div&gt; &lt;!-- 显示状态的div元素 --&gt; &lt;div id=\"test01\"&gt; &lt;!-- 隐藏状态的input元素 --&gt; &lt;input type=\"hidden\" /&gt; &lt;/div&gt; &lt;!-- 显示状态的div元素 --&gt; &lt;div class=\"test02\"&gt; &lt;!-- 显示状态的input元素 --&gt; name : &lt;input type=\"text\" name=\"username\" /&gt;&lt;br /&gt;&lt;br&gt; password: &lt;input type=\"password\" name=\"userpassword\" /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery 可见性过滤器示例图 Ok,学习笔记很简约,毕竟初学jQuery嘛.后期会不断更新我学习jQuery的学习笔记的(っ•̀ω•́)っ✎⁾⁾ ~ 最近养成了晨跑和夜跑的好习惯,也改掉了熬夜及大量饮咖啡的坏习惯,只想证明: 我会努力让自己更喜欢自己 !让你们喜欢我(✪ω✪) ~","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Java Servlet API","slug":"Java-Servlet-API","date":"2019-04-08T01:42:24.000Z","updated":"2019-04-08T02:19:43.352Z","comments":true,"path":"2019/04/08/Java-Servlet-API/","link":"","permalink":"http://yoursite.com/2019/04/08/Java-Servlet-API/","excerpt":"","text":"学习笔记 : Servlet API Servlet 体系结构图如下 Servlet 2.5 示例程序 web.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_lifecycle&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;GlobalParamName&lt;/param-name&gt; &lt;param-value&gt;Web容器中的初始化参数值 ..&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.ServletAPI&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;ServletParamName&lt;/param-name&gt; &lt;param-value&gt;当前Servlet的初始化参数值 ..&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletAPI&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet program 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * ServletConfig 接口中的方法解析如下 : * 1.ServletContext getServletContext(): 获取Servlet上下文对象,如: application.. * 2.String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. ... * * ServletContext类中的常用方法解析 : * 1.getContextPath(): 相对路径. GetRealPath(): 绝对路径. * 2.String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). * */public class ServletAPI extends HttpServlet &#123; private static final long serialVersionUID = -4244028101944729741L; @Override public void init() throws ServletException &#123; //super.init(); System.out.println(\"( Servlet 2.5 )This is init() ..\"); /* * 获取当前Servlet的初始化参数. * String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. */ String value = super.getInitParameter(\"ServletParamName\"); //web.xml System.out.println(\"当前的Servlet的参数`ServletParamName`的值为 : \"+value); /* * 获取当前Web容器的初始化参数. * String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). */ ServletContext servletContext = this.getServletContext(); String globalValue = servletContext.getInitParameter(\"GlobalParamName\"); //web.xml System.out.println(\"当前Web容器的参数`GobalParamName`的值为 : \"+globalValue); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doGet(req, resp); System.out.println(\"( Servlet 2.5 )service() -&gt; doGet()+doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doPost(req, resp); doGet(req, resp); &#125; @Override public void destroy() &#123; //super.destroy(); System.err.println(\"( Servlet 2.5 )This is destory() ..\"); &#125;&#125;/*### The result be shown as followed : Apr 06, 2019 6:45:24 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.( Servlet 2.5 )This is init() .. &lt;———the result当前的Servlet的参数`ServletParamName`的值为 : 当前Servlet的初始化参数值 .. &lt;———the result当前Web容器的参数`GobalParamName`的值为 : Web容器中的初始化参数值 .. &lt;———the resultApr 06, 2019 6:45:24 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.Apr 06, 2019 6:45:25 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.Apr 06, 2019 6:45:25 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"]Apr 06, 2019 6:45:25 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 06, 2019 6:45:25 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [3,136] milliseconds( Servlet 2.5 )service() -&gt; doGet()+doPost() .. &lt;———the result */ Servlet 3.0 示例程序 web.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;ServletAPI_3.0&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 注意: 全局的Web容器的参数是无法通过注解来配置的.毕竟注解只隶属于具体的一个Servlet,因此无法为整个Web容器设置初始化参数. 而全局的Web参数并不属任何一个Servlet.如果使用Servlet 3.0需要在web.xml配置文件中初始化该参数. 毕竟web.xml是属于整个容器的配置文件. --&gt; &lt;context-param&gt; &lt;param-name&gt;GobalParamName&lt;/param-name&gt; &lt;param-value&gt;GlobalParamValue&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * 通过注解为当前Servlet初始化参数.如下所示. */@WebServlet(value=\"/ServletAPI\",loadOnStartup=1,initParams= &#123;@WebInitParam(name=\"ServletParamName\",value=\"ServletParamValue\")&#125;)public class ServletAPI extends HttpServlet &#123; private static final long serialVersionUID = -4244028101944729741L; @Override public void init() throws ServletException &#123; //super.init(); System.out.println(\"( Servlet 3.0 )This is init() ..\"); /* * 获取当前Servlet的初始化参数. * String getInitParameter(String name): 在当前Servlet范围内,获取名为name的参数. */ String value = super.getInitParameter(\"ServletParamName\"); //web.xml System.out.println(\"当前的Servlet的参数`ServletParamName`的值为 : \"+value); /* * 获取当前Web容器的初始化参数. * String getInitParameter(String name): 在当前Web容器范围内,获取名为name的参数值(初始化参数值). */ ServletContext servletContext = this.getServletContext(); String globalValue = servletContext.getInitParameter(\"GlobalParamName\"); //web.xml System.out.println(\"当前Web容器的参数`GobalParamName`的值为 : \"+globalValue); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doGet(req, resp); System.out.println(\"( Servlet 3.0 )service() -&gt; doGet()+doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //super.doPost(req, resp); doGet(req, resp); &#125; @Override public void destroy() &#123; //super.destroy(); System.err.println(\"( Servlet 3.0 )This is destory() ..\"); &#125;&#125;/*###The result be shown as followed : Apr 07, 2019 6:52:11 PM org.apache.jasper.servlet.TldScanner scanJarsINFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.( Servlet 3.0 )This is init() .. &lt;———the result当前的Servlet的参数`ServletParamName`的值为 : ServletParamValue &lt;———the result当前Web容器的参数`GobalParamName`的值为 : GlobalParamValue &lt;———the resultApr 07, 2019 6:52:11 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"] Apr 07, 2019 6:52:11 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 07, 2019 6:52:11 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [2,502] milliseconds( Servlet 3.0 )service() -&gt; doGet()+doPost() .. &lt;———the result */","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Back up the Hexo blog","slug":"Back-up-the-Hexo-blog","date":"2019-04-07T01:55:40.000Z","updated":"2019-04-07T03:21:13.781Z","comments":true,"path":"2019/04/07/Back-up-the-Hexo-blog/","link":"","permalink":"http://yoursite.com/2019/04/07/Back-up-the-Hexo-blog/","excerpt":"","text":"文章主题 : 备份及恢复Hexo博客的详细教程 备份原理: master branch: 管理Hexo生成的静态网页. HexoBackup branch: 管理Hexo 重要的本地源文件及配置文件. 前言 : 如果你利用Hexo搭建了一个静态的网站用于写博客,会发现自己利用Hexo deploy的都是Hexo generate生成的静态网页.而下面的目录并没有被push到远程仓库 ! 需要备份的目录及配置文件 source目录 : 博客文章的.md文件.(需要备份) themes 目录 : 主题文件夹.(需要备份) scaffolds目录 : 文章的模板.(需要备份) package.json : 安装包的名称.(需要备份) .gitignore : 限定在push时哪些文件可以忽略.(需要备份) _config.yml : 站点的配置文件.(需要备份) 不需要备份的目录及配置文件 node_modules/ : 是安装包的目录，在执行npm install的时候会重新生成.(不需要备份) .git/ : 主题和站点都有，标志这是一个git项目.(不需要备份) public是hexo generate生成的静态网页.(不需要备份) .deploy_git : 同3,hexo g也会生成.(不需要备份) db.json : 配置文件.(不需要备份) 注 : 不需要拷贝的文件正是.gitignore中所忽略的哟 ! 备份 创建GitHub仓库Username.github.io如果同名仓库之前已经创建,请将之前的仓库改名,新建的仓库必须是Username.github.io. 在Username.github.io仓库中创建一个新的分支HexoBackup.(此时的默认分支是: master) 在该仓库中的Setting中将HexoBackup修改为为默认分支. 将刚刚创建的新仓库clone至本地后将之前你存放Hexo bolg文件夹中的_config.yml,themes/,source/,scaffolds/,package.json,.gitignore复制至你所clone下来的Username.github.io文件夹中. 将themes/theme-name/中的.git/删除,否则无法将主题文件夹push到远程分支.(易错点 : 详情见文章最后的注意事项) 在Username.github.io文件夹执行npm install和npm install hexo-deployer-git(注意: 此时在该文件内的分支名应该显示为:HexoBackup). 通过执行git add .,git commit -m &quot;A description of the information submitted&quot;,git push origin HexoBackup来提交Hexo bolg网站的源文件. 如果更新博客文章后可以通过执行hexo g -d生成静态网页部署到Github上. 更新( 在本地对博客修改: 包括修改主题样式,发布新文章等.. ) 以下两个步骤没有严格的顺序,小伙伴们随心所欲呗 ~ 首先执行hexo g -d生成静态网页部署至Github上. 其次依次执行git add .,git commit -m &quot;&quot;,git push origin HexoBackup来提交Hexo bolg网站源文件. 恢复 ( 重装电脑后,或者在其它电脑上想修改自己的博客.. ) 安装git. 安装Nodejs和npm. 将博客仓库clone到本地. 在文件夹内执行命令npm install hexo-cli -g,npm install,npm install hexo-deployer-git. 注意事项 ( Hexo无法备份themes主题目录中的部分theme.. ) 如果想正常备份你所喜欢的theme的话,可以在博客目录运行如下命令 : 123456789101112131415161718$ git rm --cached themes\\theme-name\\rm 'themes/theme-name'$ git statusOn branch masterYour branch is up-to-date with 'origin/HexoBackup'.Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) deleted: themes/theme-nameUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) themes/theme-name///最后再执行: `git add themes/theme-name/` 就会发现可以成功备份该主题了哟 ! 原因分析 : 这是因为用到了git的子模块(git submodule)功能,既你在你的git项目里clone的他人的项目.在你的主项目的git库里,子模块只是一个HEAD指针,指向子模块的commit ..详情见下述参考的博客文章哟 (っ•̀ω•́)っ✎⁾⁾ 参考博客文章如下( 甚是感谢 ) : https://blog.itswincer.com/posts/7efd2818/ https://hoxis.github.io/hexo-backup-theme-dir.html","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]},{"title":"Servlet lifecycle","slug":"Servlet-lifecycle","date":"2019-04-06T07:06:10.000Z","updated":"2019-04-08T01:56:42.394Z","comments":true,"path":"2019/04/06/Servlet-lifecycle/","link":"","permalink":"http://yoursite.com/2019/04/06/Servlet-lifecycle/","excerpt":"","text":"学习笔记 ：Java Servlet 的生命周期及其解析 Tomcat v9.0 + JDK 11 + Google Chrome Servlet lifecycle Servlet 2.5 示例 JSP program 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 2.5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"ServletLifecyle\"&gt;doGet : Servlet 3.0&lt;/a&gt; &lt;!-- 注意: form的默认提交方式为get --&gt; &lt;div&gt; &lt;form action=\"ServletLifecyle\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"ServletLifecyle\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ServletLifecyle extends HttpServlet &#123; @Override public void init() throws ServletException &#123; // TODO Auto-generated method stub //super.init(); System.out.println(\"(Servlet 2.5)init() ..\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub //super.doGet(req, resp); System.out.println(\"service() -&gt; doGet() + doPost() ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub //super.doPost(req, resp); this.doGet(req, resp); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub //super.destroy(); System.out.println(\"destory() ..\"); &#125;&#125;/*### 1-第一次点击请求连接时Servlet响应的结果如下 :Apr 05, 2019 10:27:32 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the result### 2-当返回再次点击链接请求时Servlet响应的结果如下 : Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() .. &lt;— 第一次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第一次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第二次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第三次点击链接时Servlet的相应结果service() -&gt; doGet() + doPost() .. &lt;— 第四次点击链接时Servlet的相应结果...### 3-上述来回来点击链接请求后且稍许时间后会发现Servlet自动调用了destory() !!!?Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..service() -&gt; doGet() + doPost() ..Apr 05, 2019 10:31:41 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] has starteddestory() ..### 由上述1,2,3可得如下结论 : init() : 默认情况下第一次访问Servlet时会被执行( 只执行一次 ),扩 : 也可以通过配置web.xml文件使得Tomcat启动时自动执行.(详见下述`web.xml`示例)service() : 包括doGet()和doPost(),执行的次数与调用次数成正比.destory() : 关闭Tomcat服务时执行一次.*/ web.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_lifecycle&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- Servlet 2.5 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.ServletLifecyle&lt;/servlet-class&gt; &lt;!-- 使得tomcat启动时自动加载init()方法,其数字代表: 当有多个Servlet时,规划其启动的顺序,默认值为`-1`. --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletLifecyle&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 12345678910通过在`web.xml`配置文件中添加'&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;'使得Tomcat启动时自动加载init() !INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.(Servlet 2.5)init() .. &lt;——— the result.Apr 06, 2019 2:31:09 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"http-nio-8080\"]Apr 06, 2019 2:31:09 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler [\"ajp-nio-8009\"]Apr 06, 2019 2:31:09 PM org.apache.catalina.startup.Catalina startINFO: Server startup in [2,686] milliseconds Servlet 3.0 示例12345678910111213/*Servlet 3.0 较2.5可以通过注解使Tomcat启动时自动加载Servlet 中的初始化方法: init().@WebServlet(value=\"/ServletTest\" , loadOnStartup=1)value : 其为一个字符串数组对象,用于接收多个Servlet,当只有一个Servlet时默认可以不写.loadOnStartup : 当有多个Servlet时将按照数字大小顺序执行.其默认为-1. */@WebServlet(value=\"/ServletTest\" , loadOnStartup=1)public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; ······ 总结深究 ( 待解决的问题 )发现学习中我并没有关闭Tomcat服务器,但自动执行了销毁方法destory() ! 于是查了一些资料,至今还未发现其答案,我认为 : 应该是Tomcat新版本的特性吧(超时自动销毁Servlet?),但是自动调用Destory()时与Service()时间差也太小了吧 ! 36 秒啊 !12345678910111213### 3-上述来回来点击链接请求后且稍许时间后会发现Servlet自动调用了destory() !!!?Apr 05, 2019 10:31:05 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] is completed(Servlet 2.5)init() ..service() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultservice() -&gt; doGet() + doPost() .. &lt;—— the resultApr 05, 2019 10:31:41 PM org.apache.catalina.core.StandardContext reloadINFO: Reloading Context with name [/Servlet_basic_lifecycle] has starteddestory() .. &lt;—— the result ? what happend ! ? (I'm not close the the Tomcat server now)······ 注意 : &lt;—— 是本人后期为便于大家审阅代码加上的. 后期在不断学习中会完善这些我未知的问题的 ! Stay hungry,Stay foolish.","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java Servlet各版本使用详解","slug":"Java-Servlet各版本使用详解","date":"2019-04-05T07:22:46.000Z","updated":"2019-04-05T08:30:14.805Z","comments":true,"path":"2019/04/05/Java-Servlet各版本使用详解/","link":"","permalink":"http://yoursite.com/2019/04/05/Java-Servlet各版本使用详解/","excerpt":"","text":"详细讲解各版本Java Servlet的使用,这次哥哥讲细节 (✪ω✪) !Servlet 2.5 : 通过配置web.xml文件来映射Servlet ( 示例代码如下 ) Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041public class FirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -7228095681625205247L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"This is doGet ..\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); System.out.println(\"This is doPost ..\"); &#125;&#125;/* * #(doGet)The result be shown as followed : * * Apr 05, 2019 10:15:33 AM org.apache.catalina.core.StandardContext reload INFO: Reloading Context with * name [/Servlet_basic] is completed * This is doGet .. *//* * #(doPost)The result be shown as followed : * * Apr 05, 2019 10:57:08 AM org.apache.catalina.core.StandardContext reload INFO: Reloading Context with * name [/Servlet_basic] is completed * This is doPost .. * *//* * #(doPost —&gt; doGet)The result be shown as followed : * * Apr 05, 2019 11:22:21 AM org.apache.catalina.core.StandardContext reload NFO: Reloading Context with * name [/Servlet_basic] is completed * This is doGet .. * This is doPost .. * */ JSP Progarm 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 2.5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- href same as : http://localhost:8080/Servlet_basic_version_2.5/FirstServlet 注意: 构建路径及`WebContent`都属于 : 根目录. JSP中的'/'表示服务器的跟路径.如 : http://localhost:8080/ web.xml中的'/'表示项目的根路径.如 : http://localhost:8080/Servlet_basic_version_2.5/ --&gt; &lt;a href=\"/Servlet_basic_version_2.5/FirstServlet\"&gt;doGet : FirstServlet&lt;/a&gt; &lt;!-- 注意 : `form`的默认提交方式为`get`,所以修改为: method=\"post\" --&gt; &lt;div&gt; &lt;form action=\"FirstServlet\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"FirstServlet\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 当程序运行后,点击`HiServlet.jsp`页面中的`url`请求时`web.xml`配置文件中的映射关系如下: 1.&lt;servlet-mapping&gt; ↓ ↓ 2.请求被根目录(src/WebContent是根目录)下&lt;url-pattern&gt;标签中的Servlet程序拦截. ↓ ↓ 3.(寻找Servlet.class的桥梁) 匹配与其&lt;servlet-name&gt;名称相同的&lt;servlet&gt;. ↓ ↓ 4.通过&lt;servlet-class&gt;标签中的`Servlet.class`响应用户的请求. 可此得知标签&lt;servlet-name&gt;是&lt;servlet&gt;和&lt;servlet-mapping&gt;之间沟通的桥梁( 其名称任意,但其两者间的名称必须相同 ! ) 如不同`Tomcat`则会抛出如下异常信息: error..Caused by: java.lang.IllegalArgumentException: Servlet mapping specifies an unknown servlet name [sameName].. --&gt; &lt;servlet&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;servlet-class&gt;pers.huangyuhui.servlet.test.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sameName&lt;/servlet-name&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet 3.0 : 通过注解来映射相应的Servlet. Servlet program 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*1.Servlet 3.0 与 Servlet 2.5 的区分 : Servlet 3.0 : 较`Servlet 2.0`不需要在web.xml中配置Servlet映射,但需在Servlet类的定义处上编写注解: @WenServlet(\"/Servlet url..\")其中\"/Servlet url..\"与Servlet 2.0在web.xml配置文件中&lt;url-pattern&gt;标签中的内容原理是相同的.2.Servlet3.0 响应请求的路线 : 如: 当点击`HiServlet.jsp`中的url链接时其先与@WebServlet中的值进行匹配,如果匹配成功,则说明请求的就是该注解所对应的类. */@WebServlet(\"/ServletTest\")public class ServletTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ServletTest() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub //response.getWriter().append(\"Served at: \").append(request.getContextPath()); System.out.println(\"This is doGet ..\"); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub //doGet(request, response); System.out.println(\"This is doPost ..\"); &#125;&#125;/*#The result be shown as followed : * * Apr 05, 2019 12:06:08 PM org.apache.catalina.startup.Catalina start * INFO: Server startup in [3,425] milliseconds * This is doGet .. &lt;— 点击`url`链接时`Servlet`触发的响应. * This is doPost .. &lt;— 点击`doPost`按钮时`Servlet`触发的响应. * This is doGet .. &lt;— 点击`doGet`按钮时`Servlet`触发的响应. * */ JSP Program 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"ISO-8859-1\"&gt; &lt;title&gt;Servlet 3.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"ServletTest\"&gt;doGet : Servlet 3.0&lt;/a&gt; &lt;div&gt; &lt;form action=\"ServletTest\" method=\"get\"&gt;&lt;hr&gt; &lt;input type=\"submit\" value=\"doGet \" /&gt; &lt;/form&gt; &lt;form action=\"ServletTest\" method=\"post\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"doPost\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; web.xml 12345678910111213&lt;!-- 无需任何修改 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;display-name&gt;Servlet_basic_version_3.0&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; JSP运行效果示例图 常被问到 : 辉仔啊,都大二下学期了呀,怎还是没有女朋友哟 ! 心想 : 是不是太爱Coding了呢 (灬°ω°灬) ~","categories":[],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Servlet同版本对应的Tomcat及不同版本的web.xml写法","slug":"Servlet同版本对应的Tomcat及不同版本的web-xml写法","date":"2019-04-05T06:34:34.000Z","updated":"2019-04-05T07:05:35.071Z","comments":true,"path":"2019/04/05/Servlet同版本对应的Tomcat及不同版本的web-xml写法/","link":"","permalink":"http://yoursite.com/2019/04/05/Servlet同版本对应的Tomcat及不同版本的web-xml写法/","excerpt":"","text":"Tomcat 实现了Java Servlet规范,Java Servlet Pages技术,不同版本的Tomcat支持不同的Servlet及JSP规范. 最新示例图如下所示 : 不同版本的web.xml写法如下 : web.xml v2.3 12345&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt; &lt;web-app&gt; &lt;!-- ... --&gt;&lt;/web-app&gt; web.xml v2.4 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app id=\"WebApp_9\" version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;/web-app&gt; web.xml v2.5 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt;&lt;/web-app&gt; web.xml 3.0 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;/web-app&gt; web.xml 4.0 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE xml&gt;&lt;web-app version=\"4.0\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"&gt;&lt;/web-app&gt;","categories":[],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"JDK","slug":"JDK","permalink":"http://yoursite.com/tags/JDK/"}]},{"title":"jQuery selector","slug":"jQuery-selector","date":"2019-04-04T10:39:52.000Z","updated":"2019-04-04T11:10:10.443Z","comments":true,"path":"2019/04/04/jQuery-selector/","link":"","permalink":"http://yoursite.com/2019/04/04/jQuery-selector/","excerpt":"","text":"为了配合Java web项目的学习今天开始学习了jQuery 啦 ! 要知道计算机语言之间是互通的,已学习C和Java的我学习jQuery起来是如此的高效,基本一天就可以学习半本书哟.. 下面是我下午学习jQuery选择器的总结代码.嘿嘿,案例是不是也很搞笑(高效)呢 ?! 啊哈哈 ヾ(◍°∇°◍)ﾉﾞ 代码示例 ( jQuery vision : jquery-1.12.4.js,目前官方最新版本是: jquery-3.3.1.js ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;jQuery 选择器总结案例&lt;/title&gt; &lt;script src=\"../../../jQuerySource/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //全局选择器 (Global Select) : 用于选择文档中所有的元素. $(document).ready(function() &#123; $(\"*\").css(\"border\", \"1px solid red\"); &#125;); //元素选择器 (Element Select) : 用于选择所有指定标签名称的元素. $(document).ready(function() &#123; $(\"p\").css(\"border\", \"1px solid blue\"); &#125;); //ID选择器 (ID Select) : 用于选择指定ID名称的单个元素. $(document).ready(function() &#123; $(\"#test01\").css(\"border\", \"1px solid aqua\"); &#125;); //类选择器 (Class Select) : 用于筛选出具有同一个class属性的所有元素. $(document).ready(function() &#123; $(\".style01\").css(\"border\", \"1px solid fuchsia\"); &#125;); //多重选择器 (Multiple Select) : 适用于需要批量处理的多种元素. $(document).ready(function() &#123; $(\"h3,div.style02\").css(\"border\", \"1px solid forestgreen\"); &#125;); //属性选择器 (Attribute Select) : 选择具有指定属性要求的元素. $(document).ready(function() &#123; $(\"[href$='.cn']\").css(\"background-color\", \"yellow\"); &#125;); //表单选择器 (Form Select) : 用于选择指定类型或处于指定状态的表单元素. $(document).ready(function() &#123; $(\":password\").css(\"border\", \"2px solid blue\"); &#125;); //子元素选择器 (Child Select) : 只能选择指定元素的第一层子元素. $(document).ready(function() &#123; $(\"ul.ul-2&gt;li\").css(\"background-color\", \"yellowgreen\"); &#125;); //后代选择器 (Descendant Select) : 选择指定元素内包含的所有后代元素.比子元素选择器的涵盖范围更广. $(document).ready(function() &#123; $(\"div.style04 strong\").css(\"background-color\", \"chartreuse\"); &#125;); //后相邻选择器 (Next Adjacent Select) : 用于选择与指定元素相邻的后一个元素. $(document).ready(function() &#123; $(\"div.style03+div\").css(\"border\", \"1px solid brown\"); &#125;); //后兄弟选择器 (Next Siblings Selector) : 可用于选择指定元素后面跟随的所有符合条件的兄弟节点元素. $(document).ready(function() &#123; $(\"div.style04~div\").css(\"border\", \"1px solid burlywood\"); &#125;); //CSS 选择器 (CSS Selector) : 用于改变指定HTML元素的CSS属性. $(document).ready(function() &#123; $(\"#test03 span\").css(\"color\", \"fuchsia\"); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; h4 &#123; margin: 0; text-align: center; font-family: \"lucida console\"; &#125; div, p &#123; width: auto; height: 100px; float: left; padding: 10px; margin: 10px; font-family: \"lucida console\"; border: 1px solid greenyellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;jQuery 选择器总结案例&lt;/h4&gt; &lt;hr /&gt; &lt;div id=\"test01\"&gt; 这是一个'div'标签.. &lt;/div&gt; &lt;div id=\"test02\"&gt; 这是一个'div'标签.. &lt;/div&gt; &lt;div id=\"test03\"&gt; &lt;span&gt;这是一个'div'标签..&lt;/span&gt; &lt;/div&gt; &lt;div class=\"style01\"&gt;这是一个'div'标签..&lt;/div&gt; &lt;p&gt; 这是一个'p'标签.. &lt;/p&gt; &lt;div class=\"style02\"&gt;这是一个'div'标签..&lt;/div&gt; &lt;div&gt; &lt;a href=\"http://www.sina.com.cn\"&gt;新浪&lt;/a&gt; &lt;a href=\"http://163.com\"&gt;网易&lt;/a&gt; &lt;a href=\"http://www.sohu.com\"&gt;搜狐&lt;/a&gt; &lt;/div&gt; &lt;div class=\"style03\"&gt; &lt;ul class=\"ul-1\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;ul&gt; &lt;li&gt;2.1&lt;/li&gt; &lt;ul class=\"ul-2\"&gt; &lt;li&gt;2.1.1&lt;/li&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"style04\"&gt; 这是&lt;span&gt;一个&lt;strong&gt;'div'&lt;/strong&gt;标签&lt;/span&gt;.. &lt;/div&gt; &lt;div&gt; &lt;form method=\"post\" action=\"URL\"&gt; &lt;label&gt;user name &lt;input type=\"text\" name=\"username\" required /&gt; &lt;/label&gt;&lt;br /&gt; &lt;label&gt;passoword &lt;input type=\"password\" name=\"password\" required /&gt; &lt;/label&gt;&lt;br /&gt; &lt;/form&gt;&lt;br&gt; &lt;button type=\"submit\"&gt;confirm&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行效果 ( 是不是以为我会做的花里胡哨的呢,嘿嘿这里只是为了学习所以就简单点吧,后期深入学习后有时间会写一些特炫的网页给大家的 ~ )","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Simple Factory Pattern","slug":"Simple-Factory-Pattern","date":"2019-04-03T04:29:16.000Z","updated":"2019-04-03T10:25:41.747Z","comments":true,"path":"2019/04/03/Simple-Factory-Pattern/","link":"","permalink":"http://yoursite.com/2019/04/03/Simple-Factory-Pattern/","excerpt":"","text":"简单工厂模式结构与实现简单工厂模式结构 Factory(工厂角色) : 工厂角色既工厂类,它是简单工厂模式的核心,负责实现创建所有产品实例的内部逻辑.工厂类还可以被外界直接调用,创建所需的产品对象.在工厂类中提供了静态的工厂方法factoryMethod(),它的返回类型为抽象产品类型Product. Product(抽象产品角色) : 它是工厂类创建的所有对象的父类,封装了各种产品对象的公有方法,它的引入将提高系统的灵活性,使得在工厂类中只需定义一个通用的工厂方法,因为所有创建的具体产品对象都是其子类对象. ConcreteProduct(具体产品角色) : 它是简单的工厂模式的创建目标,所有被创建的对象都充当这个角色的某个具体类的实例,每一个具体产品角色都继承了抽象产品的角色.需要实现在抽象产品中声明的抽象方法. 实例说明123某软件公司要基于Java语言开发一套图表库,该图表库可以为应用程序提供多种不同外观的图表,例如柱状图(HistogramChart),饼状图(PieChart)折线图(LineChart)等..该软件公司图表库设计人员希望为应用系统人员提供一套灵活易用的图标库,通过设置不同的参数即可得到不同类型的图表.而且可以较为方便的对图表库进行扩展,以便能够在将来增加一些新类型的图表. 下述用简单工厂模式来设计该图表库 (1)Chart : 抽象图表接口,充当抽象产品类. 1234public interface Chart &#123; public void display();&#125; (2)HistogramChart : 柱状图类,充当具体产品类. 1234567891011public class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(\"Create the histogram chart .\"); &#125; public void display() &#123; System.out.println(\"Display the histogram chart .\"); &#125;&#125; (3)PieChart : 饼状体类,充当具体产品类. 1234567891011public class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(\"Create the pie chart .\"); &#125; public void display() &#123; System.out.println(\"Display the pie chart .\"); &#125;&#125; (4)LineChart : 折线图类,充当具体产品类. 1234567891011public class LineChart implements Chart &#123; public LineChart() &#123; System.out.println(\"Create the line chart .\"); &#125; public void display() &#123; System.out.println(\"Display the line chart .\"); &#125;&#125; (5)ChartFactory : 图表工厂类,充当工厂类. 1234567891011121314151617181920public class ChartFactory &#123; public static Chart getChart(String chartType) &#123; Chart chart = null; if (chartType.equalsIgnoreCase(\"histogram\")) &#123; chart = new HistogramChart(); System.out.println(\"Initialize the histogram chart .\"); &#125; else if (chartType.equalsIgnoreCase(\"pie\")) &#123; chart = new PieChart(); System.out.println(\"Initialize the pie chart .\"); &#125; else if (chartType.equalsIgnoreCase(\"line\")) &#123; chart = new LineChart(); System.out.println(\"Initialize the line chart .\"); &#125; else &#123; System.err.println(\"error : Please chakout your object name. \"); &#125; return chart; &#125;&#125; (6)SimpleFactoryPatternTest : 客户端测试类 12345678910111213141516171819202122232425262728public class SimpleFactoryPatternTest &#123; public static void main(String[] args) &#123; Chart chart = ChartFactory.getChart(\"histogram\"); chart.display(); Chart chart2 = ChartFactory.getChart(\"pie\"); chart2.display(); Chart chart3 = ChartFactory.getChart(\"line\"); chart3.display(); /*##The result be shown as followed:## Create the histogram chart . Initialize the histogram chart . Display the histogram chart . Create the pie chart . Initialize the pie chart . Display the pie chart . Create the line chart . Initialize the line chart . Display the line chart . */ &#125;&#125; 不难发现,上述示例中在创建具体Chart对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象.客户端代码需要重新编译,这对于客户端而言违反了开闭原则.下面介绍一种常用的解决方案,可以实现在不修改客户端代码的前提下能让客户端能够更换具体产品对象. 首先可以将静态的工厂方法的参数存储在XML格式的配置文件中(config.xml).如下所示 : 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;config&gt; &lt;chartType&gt;histograma&lt;/chartType&gt;&lt;/config&gt; 再通过一个工具类XML Util来读取配置文件中的字符串参数,XMLUtil类的代码如下 : 1234567891011121314151617181920212223242526272829303132333435public class XMLUtil &#123; private final static String path = \"src\\\\objctConfig.xml\"; // 该方法用于从XML配置文件中提取图表类型,并返回类型名. public static String getChartType() &#123; // 创建文档对象. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); try &#123; DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); Document document; document = documentBuilder.parse(new File(path)); // 获取包含图标类型的文本节点. NodeList nodeList = document.getElementsByTagName(\"chartType\"); Node node = nodeList.item(0).getFirstChild(); String chartType = node.getNodeValue().trim(); return chartType; &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; 在引入配置文件和工具类XMLUtil之后,客户端代码SimpleFactoryPatternTest.java修改如下 : 1234567891011121314151617181920public class SimpleFactoryPatternTest &#123; public static void main(String[] args) &#123; /* * 通过读取配置文件中的参数来初始化指定的对象. */ String chartType = XMLUtil.getChartType(); Chart chart = ChartFactory.getChart(chartType); chart.display(); /*##The result be shown as followed:## Create the histogram chart . Initialize the histogram chart . Display the histogram chart . */ &#125;&#125; 不难发现,在上述客户端代码中并不包含任何与具体图标对象相关的信息,如果需要更换具体图标对象,只需要修改配置文件config.xml,无须修改任何原代码,既而符合开闭原则 开闭原则 : 是面向对象的可复用设计的第一块基石,它是最重要的面向对象设计原则.开闭原则由Bertrand Meyer于1998年提出,其定义如下 : 12345开闭原则 : 软件实体应当对扩展开放,对修改关闭.Open-Closed Principle(OCP) : Software entities should be open for extension,but closed for modification.在开闭原则的定义中,软件实体可以指一个软件模块,一个由多个类组成的局部结构或一个独立的类,开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展. 简单工厂模式优/缺点与适用环境简单工厂模式的优点 工厂类包含必要的判断逻辑,可以决定在什么时候创建哪一个产品类的实例,客户端可以避免直接创建产品对象的职责.而仅仅’消费’产品,简单工厂模式实现了对象创建和使用的分离. 客户端无须知道所创建的具体产品的类名.只需要知道具体产品类所对应的参数即可,对于一些复杂的类名,通过简单工厂模式可以在一定程度上减少使用者的记忆量. 通过引入配置文件,可以在不修改任何客户端代码的情况下更换和增加新的具体产品类,在一定程序上提高了系统的灵活性. 简单工厂模式的缺点 由于工厂类集中了所有产品的创建逻辑,职责过重,一旦不能正常工作,整个系统都要受到影响. 使用简单工厂模式势必会增加系统中类的个数(引入了新的工厂类),增加了系统的复杂度和理解难度. 系统扩展困难,一旦添加新产品就不得不修改工厂逻辑,在新产品类型较多时有可能造成工厂逻辑过于复杂,不利于系统的扩展和维护. 简单工厂模式由于使用了静态工厂方法,造成工厂角色无法形成基于继承的等级结构. 简单工厂模式的适用环境 工厂类负责创建的对象比较少,由于创建的对象比较少,不会造成工厂方法中的业务逻辑过于复杂. 客户端只知道传入工厂类的参数,对于如何创建对象并不关心. 参考书籍《 Java设计模式 》 作者: 刘伟 (可以说本书的代码示例写的非常用心,很适合初学者参考)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"}]},{"title":"Spring 依赖注入","slug":"Spring-依赖注入","date":"2019-04-02T13:12:43.000Z","updated":"2019-04-02T14:12:21.655Z","comments":true,"path":"2019/04/02/Spring-依赖注入/","link":"","permalink":"http://yoursite.com/2019/04/02/Spring-依赖注入/","excerpt":"","text":"Spring framework 依赖注入篇如果想区分依赖注入与控制反转(IOC)两者之间的不同,可以参考Martin Fowler给出的解释.查看文章: GO 简单来说,依赖注入的情况如下 : 12345678public class A &#123; public void importantMethod() &#123; B b = ... // get an instance of B b.usefulMethod(); ... &#125; ...&#125; 如果要使用B,类A必须先获得组件B的实例引用,若B是一个具体类,则可以通过new关键字直接创建组件B实例.但是,如果B是接口,且有多个实现,则问题就变得复杂了,我们固然可以任意选择接口B的一个实现类,但这也意味着A的可重用性大大降低了,因为无法采用B的其他实现.* 依赖注入是这样处理此类情景的 : 接管对象的创建工作,并将该对象的引用注入需要该对象的组件.以上述例子为例,依赖注入框架会分别创建对象A和对象B,将对象B注入到对象A中.为了能让框架进行依赖注入,程序员需要编写特定的set方法或构建方法,例如: 为了能将B注入到A中,类A会被修改成如下形式 : 123456789101112public class A &#123; private B b; public void importantMethod() &#123; // no need to worry about creating B anymore. // B b = ... // get an instance of B. b.usefulMethod(); ... &#125; public void setB(B b) &#123; this.b = b; &#125;&#125; 修改后的类A新增了一个setter方法,该方法将会被框架调用,以注入一个B的实例.由于对象依赖由依赖注入,类A的importantMethod()方法不再需要在调用B的usefulMethod()方法前去创建一个B的实例. 当然,也可以采用构造器方式注入,如下所示 : (本例中,Spring会先创建B的实例,再创建实例A,然后把B注入到实例A中.) 12345678910111213public class A &#123; private B b; public A(B b)&#123; this.b = b; &#125; public void importantMethod() &#123; // no need to worry about creating B anymore. // B b = ... // get an instance of B. b.usefulMethod(); ... &#125;&#125; 注意 : Spring 管理的对象称为beans . 1234567通过提供一个控制反转器(或者依赖注入器IOC),`Spring`为我们提供一种可以&apos;聪明&apos;地管理Java对象的依赖关系的方法.其优雅之处在于 : 程序员无须了解`Spring`框架的存在,更不需要引入任何`Spring`类型.使用`Spring`,程序几乎将所有重要对象的创建工作移交给了`Spring`,并配置如何注入依赖.`Spring`支持`XML`和`注解`两种配置方式.此外还需要创建是一个`ApplicationContext`对象,其代表一个`Spring`控制反转容器,`org.springframework.context.ApplicationContext`接口有多个实现,包括`ClassPathXmlApplicationContext`和`FileSystemXmlApplicationContext`.这两个实现都需要至少一个包含`beans`信息的`XML`文件. ClassPathXmlApplicationContext : 在类加载路径中加载配置文件. FileSystemXmlApplicationContext : 在文件系统路径中加载文件. 下面为从类路径中加载applicationContext1.xml和applicationContext2.xml的ApplicationContext创建的一个代码示例 :123456ApplicationContext context = new ClassPathXmlApplicationContext( new String[]&#123;\"applicationContext1.xml\",\"applicationContext2.xml\"&#125;)//可以通过调用`ApplicationContext`的`getBean`方法获得对象//getBean方法会查询`id`为`product`且类型为`Product`的`bean`对象.Product product = context.getBean(\"product\",Product.class); 注 : 理想情况下,我们仅需在测试代码中创建一个ApplicationContext,应用程序本身无需处理,对于Spring MVC应用,可以通过一个Spring Servlet来处理ApplicationContext,既而无须直接处理. 摘抄书籍 : 《 Servlet,JSP and Spring MVC - beginner 》 -&gt; author: [加] Budi Kurniawan [美] Paul Deck","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"全国计算机等级考试-三级数据库技术","slug":"全国计算机等级考试-三级数据库技术","date":"2019-03-31T02:46:51.000Z","updated":"2019-03-31T07:52:47.680Z","comments":true,"path":"2019/03/31/全国计算机等级考试-三级数据库技术/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-三级数据库技术/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 三级数据库技术篇来来来,先欣赏一下昨天去看樱花时拍的风景,语文学的不好的我只能用超级美来形容啦啊哈哈哈 (づ｡◕ᴗᴗ◕｡)づ 哎呦 ~ 要是俺和自己喜欢女孩纸走在这条路上哥哥心里一定美的够够的（づ￣3￣）づ╭❤～ 敲黑板：三级数据库技术题目也不难,较二级概念题多一些 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧开门见山,先感受一下哥哥带来的学习笔记,详细到感动自己的那种..ヾ(❀^ω^)ﾉﾞ填空题总结 笔记共记录了17张卷子所有选择题的解析及易错点,毕竟有30分呢嘿嘿.. (づ｡◕ᴗᴗ◕｡)づ 应用题总结 笔记共记录了9张卷子所有应用题的解析及易错点,同样占据30分哟 (づ｡◕ᴗᴗ◕｡)づ 笔记的下载链接 : , Good luck to you ~","categories":[],"tags":[{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://yoursite.com/tags/SQL-Server/"}]},{"title":"全国计算机等级考试-二级MySQL","slug":"全国计算机等级考试-二级MySQL","date":"2019-03-31T02:10:44.000Z","updated":"2019-03-31T03:19:47.780Z","comments":true,"path":"2019/03/31/全国计算机等级考试-二级MySQL/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-二级MySQL/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级MySQL篇敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ 嘿嘿,没想到你点进来啦,其实我大一报考MySQL二级时并没有记笔记,这就尴尬啦..既然你点击近来啦,那就推荐一波学习资源吧 (っ•̀ω•́)っ✎⁾⁾ 我在备考时使用的都是未来教育提供的考试模拟系统,如下图示例( 没有打广告哟,是真的挺不错的！ ) 很多同学使用的基本都是未来教育的考试模拟系统,可以说和真实考试的系统几乎相似,虽然说2019/3月份的全国计算机等考的考试系统更新了..但题目的基本模块还是没有变化的,如果大家想考二级/三级/四级,真的非常建议使用未来教育的考试模拟系统！至于说能否考过那就要看你自己认真度啦嘿嘿 ~ 未来教育的官方网站 : , GO ~","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"}]},{"title":"全国计算机等级考试-二级C语言","slug":"全国计算机等级考试-二级C语言","date":"2019-03-31T01:45:04.000Z","updated":"2019-03-31T07:23:52.922Z","comments":true,"path":"2019/03/31/全国计算机等级考试-二级C语言/","link":"","permalink":"http://yoursite.com/2019/03/31/全国计算机等级考试-二级C语言/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级C篇来来来,先欣赏一下昨天去看樱花时拍的风景,语文学的不好的我只能用超级美来形容啦啊哈哈哈 (づ｡◕ᴗᴗ◕｡)づ 敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ OK ! 说直白一点,二级考试真是的傻白甜,毕竟考试范围都已经给你了,况且还有可能遇到原题呢...但是！但是！但是！过程很重要,相信这一切都是你走向春天的必经之路,大家千万不因傲慢而忽略了路边的风景 ！ 下面是我考试前的一些练习题,阔以说将题目要求,运行结果,注意事项,易错点写的的非常的详细啦！( 嘿嘿,大家阔以省下买试卷的钱咯 (づ｡◕ᴗᴗ◕｡)づ ) 试卷及笔记的下载链接 : , Good luck to you ~ 建议多多刷题哟,尽情体验C语言中指针与数据结构及算法的美吧 (っ•̀ω•́)っ✎⁾⁾","categories":[],"tags":[{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"static keyword","slug":"static-keyword","date":"2019-03-16T14:03:17.000Z","updated":"2019-03-18T14:54:09.340Z","comments":true,"path":"2019/03/16/static-keyword/","link":"","permalink":"http://yoursite.com/2019/03/16/static-keyword/","excerpt":"","text":"今天刷C语言程序题时遇到很多关于static关键字的题目,为区分Java中的static继而回到寝室写一篇关于Java中static关键字的使用详解.先来谈谈Java中的static123\"static方法就是没有this的方法.在static方法内部不能调用非静态方法,反过来是可以的.而且可以在没有创建任何对象的前提下,仅仅通过类本身来调用static方法.这实际上正是static方法的主要用途. ———— 《 Java编程思想 》\"总结为一句话：方便在没有创建对象的情况下来进行调用(方法/变量). static 变量123static 变量也称作静态变量.静态变量: 静态变量被所有的对象所共享,在内存中只有一个副本.它当且仅当在类初次加载时会被初始化.非静态变量: 是对象所拥有的,在创建对象的时候被初始化.存在多个副本,各个对象拥有的副本互不影响. static 方法123使用 static 修饰的方法一般称作静态方法.由于静态方法不依赖于任何对象就可以进行访问,因此对于静态方法来内说是无法使用 this 关键字的,因为它不依附于任何对象,既然都没有对象,就谈不上 this 了 ! 继而由于这个特性,在静态方法中不能访问类的非静态成员变量和非静态成员方法,因为非静态成员方法/变量都是必须依赖具体的`对象`才能够被调用. static 代码块12静态代码块以优化程序性能.static 块可以置于类中的任何地方,类中可以有多个static块.在类初次被加载的时候,会按照 static 代码块的顺序逐个执行,并且只会执行一次. 使用JDBC中简单的Data access obejct实例来讲解如何利用static关键字优化程序性能 ! (っ•̀ω•́)っ✎⁾⁾ 首先创建一个连接数据库的工具类,使用static 代码块解决重复加载驱动问题,提高性能. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @ClassName: JDBCUtil * @Description: Connect to the database. * @author: Huang Yuhui * @date: Mar 13, 2019 3:19:41 PM */public class JDBCUtil &#123; private JDBCUtil() &#123; // TODO Auto-generated constructor stub &#125; // initialize the driver of database. static &#123; try &#123; Class.forName(\"com.mysql.cj.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // Return a database connection object. public static Connection getConnection() &#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(\"jdbc:mysql://localhost/databaseName?\" + \"useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\", \"username\", \"password\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; // release the resource of connecting. public static void freeResource(Connection connection,PreparedStatement preparedStatement,ResultSet resultSet) &#123; if(connection!=null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(resultSet!=null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用static修饰单独抽取出来的Connection对象使其成为静态变量.继而使得整个DAO可以共享此对象. 12345678910/** * @ClassName: basicConnection * @Description: Share this object of Connection. * @author: Huang Yuhui * @date: Mar 13, 2019 3:15:43 PM */public class basicConnection &#123; public static Connection connection = JDBCUtil.getConnection();&#125; 小哥就简写一下DAO层类,便于举例: 增加数据表信息的类 + 删除数据表信息的类 + ······ 12345678910111213141516/** * @ClassName: basicConnectionTest * @Description: Insert the specified data into the database. * @author: Huang Yuhui * @date: Mar 16, 2019 10:40:11 PM */public class InsertTest &#123; Connection connection = basicConnection.connection; @Test public void insertInfoTest() &#123; System.out.println(\"insertInfoTest : \" + connection); &#125;&#125; 12345678910111213141516/** * @ClassName: DeleteTest * @Description: Delete the specified data from the database. * @author: Huang Yuhui * @date: Mar 16, 2019 11:05:44 PM */public class DeleteTest &#123; Connection connection2 = basicConnection.connection; @Test public void deleteInfoTest() &#123; System.out.println(\"deleteInfoTest : \" + connection2); &#125;&#125; 利用JUnit测试套件测试Data acess object中所有的测试类. 123456789101112/** * @ClassName: AllTest * @Description: Test all class. * @author: Huang Yuhui * @date: Mar 16, 2019 11:04:58 PM * */@RunWith(Suite.class)@SuiteClasses(&#123; InsertTest.class, DeleteTest.class &#125;)public class AllTest &#123;&#125; 输出结果如下所示.由于Connection对象被抽取且被static修饰为了静态对象.继而在整个DAO中可以共享这个连接数据库的对象.而不必每一个类中都实例化一次连接数据库的对象(Connection)继而提升程序的性能（づ￣3￣）づ╭❤～ 12insertInfoTest : com.mysql.cj.jdbc.ConnectionImpl@158a8276deleteInfoTest : com.mysql.cj.jdbc.ConnectionImpl@158a8276 哎哟,不知觉又半夜啦! 晚安,好梦. remember love yourself deeply.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"http://yoursite.com/tags/JUnit/"}]},{"title":"全国计算机等级考试-Java","slug":"全国计算机等级考试-Java","date":"2019-03-15T03:10:42.000Z","updated":"2019-03-15T05:29:13.157Z","comments":true,"path":"2019/03/15/全国计算机等级考试-Java/","link":"","permalink":"http://yoursite.com/2019/03/15/全国计算机等级考试-Java/","excerpt":"","text":"NCRE(National Computer Rank Examination) —— 二级Java篇 敲黑板：二级考试的试题都是在往年的试卷中随机抽取的 ! 勿慌 ✧⁺⸜(●˙▾˙●)⸝⁺✧ 选择题总结(重点+易错点) try与catch的匹配是: catch到的异常是try中可能抛出的异常或其子类的实例. 按照标准的I/O模型,Java提供了三种标准流,分别为：System.in , System.out , System.err. 属于过滤字节输出流的类是：BufferedOutputSteam. 当窗口被激活时，调用的窗口事件的方法是：public void windowActivated(WindowEvent) 对类进行并发控制，需要私有属性进行定义变量(private),用锁将方法锁起来synchronized,这样就不会出现并发出现异常情况. Swing组件的外观与具体平台无关. 在Java中的开发包1.7之前，switch不支持String类型数据,case值和key值匹配时,程序会报错 ! 在一个类中可以定义为多个名称相同,但参数不同的方法,这种机制叫做：重载. 匿名内部类也就是没有名字的内部类,正因为没有名字,所以匿名内部类只能使用一次!它通常用来简化代码编写,但使用匿名内部类还有一个前提条 件：必须继承一个父类或实现一个接口 ! 类变量必须带有的修饰符为：static 在Java中二维数组定义的语法为：数据类型[][]数组名=new 数据类型[行数][列数]; 在Java.io包的字节输入流中,过滤器输入流的基类是: FilterInputStream 所有字符输入流都从Reader类继承,所有字符输出流都从Writer类继承. Swing除继续沿用了AWT中的FlowLayout,BorderLayout,CardLayout,GridLayout,GridBagLayout布局管理器外,新增了一个BoxLayout布局管理 器.BoxLayout布局管理器按照自上而下(y轴)或者从左到右(x轴)的顺序布局依次加入构件. java.awt.event包中定义了适配器类；该包中定义的适配器类包括以下几个: ComponentAdapter 构件适配器 ContainerAdapter 容器适配器 FocusAdapter 焦点适配器 MouseAdapter 鼠标适配器 KeyAdapter 键盘适配器 MouseMotionAdapter 鼠标运动适配器 WindowAdapters 窗口适配器 而FrameAdapter 不属于事件适配器类 !* 如果发生下面几种情况时,处于运行状态的线程就进入阻塞状态 : 线程调用sleep(); / join(); / wait();方法. 如果线程中使用sychronized来请求对象的所未获得时. 如果线程中有输入/输出操作,则进入阻塞状态;待输入/输出操作结束后,线程进入可运行状态. 在Java中,使用synchronized关键字标识临界区.Java平台将每个由synchronized语句设置的对象设置一个锁,称为对象锁,它是一种独占的排 他锁,既同一时刻最多只能有一个线程获取该锁,为了能够正常地使用对象锁，对共享数据的所有访问都必须在临界区内.同时临界区的共享数据必须是私 有的,确保只能通过对象的方法才能访问到. 算法的空间复杂度是指算法在执行过程中所需的内存空间.算法执行期间所需的存储空间包括3个部分: 输入数据的存储空间 程序本身所占的存储空间 算法执行过程中所需要的额外空间 需求分析是对待开发软件提出的需求进行分析并给出详细设计,是解决软件做什么的阶段. 软件设计可以使用的工具有总体结构图,程序流程图,N-S图,PAD图..注意：数据流程图(DFD)是需求分析使用的工具 ! 逻辑设计阶段形成逻辑数据模型(从E-R图向关系模式转换).注意点：关系模式设计属于：逻辑设计 能够运行Java字节码的命令为: javac break在java起到跳出循环的作用.continue是跳过当次循环继续执行下一次循环. XML只是一个配置文件通过流将XML件读取出来，并不属于字节流 ! yield()该方法与sleep()类似,只是不能由用户指定暂停多长时间,并且yield()方法只能让同优级的线程有执行的机会 ! javap的作用: Javap是 Java class文件分解器,可以反编译,也可以查看java编译器生成的字节码. 在数据库设计中,在需求分析阶段建立数据字典. 注意: 在 / 运算中并不存四舍五入的操作!只取整数部分! 正则表达式是一种描述某种匹配检索规则的字符串. java.util.regex 包中有一个Pattern类,用于进行快速模拟匹配. java.util.regex 包还具有一个Matcher匹配器类. javax.swing.text是文本类包,javax.swing.table是表格类包,javax.swing.plaf包括一些对外观样式操作的类和接口. JFrame是页面容器,JToolBar为工具条(属于容器的一种). Java中的线程包含CPU,代码,数据三个部分 interrupt();中断线程:中断状态被清除. start();用于开启一个线程. notify();用于唤醒一个处于等待状态的线程. 当一个Applet所在的浏览器被最小化以后,不能被调用的Applet方法是init() init(); 当浏览器加载applet,进行初始化的时候调用该方法. start(); 该方法在init()方法之后调用,当用户从其它页面转到包含applet的页面时该方法也被调用. stop(); 在用户离开包含applet的页面时被调用. destroy(); 当applet不再被使用,或浏览器退出的时候,该方法被调用. 操作题总结(重点+API介绍) 数组的算法排序继承于 Comparable JApplet(init()方法中接收来自html页面上的参数). 通过setName(String str);为继承Thread的子类的线程初始化名字. equals();方法比较的是两个字符串的内容是否相等.而 == 符号比较的是: 两个字符串的地址是否相同. 当程序中涉及鼠标点击事件需要继承MouseAdapter类来对鼠标做出的动作进行相应的回应 ! paint(Graphics g),调用 g.drawOval();可以画同心圆. Applet中绘制指定文本字符串使用：drawString(); Java中String类提供了charAt();方法遍历每个字符. 常用布局管理器 FlowLayout,BorderLayout,GridLayout,CardLayout,GridBagLayout. 注意: JLabel对象可以显示文本,图像或同时显示两者,创建对象时,在构造函数中输入要显示的对象即可. getContentPane();方法获得JFrame的内容面板. getSource(); 找到给定名称的资源. frame.pack();-Method in class java.awt. Window. 使此窗口的大小适合其子组件的首选大小和布局. JPanel是Java图形用户界面(GUI)工具包swing中的面板容器类,包含于javax.swing包,是一种轻量级容器,可以加入到JFrame窗体中,所以我们 需要继承此类作为画板供JFrame类来操作 通过鼠标点击获取相应的请求命令方法为: e.getActionCommand(); beep() - Method in class java.awt. Toolkit. 根据本地系统设置和硬件功能发出音频蜂鸣声. for example: Toolkit.getDefaultToolkit().beep(); drawRect(int, int, int, int) - Method in class java.awt.Graphics 绘制指定矩形的轮廓. DataOutputStream 数据输出流允许应用程序以机器无关方式将Java基本数据类型写到底层输出流, DataInputStream 类提供readChar();方法来读取文件中的字符. Java IO 123 System.getProperty(\"user.dir\"); 获取当前的工作路径.getName(); 方法获取文件名，getPath();获取文件路径.isDirectory(); 判断是否是文件. extends Thread 与 implements Runnable 使用 123456789101112 当通过`implements Runnable`创建线程:将实现了Runnable接口的对象作为`target`参数传递给Thread类即可,格式如下:new Thread(`实现了Runnable接口的对象名`);举例: public class Java_2 implements Runnable &#123; public static void main(String[]args) &#123; Java_2 r = new Java_2(); Thread t = new Thread( r ); t.start(); &#125;··· 通过`extends Thread`创建线程:Thread本身实现了`Runnable`接口,重写其`run()`方法即可;线程创建后,需要调用`start();`方法运行. 12345setPreferredSize(new Dimension(280, 60));public void setPreferredSize(Dimension preferredSize)&#123;...&#125;将此组件的首选大小设置为常量值. 随后`getPreferredSize()`总是返回此值.将首选大小设置为`null`可恢复默认行为. `Dimension` : 类封装单个对象中组件的宽度和高度(以整数精度). DecimalFormat类提供的format();方法可以将数据格式化. 123public class DecimalFormat extends NumberFormatDecimalFormat()&#123;...&#125;`DecimalFormat`是格式为十进制数的NumberFormat的具体子类. 它具有各种功能,旨在使任何地区的数字解析和格式化,包括支持西方,阿拉伯语和印度数字。它还支持不同类型的数字,包括整数(123..),定点数(123.4),科学记数法(1.23E4),百分比(12％),和货币金额(123美元),所有这些都可以进行本地化. 窗体事件 1234setDefaultCloseOperation(); 设置用户在此窗口上发起\"close\"时默认执行操作.JFrame.EXIT_ON_CLOSE; `close`式关闭程序退出窗口.for example: frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 常用事件类 12345public void addActionListener(ActionListener e)&#123;..&#125;添加指定的动作侦听器以从此按钮接收动作事件.当用户按下或释放鼠标在此按钮上时,会发生动作事件.如果`e`为空,则不会抛出任何异常.也不会执行任何操作.for example: saveButton.addActionListener(this); 哎哟终于写好了 ! 伸个懒腰 ٩(๑❛ᴗ❛๑)۶ ~ 最近没零花钱买麦斯威尔了,然后每天的状态就像下面的俺的小黄人一样 ╰( ´・ω・)つ──☆✿✿✿ 后期有时间还写推出NCRE-MySQL,NCRE-C,NCRE-三级数据库等全国计算机等考题目解析 ! 最近忙于备考,所以先写作先放一放 ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"NCRE","slug":"NCRE","permalink":"http://yoursite.com/tags/NCRE/"}]},{"title":"JDBC 常见错误分析","slug":"JDBC-常见错误分析","date":"2019-03-14T11:32:12.000Z","updated":"2019-03-14T14:02:20.028Z","comments":true,"path":"2019/03/14/JDBC-常见错误分析/","link":"","permalink":"http://yoursite.com/2019/03/14/JDBC-常见错误分析/","excerpt":"","text":"JDBC ( Java Database Connectivity ) 常见错误分析今遇到一个网友问到JDBC中一个常见的错误,让我想起了大一时自己学习JDBC时整理的文档,继而公布出来分享给大家. 根据不同问题给出相应的解析问题一 : 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);错误 程序报错信息123456Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. ()...[译文如下]加载类 'com.mysql.jdbc.Driver' 这是不赞成的.新的驱动程序类是 'com.mysql.cj.jdbc.Driver' 驱动程序.驱动程序是通过SPI自动注册的，并且手动加载驱动类通常是不必要的... 解析123新版的驱动类位置有了变化(不影响使用，但会报警告) 旧版连接(MySQL Connection/J 5.x) ——&gt; jdbc.url = com.mysql.jdbc.Driver 新版连接(MySQL Connection/J 6.x) ——&gt; jdbc.url= com.mysql.cj.jdbc.Driver 解决方案1将 \"com.mysql.jdbc.Driver\" 改成 \"com.mysql.cj.jdbc.Driver\" . 问题二 ：连接错误 程序报错信息1234SunAug 19 17:39:12 CST 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServer Certificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.[译文如下]SunAug 19 17:39∶12 CST 2018警告：不建议建立没有服务器身份验证的SSL连接.根据MySQL 5.5.45 +、5.626+和5.7.6+的要求,如果没有设置显式选项，默认情况下必须建立SSL连接.对于不使用SSL的现有应用程序,'ValuyServer'证书属性设置为'false'.您需要通过设置'USESL=false'来显式禁用'SSL',或者设置'useSSL=true',并为服务器证书验证提供信任存储. 解析以及解决方案123由报错信息可得知,MySQL版本更新后的新特性: 如果连接数据库必须通过服务器的身份验证,当然上述已给出解决方案的建议. 方案一 ： 在url后加：useSSL=false; (简单易操作) 方案二 ： 在url后加：useSSL=true; (并未服务器证书验证提供信任存储) 问题三 ：时区错误 程序报错信息1234Exception in thread \"main\" java.sql.SQLException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.[译文如下]java.sql.SQLException ：服务器时区值 '？？±××？±？' 是不被识别的,或者表示一个以上的时区.如果要利用时区支持,必须配置服务器或JDBC驱动程序(通过 serverTimezone 配置属性)使用更具体的时区值. 解析及解决方案1为URL添加参数 serverTimezone=UTC 即可,这里的时区可以根据自己数据库的设定来设置（GMT/UTC ）. 问题四 ：当上述问题全部已经解决后可以正常连接数据库,但是如果重启MySQL服务器后重新连接数据库时发现报错！ 程序报错信息1java.sql.SQLNonTransientConnectionException: Public Key Retrieval is not allowed. 解决方案1在URL连接后添加 ： allowPublicKeyRetrieval = true 哎哟不知觉又在图书馆又待了一天..都不知已将近九点了,收拾下回寝室啦 ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Ubuntu18.04-Mac theme","slug":"Ubuntu18-04-Mac-theme","date":"2019-03-12T13:55:26.000Z","updated":"2019-03-21T10:54:40.705Z","comments":true,"path":"2019/03/12/Ubuntu18-04-Mac-theme/","link":"","permalink":"http://yoursite.com/2019/03/12/Ubuntu18-04-Mac-theme/","excerpt":"","text":"Ubuntu18.04 桌面美化( Mac theme )小哥哥我特意写了一些注意事项,可以提高效率,避免浪费时间哟 ~ 注意 ：千万不要认为在官网下载的包都是一个作用，继而导致后期不按规则存放解压后的包而发生 Tweak 无法识别装饰包的尴尬 !!! 在Ubuntu18.04 中美化桌面分为三个美化部分(装饰包也分为以下三种) 主题美化(Themes) (/usr/share/themes) shell主题美化(shell) (/usr/share/themes) 图标美化(icon) (/usr/share/icon) Ubuntu18.04发布以后不难发现其桌面发生了改版！Unity——&gt;Gnome,其实吧 : Gnomez桌面可自定制,美化后也非常酷 ~ 还有一个特别需要注意的问题：当执行以下命令安装中文名为 ‘优化’ 的软件后，你会发现在Extensions(扩展)选项中没有User themes ?!1sudo apt install gnome-tweak-tool 解决方案是你需要安装: Gnome-shell Extensions谈到这里俺要感谢一个篇写的超认真的CSDN博客,如果不想看官方文档/教程的话,她的这篇关于Ubuntu18.04美化桌面的博客是非常值得参考的,而且作者头像超美的哟(✪ω✪) ! GO ~ (建议)如果想要深入了解,最好去相应官方网站去看文档说明/指导,毕竟这才是原版,原汁原味 (っ•̀ω•́)っ✎⁾⁾ ~例如讲解 : HOW TO CUSTOMIZE GNOME 3 DESKTOP ENVIRONMENT ON UBUNTU 17.10 . GO ~ 关于如何使用 Gnome Shell 扩展，在此再给出一值得个参考学习的文章(作者写的超认真! 向这位学者致敬 ~). GO ~ 好啦 ~ 来 ! 感受一下我特爱的Ubuntu美化后的截图 ! 特美吧嘿嘿嘿 ~(◍´꒳`◍)~ 小伙伴们自定义Ubuntu桌面后是不是很开心呢 ! 请小哥哥我喝杯咖啡呗嘿嘿嘿 （づ￣3￣）づ╭❤～ 摘自我的CSDN博客,这篇博客是：2018/10/03 写的. CSDN主页 : https://blog.csdn.net/qq_43313515","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"Data structures and algorithm analysis in C","slug":"Data-structures-and-algorithm-analysis-in-C","date":"2019-03-12T11:04:44.000Z","updated":"2019-03-12T14:53:29.296Z","comments":true,"path":"2019/03/12/Data-structures-and-algorithm-analysis-in-C/","link":"","permalink":"http://yoursite.com/2019/03/12/Data-structures-and-algorithm-analysis-in-C/","excerpt":"","text":"数据结构与算法分析 - C语言描述著名计算机科学家沃思(Niklaus Wirth)曾提出一个程序公式：程序 = 数据结构 + 算法. 由此体现程序最美的灵魂所在 ~ 12345来! 小哥哥带大家体现一下`灵魂`的美 -(っ•̀ω•́)っ✎⁾⁾-约瑟夫问题(`Josephus problem `)是循环链表的一个典型应用,其描述如下: M个人围成一个圈,从其中任意一个人开始,按顺时针使所有人从一开始报数,报到N的人出列,然后使N之后的人接着从1开始报数,再次使报到N的人出列···如此下去,求出列的顺序及最后留下来的人的编号.很有趣的题目对吧! 小哥哥在这里简单实现一下哟 ~ Declare.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef _Josephus_problem_#define _Josephus_problem_ /*Simplify the code*/typedef struct Head *pHead;typedef struct Node *pNode; /*Define the header node*/struct Head&#123; int length; pNode next;&#125;;/*Define data nodes*/struct Node&#123; int data; pNode next;&#125;; /*DECLARE THE FUNCTION*//*CATCH THE EXCETPION*/void HeadIsNullException(pHead ph);/*CATCH THE EXCEPTION OF INPUT*/void InputIsUnresonable(int input);/*CREATE A CRICULAR LIST*/pHead Create();/*DETERMINE WHETHER THE LINK IS EMPTY*/int IsEmpty(pHead ph);/*INSET THE NODE INTO LINKE IN SPECIFIED POSITION*/int Insert(pHead ph, int position, int value);/*PRINT THE DATA OF NODE OF ALL*/void print(pHead ph);/*THE HEART OF ALGORITHM*/void The_Heart_Of_Algorithm_(pHead ph, int n); #endif Functions.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include \"Declare.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /*CATCH THE EXCEPTION OF CIRCULAR LINK*/void HeadIsNullException(pHead ph)&#123; if (ph == NULL) printf(\"ERROR : THE NODE HEAD IS NULL !\\n\");&#125; /*CATCH THE EXCEPTION OF INPUT*/void InputIsUnresonable(int input)&#123; if (input &lt; 0) printf(\"ERROR : THE NUMBER THAT YOU ENTERED IS UNREASONABLE !\\n\");&#125; /*CREATE A CIRCULAR LIST*/pHead Create()&#123; pHead ph = (pHead)malloc(sizeof(struct Head)); HeadIsNullException(ph); ph-&gt;length = 0; ph-&gt;next = NULL; return ph;&#125; /*DETERMINE WHETHER THE LINK IS EMPTY*/int IsEmpty(pHead ph)&#123; HeadIsNullException(ph); if (ph-&gt;length == 0) return 1; else return 0;&#125; /*INSERT THE NODE INTO LINK IN SPECIFIED POSITION*/int Insert(pHead ph, int position, int value)&#123; if (ph == NULL || position &lt; 0 || position &gt; ph-&gt;length) printf(\"ERROR : Insertion anomaly !\"); pNode p_value = (pNode)malloc(sizeof(struct Node)); p_value-&gt;data = value; //--(っ•̀ω•́)っ✎⁾⁾-- TO DETERMINE THE INSERTION POSITION. //FIRST DETERMINE WHETHER THE LIST IS EMPTY. if (IsEmpty(ph)) &#123; ph-&gt;next = p_value; p_value-&gt;next = p_value; //o(*￣︶￣*)o ~ YOU ARE NOT ALONE .. &#125; else &#123; //INSERT IN THT FIST POSITION. pNode p_node = ph-&gt;next; if (position == 0) &#123; //FIND THE LAST NODE. while (p_node-&gt;next != ph-&gt;next) p_node = p_node-&gt;next; p_value-&gt;next = ph-&gt;next; ph-&gt;next = p_value; p_node-&gt;next = p_value; &#125; else &#123; pNode p_node_ = ph-&gt;next; for (int i = 1; i &lt; position; i++) p_node_ = p_node_-&gt;next; p_value-&gt;next = p_node_-&gt;next; p_node_-&gt;next = p_value; &#125; &#125; ph-&gt;length++; return 1;&#125; /*PRINT THE DATA OF NODE OF ALL*/void print(pHead ph)&#123; if (ph == NULL || ph-&gt;length == 0) printf(\"ERROR : THE LENGTH OF LIST IS ZERO !\"); pNode pTemp = ph-&gt;next; for (int i = 0; i &lt; ph-&gt;length; i++) &#123; printf(\"%d \", pTemp-&gt;data); pTemp = pTemp-&gt;next; &#125; printf(\"\\n\");&#125; /*THE HEART OF ALGORITHM*/void The_Heart_Of_Algorithm_(pHead ph,int n)&#123; pNode node = ph-&gt;next; while (node-&gt;next != node) //KEEP THE LAST NODE. &#123; for (int i = 1; i &lt; n - 1; i++) node = node-&gt;next; pNode pTemp = node-&gt;next; //--(っ•̀ω•́)っ✎⁾⁾--DETERMINE THE LOCATION OF NODE. //First, determine if the position of this node is zero. if (pTemp == ph-&gt;next) &#123; ph-&gt;next = pTemp-&gt;next; node-&gt;next = pTemp-&gt;next; printf(\"%d \", pTemp-&gt;data); free(pTemp); ph-&gt;length--; &#125; //Second, the position of this node is others. else &#123; node-&gt;next = pTemp-&gt;next; printf(\"%d \", pTemp-&gt;data); free(pTemp); ph-&gt;length--; &#125; node = node-&gt;next; &#125; node-&gt;next = node; //YOU ARE NOT ALONE ~(*^▽^*)~ printf(\"\\n\");&#125; Main.c 1234567891011121314151617181920212223242526272829303132333435363738#include \"Declare.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[])&#123; int m, n; /*INITIALIZED DATA*/ printf(\"Please enter the total number of peoples of Josphus problem :\\n\"); scanf(\"%d\", &amp;m); InputIsUnresonable(m); printf(\"Please enter the index of node which you want to delete :\\n\"); scanf(\"%d\", &amp;n); InputIsUnresonable(n); /*CREATE A CRICULAR LIST*/ pHead ph = NULL; //&lt;—————————— 'INITIALIZED THE CIRCULAR LINK'. ph = Create(); HeadIsNullException(ph); for (int i = m; i &gt; 0; i--) Insert(ph, 0, i); printf(\"\\n\"); printf(\"--- The data of all node inserted by you. ---\\n\"); print(ph); /*--- THE HEART OF ALGORITHM ---*/ printf(\"--- out put the order of the loop list ---\\n\"); The_Heart_Of_Algorithm_(ph, n); /*FINAL RESULT*/ printf(\"--- THE LAST OF NODE ---\\n\"); print(ph); system(\"pause\"); return 0;&#125; The result of a program running 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Please enter the total number of peoples of Josphus problem :10000Please enter the index of node which you want to delete :6 --- The data of all node inserted by you. ---1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 3751 3752 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 4232 4233 4234 4235 4236 4237 4238 4239 4240 4241 4242 4243 4244 4245 4246 4247 4248 4249 4250 4251 4252 4253 4254 4255 4256 4257 4258 4259 4260 4261 4262 4263 4264 4265 4266 4267 4268 4269 4270 4271 4272 4273 4274 4275 4276 4277 4278 4279 4280 4281 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 4333 4334 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 4409 4410 4411 4412 4413 4414 4415 4416 4417 4418 4419 4420 4421 4422 4423 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011 5012 5013 5014 5015 5016 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 5150 5151 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446 5447 5448 5449 5450 5451 5452 5453 5454 5455 5456 5457 5458 5459 5460 5461 5462 5463 5464 5465 5466 5467 5468 5469 5470 5471 5472 5473 5474 5475 5476 5477 5478 5479 5480 5481 5482 5483 5484 5485 5486 5487 5488 5489 5490 5491 5492 5493 5494 5495 5496 5497 5498 5499 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5518 5519 5520 5521 5522 5523 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 5576 5577 5578 5579 5580 5581 5582 5583 5584 5585 5586 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 5639 5640 5641 5642 5643 5644 5645 5646 5647 5648 5649 5650 5651 5652 5653 5654 5655 5656 5657 5658 5659 5660 5661 5662 5663 5664 5665 5666 5667 5668 5669 5670 5671 5672 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 5725 5726 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 5751 5752 5753 5754 5755 5756 5757 5758 5759 5760 5761 5762 5763 5764 5765 5766 5767 5768 5769 5770 5771 5772 5773 5774 5775 5776 5777 5778 5779 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 5838 5839 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 5871 5872 5873 5874 5875 5876 5877 5878 5879 5880 5881 5882 5883 5884 5885 5886 5887 5888 5889 5890 5891 5892 5893 5894 5895 5896 5897 5898 5899 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 5936 5937 5938 5939 5940 5941 5942 5943 5944 5945 5946 5947 5948 5949 5950 5951 5952 5953 5954 5955 5956 5957 5958 5959 5960 5961 5962 5963 5964 5965 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 5991 5992 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6010 6011 6012 6013 6014 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 6044 6045 6046 6047 6048 6049 6050 6051 6052 6053 6054 6055 6056 6057 6058 6059 6060 6061 6062 6063 6064 6065 6066 6067 6068 6069 6070 6071 6072 6073 6074 6075 6076 6077 6078 6079 6080 6081 6082 6083 6084 6085 6086 6087 6088 6089 6090 6091 6092 6093 6094 6095 6096 6097 6098 6099 6100 6101 6102 6103 6104 6105 6106 6107 6108 6109 6110 6111 6112 6113 6114 6115 6116 6117 6118 6119 6120 6121 6122 6123 6124 6125 6126 6127 6128 6129 6130 6131 6132 6133 6134 6135 6136 6137 6138 6139 6140 6141 6142 6143 6144 6145 6146 6147 6148 6149 6150 6151 6152 6153 6154 6155 6156 6157 6158 6159 6160 6161 6162 6163 6164 6165 6166 6167 6168 6169 6170 6171 6172 6173 6174 6175 6176 6177 6178 6179 6180 6181 6182 6183 6184 6185 6186 6187 6188 6189 6190 6191 6192 6193 6194 6195 6196 6197 6198 6199 6200 6201 6202 6203 6204 6205 6206 6207 6208 6209 6210 6211 6212 6213 6214 6215 6216 6217 6218 6219 6220 6221 6222 6223 6224 6225 6226 6227 6228 6229 6230 6231 6232 6233 6234 6235 6236 6237 6238 6239 6240 6241 6242 6243 6244 6245 6246 6247 6248 6249 6250 6251 6252 6253 6254 6255 6256 6257 6258 6259 6260 6261 6262 6263 6264 6265 6266 6267 6268 6269 6270 6271 6272 6273 6274 6275 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 6289 6290 6291 6292 6293 6294 6295 6296 6297 6298 6299 6300 6301 6302 6303 6304 6305 6306 6307 6308 6309 6310 6311 6312 6313 6314 6315 6316 6317 6318 6319 6320 6321 6322 6323 6324 6325 6326 6327 6328 6329 6330 6331 6332 6333 6334 6335 6336 6337 6338 6339 6340 6341 6342 6343 6344 6345 6346 6347 6348 6349 6350 6351 6352 6353 6354 6355 6356 6357 6358 6359 6360 6361 6362 6363 6364 6365 6366 6367 6368 6369 6370 6371 6372 6373 6374 6375 6376 6377 6378 6379 6380 6381 6382 6383 6384 6385 6386 6387 6388 6389 6390 6391 6392 6393 6394 6395 6396 6397 6398 6399 6400 6401 6402 6403 6404 6405 6406 6407 6408 6409 6410 6411 6412 6413 6414 6415 6416 6417 6418 6419 6420 6421 6422 6423 6424 6425 6426 6427 6428 6429 6430 6431 6432 6433 6434 6435 6436 6437 6438 6439 6440 6441 6442 6443 6444 6445 6446 6447 6448 6449 6450 6451 6452 6453 6454 6455 6456 6457 6458 6459 6460 6461 6462 6463 6464 6465 6466 6467 6468 6469 6470 6471 6472 6473 6474 6475 6476 6477 6478 6479 6480 6481 6482 6483 6484 6485 6486 6487 6488 6489 6490 6491 6492 6493 6494 6495 6496 6497 6498 6499 6500 6501 6502 6503 6504 6505 6506 6507 6508 6509 6510 6511 6512 6513 6514 6515 6516 6517 6518 6519 6520 6521 6522 6523 6524 6525 6526 6527 6528 6529 6530 6531 6532 6533 6534 6535 6536 6537 6538 6539 6540 6541 6542 6543 6544 6545 6546 6547 6548 6549 6550 6551 6552 6553 6554 6555 6556 6557 6558 6559 6560 6561 6562 6563 6564 6565 6566 6567 6568 6569 6570 6571 6572 6573 6574 6575 6576 6577 6578 6579 6580 6581 6582 6583 6584 6585 6586 6587 6588 6589 6590 6591 6592 6593 6594 6595 6596 6597 6598 6599 6600 6601 6602 6603 6604 6605 6606 6607 6608 6609 6610 6611 6612 6613 6614 6615 6616 6617 6618 6619 6620 6621 6622 6623 6624 6625 6626 6627 6628 6629 6630 6631 6632 6633 6634 6635 6636 6637 6638 6639 6640 6641 6642 6643 6644 6645 6646 6647 6648 6649 6650 6651 6652 6653 6654 6655 6656 6657 6658 6659 6660 6661 6662 6663 6664 6665 6666 6667 6668 6669 6670 6671 6672 6673 6674 6675 6676 6677 6678 6679 6680 6681 6682 6683 6684 6685 6686 6687 6688 6689 6690 6691 6692 6693 6694 6695 6696 6697 6698 6699 6700 6701 6702 6703 6704 6705 6706 6707 6708 6709 6710 6711 6712 6713 6714 6715 6716 6717 6718 6719 6720 6721 6722 6723 6724 6725 6726 6727 6728 6729 6730 6731 6732 6733 6734 6735 6736 6737 6738 6739 6740 6741 6742 6743 6744 6745 6746 6747 6748 6749 6750 6751 6752 6753 6754 6755 6756 6757 6758 6759 6760 6761 6762 6763 6764 6765 6766 6767 6768 6769 6770 6771 6772 6773 6774 6775 6776 6777 6778 6779 6780 6781 6782 6783 6784 6785 6786 6787 6788 6789 6790 6791 6792 6793 6794 6795 6796 6797 6798 6799 6800 6801 6802 6803 6804 6805 6806 6807 6808 6809 6810 6811 6812 6813 6814 6815 6816 6817 6818 6819 6820 6821 6822 6823 6824 6825 6826 6827 6828 6829 6830 6831 6832 6833 6834 6835 6836 6837 6838 6839 6840 6841 6842 6843 6844 6845 6846 6847 6848 6849 6850 6851 6852 6853 6854 6855 6856 6857 6858 6859 6860 6861 6862 6863 6864 6865 6866 6867 6868 6869 6870 6871 6872 6873 6874 6875 6876 6877 6878 6879 6880 6881 6882 6883 6884 6885 6886 6887 6888 6889 6890 6891 6892 6893 6894 6895 6896 6897 6898 6899 6900 6901 6902 6903 6904 6905 6906 6907 6908 6909 6910 6911 6912 6913 6914 6915 6916 6917 6918 6919 6920 6921 6922 6923 6924 6925 6926 6927 6928 6929 6930 6931 6932 6933 6934 6935 6936 6937 6938 6939 6940 6941 6942 6943 6944 6945 6946 6947 6948 6949 6950 6951 6952 6953 6954 6955 6956 6957 6958 6959 6960 6961 6962 6963 6964 6965 6966 6967 6968 6969 6970 6971 6972 6973 6974 6975 6976 6977 6978 6979 6980 6981 6982 6983 6984 6985 6986 6987 6988 6989 6990 6991 6992 6993 6994 6995 6996 6997 6998 6999 7000 7001 7002 7003 7004 7005 7006 7007 7008 7009 7010 7011 7012 7013 7014 7015 7016 7017 7018 7019 7020 7021 7022 7023 7024 7025 7026 7027 7028 7029 7030 7031 7032 7033 7034 7035 7036 7037 7038 7039 7040 7041 7042 7043 7044 7045 7046 7047 7048 7049 7050 7051 7052 7053 7054 7055 7056 7057 7058 7059 7060 7061 7062 7063 7064 7065 7066 7067 7068 7069 7070 7071 7072 7073 7074 7075 7076 7077 7078 7079 7080 7081 7082 7083 7084 7085 7086 7087 7088 7089 7090 7091 7092 7093 7094 7095 7096 7097 7098 7099 7100 7101 7102 7103 7104 7105 7106 7107 7108 7109 7110 7111 7112 7113 7114 7115 7116 7117 7118 7119 7120 7121 7122 7123 7124 7125 7126 7127 7128 7129 7130 7131 7132 7133 7134 7135 7136 7137 7138 7139 7140 7141 7142 7143 7144 7145 7146 7147 7148 7149 7150 7151 7152 7153 7154 7155 7156 7157 7158 7159 7160 7161 7162 7163 7164 7165 7166 7167 7168 7169 7170 7171 7172 7173 7174 7175 7176 7177 7178 7179 7180 7181 7182 7183 7184 7185 7186 7187 7188 7189 7190 7191 7192 7193 7194 7195 7196 7197 7198 7199 7200 7201 7202 7203 7204 7205 7206 7207 7208 7209 7210 7211 7212 7213 7214 7215 7216 7217 7218 7219 7220 7221 7222 7223 7224 7225 7226 7227 7228 7229 7230 7231 7232 7233 7234 7235 7236 7237 7238 7239 7240 7241 7242 7243 7244 7245 7246 7247 7248 7249 7250 7251 7252 7253 7254 7255 7256 7257 7258 7259 7260 7261 7262 7263 7264 7265 7266 7267 7268 7269 7270 7271 7272 7273 7274 7275 7276 7277 7278 7279 7280 7281 7282 7283 7284 7285 7286 7287 7288 7289 7290 7291 7292 7293 7294 7295 7296 7297 7298 7299 7300 7301 7302 7303 7304 7305 7306 7307 7308 7309 7310 7311 7312 7313 7314 7315 7316 7317 7318 7319 7320 7321 7322 7323 7324 7325 7326 7327 7328 7329 7330 7331 7332 7333 7334 7335 7336 7337 7338 7339 7340 7341 7342 7343 7344 7345 7346 7347 7348 7349 7350 7351 7352 7353 7354 7355 7356 7357 7358 7359 7360 7361 7362 7363 7364 7365 7366 7367 7368 7369 7370 7371 7372 7373 7374 7375 7376 7377 7378 7379 7380 7381 7382 7383 7384 7385 7386 7387 7388 7389 7390 7391 7392 7393 7394 7395 7396 7397 7398 7399 7400 7401 7402 7403 7404 7405 7406 7407 7408 7409 7410 7411 7412 7413 7414 7415 7416 7417 7418 7419 7420 7421 7422 7423 7424 7425 7426 7427 7428 7429 7430 7431 7432 7433 7434 7435 7436 7437 7438 7439 7440 7441 7442 7443 7444 7445 7446 7447 7448 7449 7450 7451 7452 7453 7454 7455 7456 7457 7458 7459 7460 7461 7462 7463 7464 7465 7466 7467 7468 7469 7470 7471 7472 7473 7474 7475 7476 7477 7478 7479 7480 7481 7482 7483 7484 7485 7486 7487 7488 7489 7490 7491 7492 7493 7494 7495 7496 7497 7498 7499 7500 7501 7502 7503 7504 7505 7506 7507 7508 7509 7510 7511 7512 7513 7514 7515 7516 7517 7518 7519 7520 7521 7522 7523 7524 7525 7526 7527 7528 7529 7530 7531 7532 7533 7534 7535 7536 7537 7538 7539 7540 7541 7542 7543 7544 7545 7546 7547 7548 7549 7550 7551 7552 7553 7554 7555 7556 7557 7558 7559 7560 7561 7562 7563 7564 7565 7566 7567 7568 7569 7570 7571 7572 7573 7574 7575 7576 7577 7578 7579 7580 7581 7582 7583 7584 7585 7586 7587 7588 7589 7590 7591 7592 7593 7594 7595 7596 7597 7598 7599 7600 7601 7602 7603 7604 7605 7606 7607 7608 7609 7610 7611 7612 7613 7614 7615 7616 7617 7618 7619 7620 7621 7622 7623 7624 7625 7626 7627 7628 7629 7630 7631 7632 7633 7634 7635 7636 7637 7638 7639 7640 7641 7642 7643 7644 7645 7646 7647 7648 7649 7650 7651 7652 7653 7654 7655 7656 7657 7658 7659 7660 7661 7662 7663 7664 7665 7666 7667 7668 7669 7670 7671 7672 7673 7674 7675 7676 7677 7678 7679 7680 7681 7682 7683 7684 7685 7686 7687 7688 7689 7690 7691 7692 7693 7694 7695 7696 7697 7698 7699 7700 7701 7702 7703 7704 7705 7706 7707 7708 7709 7710 7711 7712 7713 7714 7715 7716 7717 7718 7719 7720 7721 7722 7723 7724 7725 7726 7727 7728 7729 7730 7731 7732 7733 7734 7735 7736 7737 7738 7739 7740 7741 7742 7743 7744 7745 7746 7747 7748 7749 7750 7751 7752 7753 7754 7755 7756 7757 7758 7759 7760 7761 7762 7763 7764 7765 7766 7767 7768 7769 7770 7771 7772 7773 7774 7775 7776 7777 7778 7779 7780 7781 7782 7783 7784 7785 7786 7787 7788 7789 7790 7791 7792 7793 7794 7795 7796 7797 7798 7799 7800 7801 7802 7803 7804 7805 7806 7807 7808 7809 7810 7811 7812 7813 7814 7815 7816 7817 7818 7819 7820 7821 7822 7823 7824 7825 7826 7827 7828 7829 7830 7831 7832 7833 7834 7835 7836 7837 7838 7839 7840 7841 7842 7843 7844 7845 7846 7847 7848 7849 7850 7851 7852 7853 7854 7855 7856 7857 7858 7859 7860 7861 7862 7863 7864 7865 7866 7867 7868 7869 7870 7871 7872 7873 7874 7875 7876 7877 7878 7879 7880 7881 7882 7883 7884 7885 7886 7887 7888 7889 7890 7891 7892 7893 7894 7895 7896 7897 7898 7899 7900 7901 7902 7903 7904 7905 7906 7907 7908 7909 7910 7911 7912 7913 7914 7915 7916 7917 7918 7919 7920 7921 7922 7923 7924 7925 7926 7927 7928 7929 7930 7931 7932 7933 7934 7935 7936 7937 7938 7939 7940 7941 7942 7943 7944 7945 7946 7947 7948 7949 7950 7951 7952 7953 7954 7955 7956 7957 7958 7959 7960 7961 7962 7963 7964 7965 7966 7967 7968 7969 7970 7971 7972 7973 7974 7975 7976 7977 7978 7979 7980 7981 7982 7983 7984 7985 7986 7987 7988 7989 7990 7991 7992 7993 7994 7995 7996 7997 7998 7999 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020 8021 8022 8023 8024 8025 8026 8027 8028 8029 8030 8031 8032 8033 8034 8035 8036 8037 8038 8039 8040 8041 8042 8043 8044 8045 8046 8047 8048 8049 8050 8051 8052 8053 8054 8055 8056 8057 8058 8059 8060 8061 8062 8063 8064 8065 8066 8067 8068 8069 8070 8071 8072 8073 8074 8075 8076 8077 8078 8079 8080 8081 8082 8083 8084 8085 8086 8087 8088 8089 8090 8091 8092 8093 8094 8095 8096 8097 8098 8099 8100 8101 8102 8103 8104 8105 8106 8107 8108 8109 8110 8111 8112 8113 8114 8115 8116 8117 8118 8119 8120 8121 8122 8123 8124 8125 8126 8127 8128 8129 8130 8131 8132 8133 8134 8135 8136 8137 8138 8139 8140 8141 8142 8143 8144 8145 8146 8147 8148 8149 8150 8151 8152 8153 8154 8155 8156 8157 8158 8159 8160 8161 8162 8163 8164 8165 8166 8167 8168 8169 8170 8171 8172 8173 8174 8175 8176 8177 8178 8179 8180 8181 8182 8183 8184 8185 8186 8187 8188 8189 8190 8191 8192 8193 8194 8195 8196 8197 8198 8199 8200 8201 8202 8203 8204 8205 8206 8207 8208 8209 8210 8211 8212 8213 8214 8215 8216 8217 8218 8219 8220 8221 8222 8223 8224 8225 8226 8227 8228 8229 8230 8231 8232 8233 8234 8235 8236 8237 8238 8239 8240 8241 8242 8243 8244 8245 8246 8247 8248 8249 8250 8251 8252 8253 8254 8255 8256 8257 8258 8259 8260 8261 8262 8263 8264 8265 8266 8267 8268 8269 8270 8271 8272 8273 8274 8275 8276 8277 8278 8279 8280 8281 8282 8283 8284 8285 8286 8287 8288 8289 8290 8291 8292 8293 8294 8295 8296 8297 8298 8299 8300 8301 8302 8303 8304 8305 8306 8307 8308 8309 8310 8311 8312 8313 8314 8315 8316 8317 8318 8319 8320 8321 8322 8323 8324 8325 8326 8327 8328 8329 8330 8331 8332 8333 8334 8335 8336 8337 8338 8339 8340 8341 8342 8343 8344 8345 8346 8347 8348 8349 8350 8351 8352 8353 8354 8355 8356 8357 8358 8359 8360 8361 8362 8363 8364 8365 8366 8367 8368 8369 8370 8371 8372 8373 8374 8375 8376 8377 8378 8379 8380 8381 8382 8383 8384 8385 8386 8387 8388 8389 8390 8391 8392 8393 8394 8395 8396 8397 8398 8399 8400 8401 8402 8403 8404 8405 8406 8407 8408 8409 8410 8411 8412 8413 8414 8415 8416 8417 8418 8419 8420 8421 8422 8423 8424 8425 8426 8427 8428 8429 8430 8431 8432 8433 8434 8435 8436 8437 8438 8439 8440 8441 8442 8443 8444 8445 8446 8447 8448 8449 8450 8451 8452 8453 8454 8455 8456 8457 8458 8459 8460 8461 8462 8463 8464 8465 8466 8467 8468 8469 8470 8471 8472 8473 8474 8475 8476 8477 8478 8479 8480 8481 8482 8483 8484 8485 8486 8487 8488 8489 8490 8491 8492 8493 8494 8495 8496 8497 8498 8499 8500 8501 8502 8503 8504 8505 8506 8507 8508 8509 8510 8511 8512 8513 8514 8515 8516 8517 8518 8519 8520 8521 8522 8523 8524 8525 8526 8527 8528 8529 8530 8531 8532 8533 8534 8535 8536 8537 8538 8539 8540 8541 8542 8543 8544 8545 8546 8547 8548 8549 8550 8551 8552 8553 8554 8555 8556 8557 8558 8559 8560 8561 8562 8563 8564 8565 8566 8567 8568 8569 8570 8571 8572 8573 8574 8575 8576 8577 8578 8579 8580 8581 8582 8583 8584 8585 8586 8587 8588 8589 8590 8591 8592 8593 8594 8595 8596 8597 8598 8599 8600 8601 8602 8603 8604 8605 8606 8607 8608 8609 8610 8611 8612 8613 8614 8615 8616 8617 8618 8619 8620 8621 8622 8623 8624 8625 8626 8627 8628 8629 8630 8631 8632 8633 8634 8635 8636 8637 8638 8639 8640 8641 8642 8643 8644 8645 8646 8647 8648 8649 8650 8651 8652 8653 8654 8655 8656 8657 8658 8659 8660 8661 8662 8663 8664 8665 8666 8667 8668 8669 8670 8671 8672 8673 8674 8675 8676 8677 8678 8679 8680 8681 8682 8683 8684 8685 8686 8687 8688 8689 8690 8691 8692 8693 8694 8695 8696 8697 8698 8699 8700 8701 8702 8703 8704 8705 8706 8707 8708 8709 8710 8711 8712 8713 8714 8715 8716 8717 8718 8719 8720 8721 8722 8723 8724 8725 8726 8727 8728 8729 8730 8731 8732 8733 8734 8735 8736 8737 8738 8739 8740 8741 8742 8743 8744 8745 8746 8747 8748 8749 8750 8751 8752 8753 8754 8755 8756 8757 8758 8759 8760 8761 8762 8763 8764 8765 8766 8767 8768 8769 8770 8771 8772 8773 8774 8775 8776 8777 8778 8779 8780 8781 8782 8783 8784 8785 8786 8787 8788 8789 8790 8791 8792 8793 8794 8795 8796 8797 8798 8799 8800 8801 8802 8803 8804 8805 8806 8807 8808 8809 8810 8811 8812 8813 8814 8815 8816 8817 8818 8819 8820 8821 8822 8823 8824 8825 8826 8827 8828 8829 8830 8831 8832 8833 8834 8835 8836 8837 8838 8839 8840 8841 8842 8843 8844 8845 8846 8847 8848 8849 8850 8851 8852 8853 8854 8855 8856 8857 8858 8859 8860 8861 8862 8863 8864 8865 8866 8867 8868 8869 8870 8871 8872 8873 8874 8875 8876 8877 8878 8879 8880 8881 8882 8883 8884 8885 8886 8887 8888 8889 8890 8891 8892 8893 8894 8895 8896 8897 8898 8899 8900 8901 8902 8903 8904 8905 8906 8907 8908 8909 8910 8911 8912 8913 8914 8915 8916 8917 8918 8919 8920 8921 8922 8923 8924 8925 8926 8927 8928 8929 8930 8931 8932 8933 8934 8935 8936 8937 8938 8939 8940 8941 8942 8943 8944 8945 8946 8947 8948 8949 8950 8951 8952 8953 8954 8955 8956 8957 8958 8959 8960 8961 8962 8963 8964 8965 8966 8967 8968 8969 8970 8971 8972 8973 8974 8975 8976 8977 8978 8979 8980 8981 8982 8983 8984 8985 8986 8987 8988 8989 8990 8991 8992 8993 8994 8995 8996 8997 8998 8999 9000 9001 9002 9003 9004 9005 9006 9007 9008 9009 9010 9011 9012 9013 9014 9015 9016 9017 9018 9019 9020 9021 9022 9023 9024 9025 9026 9027 9028 9029 9030 9031 9032 9033 9034 9035 9036 9037 9038 9039 9040 9041 9042 9043 9044 9045 9046 9047 9048 9049 9050 9051 9052 9053 9054 9055 9056 9057 9058 9059 9060 9061 9062 9063 9064 9065 9066 9067 9068 9069 9070 9071 9072 9073 9074 9075 9076 9077 9078 9079 9080 9081 9082 9083 9084 9085 9086 9087 9088 9089 9090 9091 9092 9093 9094 9095 9096 9097 9098 9099 9100 9101 9102 9103 9104 9105 9106 9107 9108 9109 9110 9111 9112 9113 9114 9115 9116 9117 9118 9119 9120 9121 9122 9123 9124 9125 9126 9127 9128 9129 9130 9131 9132 9133 9134 9135 9136 9137 9138 9139 9140 9141 9142 9143 9144 9145 9146 9147 9148 9149 9150 9151 9152 9153 9154 9155 9156 9157 9158 9159 9160 9161 9162 9163 9164 9165 9166 9167 9168 9169 9170 9171 9172 9173 9174 9175 9176 9177 9178 9179 9180 9181 9182 9183 9184 9185 9186 9187 9188 9189 9190 9191 9192 9193 9194 9195 9196 9197 9198 9199 9200 9201 9202 9203 9204 9205 9206 9207 9208 9209 9210 9211 9212 9213 9214 9215 9216 9217 9218 9219 9220 9221 9222 9223 9224 9225 9226 9227 9228 9229 9230 9231 9232 9233 9234 9235 9236 9237 9238 9239 9240 9241 9242 9243 9244 9245 9246 9247 9248 9249 9250 9251 9252 9253 9254 9255 9256 9257 9258 9259 9260 9261 9262 9263 9264 9265 9266 9267 9268 9269 9270 9271 9272 9273 9274 9275 9276 9277 9278 9279 9280 9281 9282 9283 9284 9285 9286 9287 9288 9289 9290 9291 9292 9293 9294 9295 9296 9297 9298 9299 9300 9301 9302 9303 9304 9305 9306 9307 9308 9309 9310 9311 9312 9313 9314 9315 9316 9317 9318 9319 9320 9321 9322 9323 9324 9325 9326 9327 9328 9329 9330 9331 9332 9333 9334 9335 9336 9337 9338 9339 9340 9341 9342 9343 9344 9345 9346 9347 9348 9349 9350 9351 9352 9353 9354 9355 9356 9357 9358 9359 9360 9361 9362 9363 9364 9365 9366 9367 9368 9369 9370 9371 9372 9373 9374 9375 9376 9377 9378 9379 9380 9381 9382 9383 9384 9385 9386 9387 9388 9389 9390 9391 9392 9393 9394 9395 9396 9397 9398 9399 9400 9401 9402 9403 9404 9405 9406 9407 9408 9409 9410 9411 9412 9413 9414 9415 9416 9417 9418 9419 9420 9421 9422 9423 9424 9425 9426 9427 9428 9429 9430 9431 9432 9433 9434 9435 9436 9437 9438 9439 9440 9441 9442 9443 9444 9445 9446 9447 9448 9449 9450 9451 9452 9453 9454 9455 9456 9457 9458 9459 9460 9461 9462 9463 9464 9465 9466 9467 9468 9469 9470 9471 9472 9473 9474 9475 9476 9477 9478 9479 9480 9481 9482 9483 9484 9485 9486 9487 9488 9489 9490 9491 9492 9493 9494 9495 9496 9497 9498 9499 9500 9501 9502 9503 9504 9505 9506 9507 9508 9509 9510 9511 9512 9513 9514 9515 9516 9517 9518 9519 9520 9521 9522 9523 9524 9525 9526 9527 9528 9529 9530 9531 9532 9533 9534 9535 9536 9537 9538 9539 9540 9541 9542 9543 9544 9545 9546 9547 9548 9549 9550 9551 9552 9553 9554 9555 9556 9557 9558 9559 9560 9561 9562 9563 9564 9565 9566 9567 9568 9569 9570 9571 9572 9573 9574 9575 9576 9577 9578 9579 9580 9581 9582 9583 9584 9585 9586 9587 9588 9589 9590 9591 9592 9593 9594 9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9605 9606 9607 9608 9609 9610 9611 9612 9613 9614 9615 9616 9617 9618 9619 9620 9621 9622 9623 9624 9625 9626 9627 9628 9629 9630 9631 9632 9633 9634 9635 9636 9637 9638 9639 9640 9641 9642 9643 9644 9645 9646 9647 9648 9649 9650 9651 9652 9653 9654 9655 9656 9657 9658 9659 9660 9661 9662 9663 9664 9665 9666 9667 9668 9669 9670 9671 9672 9673 9674 9675 9676 9677 9678 9679 9680 9681 9682 9683 9684 9685 9686 9687 9688 9689 9690 9691 9692 9693 9694 9695 9696 9697 9698 9699 9700 9701 9702 9703 9704 9705 9706 9707 9708 9709 9710 9711 9712 9713 9714 9715 9716 9717 9718 9719 9720 9721 9722 9723 9724 9725 9726 9727 9728 9729 9730 9731 9732 9733 9734 9735 9736 9737 9738 9739 9740 9741 9742 9743 9744 9745 9746 9747 9748 9749 9750 9751 9752 9753 9754 9755 9756 9757 9758 9759 9760 9761 9762 9763 9764 9765 9766 9767 9768 9769 9770 9771 9772 9773 9774 9775 9776 9777 9778 9779 9780 9781 9782 9783 9784 9785 9786 9787 9788 9789 9790 9791 9792 9793 9794 9795 9796 9797 9798 9799 9800 9801 9802 9803 9804 9805 9806 9807 9808 9809 9810 9811 9812 9813 9814 9815 9816 9817 9818 9819 9820 9821 9822 9823 9824 9825 9826 9827 9828 9829 9830 9831 9832 9833 9834 9835 9836 9837 9838 9839 9840 9841 9842 9843 9844 9845 9846 9847 9848 9849 9850 9851 9852 9853 9854 9855 9856 9857 9858 9859 9860 9861 9862 9863 9864 9865 9866 9867 9868 9869 9870 9871 9872 9873 9874 9875 9876 9877 9878 9879 9880 9881 9882 9883 9884 9885 9886 9887 9888 9889 9890 9891 9892 9893 9894 9895 9896 9897 9898 9899 9900 9901 9902 9903 9904 9905 9906 9907 9908 9909 9910 9911 9912 9913 9914 9915 9916 9917 9918 9919 9920 9921 9922 9923 9924 9925 9926 9927 9928 9929 9930 9931 9932 9933 9934 9935 9936 9937 9938 9939 9940 9941 9942 9943 9944 9945 9946 9947 9948 9949 9950 9951 9952 9953 9954 9955 9956 9957 9958 9959 9960 9961 9962 9963 9964 9965 9966 9967 9968 9969 9970 9971 9972 9973 9974 9975 9976 9977 9978 9979 9980 9981 9982 9983 9984 9985 9986 9987 9988 9989 9990 9991 9992 9993 9994 9995 9996 9997 9998 9999 10000--- out put the order of the loop list ---6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96 102 108 114 120 126 132 138 144 150 156 162 168 174 180 186 192 198 204 210 216 222 228 234 240 246 252 258 264 270 276 282 288 294 300 306 312 318 324 330 336 342 348 354 360 366 372 378 384 390 396 402 408 414 420 426 432 438 444 450 456 462 468 474 480 486 492 498 504 510 516 522 528 534 540 546 552 558 564 570 576 582 588 594 600 606 612 618 624 630 636 642 648 654 660 666 672 678 684 690 696 702 708 714 720 726 732 738 744 750 756 762 768 774 780 786 792 798 804 810 816 822 828 834 840 846 852 858 864 870 876 882 888 894 900 906 912 918 924 930 936 942 948 954 960 966 972 978 984 990 996 1002 1008 1014 1020 1026 1032 1038 1044 1050 1056 1062 1068 1074 1080 1086 1092 1098 1104 1110 1116 1122 1128 1134 1140 1146 1152 1158 1164 1170 1176 1182 1188 1194 1200 1206 1212 1218 1224 1230 1236 1242 1248 1254 1260 1266 1272 1278 1284 1290 1296 1302 1308 1314 1320 1326 1332 1338 1344 1350 1356 1362 1368 1374 1380 1386 1392 1398 1404 1410 1416 1422 1428 1434 1440 1446 1452 1458 1464 1470 1476 1482 1488 1494 1500 1506 1512 1518 1524 1530 1536 1542 1548 1554 1560 1566 1572 1578 1584 1590 1596 1602 1608 1614 1620 1626 1632 1638 1644 1650 1656 1662 1668 1674 1680 1686 1692 1698 1704 1710 1716 1722 1728 1734 1740 1746 1752 1758 1764 1770 1776 1782 1788 1794 1800 1806 1812 1818 1824 1830 1836 1842 1848 1854 1860 1866 1872 1878 1884 1890 1896 1902 1908 1914 1920 1926 1932 1938 1944 1950 1956 1962 1968 1974 1980 1986 1992 1998 2004 2010 2016 2022 2028 2034 2040 2046 2052 2058 2064 2070 2076 2082 2088 2094 2100 2106 2112 2118 2124 2130 2136 2142 2148 2154 2160 2166 2172 2178 2184 2190 2196 2202 2208 2214 2220 2226 2232 2238 2244 2250 2256 2262 2268 2274 2280 2286 2292 2298 2304 2310 2316 2322 2328 2334 2340 2346 2352 2358 2364 2370 2376 2382 2388 2394 2400 2406 2412 2418 2424 2430 2436 2442 2448 2454 2460 2466 2472 2478 2484 2490 2496 2502 2508 2514 2520 2526 2532 2538 2544 2550 2556 2562 2568 2574 2580 2586 2592 2598 2604 2610 2616 2622 2628 2634 2640 2646 2652 2658 2664 2670 2676 2682 2688 2694 2700 2706 2712 2718 2724 2730 2736 2742 2748 2754 2760 2766 2772 2778 2784 2790 2796 2802 2808 2814 2820 2826 2832 2838 2844 2850 2856 2862 2868 2874 2880 2886 2892 2898 2904 2910 2916 2922 2928 2934 2940 2946 2952 2958 2964 2970 2976 2982 2988 2994 3000 3006 3012 3018 3024 3030 3036 3042 3048 3054 3060 3066 3072 3078 3084 3090 3096 3102 3108 3114 3120 3126 3132 3138 3144 3150 3156 3162 3168 3174 3180 3186 3192 3198 3204 3210 3216 3222 3228 3234 3240 3246 3252 3258 3264 3270 3276 3282 3288 3294 3300 3306 3312 3318 3324 3330 3336 3342 3348 3354 3360 3366 3372 3378 3384 3390 3396 3402 3408 3414 3420 3426 3432 3438 3444 3450 3456 3462 3468 3474 3480 3486 3492 3498 3504 3510 3516 3522 3528 3534 3540 3546 3552 3558 3564 3570 3576 3582 3588 3594 3600 3606 3612 3618 3624 3630 3636 3642 3648 3654 3660 3666 3672 3678 3684 3690 3696 3702 3708 3714 3720 3726 3732 3738 3744 3750 3756 3762 3768 3774 3780 3786 3792 3798 3804 3810 3816 3822 3828 3834 3840 3846 3852 3858 3864 3870 3876 3882 3888 3894 3900 3906 3912 3918 3924 3930 3936 3942 3948 3954 3960 3966 3972 3978 3984 3990 3996 4002 4008 4014 4020 4026 4032 4038 4044 4050 4056 4062 4068 4074 4080 4086 4092 4098 4104 4110 4116 4122 4128 4134 4140 4146 4152 4158 4164 4170 4176 4182 4188 4194 4200 4206 4212 4218 4224 4230 4236 4242 4248 4254 4260 4266 4272 4278 4284 4290 4296 4302 4308 4314 4320 4326 4332 4338 4344 4350 4356 4362 4368 4374 4380 4386 4392 4398 4404 4410 4416 4422 4428 4434 4440 4446 4452 4458 4464 4470 4476 4482 4488 4494 4500 4506 4512 4518 4524 4530 4536 4542 4548 4554 4560 4566 4572 4578 4584 4590 4596 4602 4608 4614 4620 4626 4632 4638 4644 4650 4656 4662 4668 4674 4680 4686 4692 4698 4704 4710 4716 4722 4728 4734 4740 4746 4752 4758 4764 4770 4776 4782 4788 4794 4800 4806 4812 4818 4824 4830 4836 4842 4848 4854 4860 4866 4872 4878 4884 4890 4896 4902 4908 4914 4920 4926 4932 4938 4944 4950 4956 4962 4968 4974 4980 4986 4992 4998 5004 5010 5016 5022 5028 5034 5040 5046 5052 5058 5064 5070 5076 5082 5088 5094 5100 5106 5112 5118 5124 5130 5136 5142 5148 5154 5160 5166 5172 5178 5184 5190 5196 5202 5208 5214 5220 5226 5232 5238 5244 5250 5256 5262 5268 5274 5280 5286 5292 5298 5304 5310 5316 5322 5328 5334 5340 5346 5352 5358 5364 5370 5376 5382 5388 5394 5400 5406 5412 5418 5424 5430 5436 5442 5448 5454 5460 5466 5472 5478 5484 5490 5496 5502 5508 5514 5520 5526 5532 5538 5544 5550 5556 5562 5568 5574 5580 5586 5592 5598 5604 5610 5616 5622 5628 5634 5640 5646 5652 5658 5664 5670 5676 5682 5688 5694 5700 5706 5712 5718 5724 5730 5736 5742 5748 5754 5760 5766 5772 5778 5784 5790 5796 5802 5808 5814 5820 5826 5832 5838 5844 5850 5856 5862 5868 5874 5880 5886 5892 5898 5904 5910 5916 5922 5928 5934 5940 5946 5952 5958 5964 5970 5976 5982 5988 5994 6000 6006 6012 6018 6024 6030 6036 6042 6048 6054 6060 6066 6072 6078 6084 6090 6096 6102 6108 6114 6120 6126 6132 6138 6144 6150 6156 6162 6168 6174 6180 6186 6192 6198 6204 6210 6216 6222 6228 6234 6240 6246 6252 6258 6264 6270 6276 6282 6288 6294 6300 6306 6312 6318 6324 6330 6336 6342 6348 6354 6360 6366 6372 6378 6384 6390 6396 6402 6408 6414 6420 6426 6432 6438 6444 6450 6456 6462 6468 6474 6480 6486 6492 6498 6504 6510 6516 6522 6528 6534 6540 6546 6552 6558 6564 6570 6576 6582 6588 6594 6600 6606 6612 6618 6624 6630 6636 6642 6648 6654 6660 6666 6672 6678 6684 6690 6696 6702 6708 6714 6720 6726 6732 6738 6744 6750 6756 6762 6768 6774 6780 6786 6792 6798 6804 6810 6816 6822 6828 6834 6840 6846 6852 6858 6864 6870 6876 6882 6888 6894 6900 6906 6912 6918 6924 6930 6936 6942 6948 6954 6960 6966 6972 6978 6984 6990 6996 7002 7008 7014 7020 7026 7032 7038 7044 7050 7056 7062 7068 7074 7080 7086 7092 7098 7104 7110 7116 7122 7128 7134 7140 7146 7152 7158 7164 7170 7176 7182 7188 7194 7200 7206 7212 7218 7224 7230 7236 7242 7248 7254 7260 7266 7272 7278 7284 7290 7296 7302 7308 7314 7320 7326 7332 7338 7344 7350 7356 7362 7368 7374 7380 7386 7392 7398 7404 7410 7416 7422 7428 7434 7440 7446 7452 7458 7464 7470 7476 7482 7488 7494 7500 7506 7512 7518 7524 7530 7536 7542 7548 7554 7560 7566 7572 7578 7584 7590 7596 7602 7608 7614 7620 7626 7632 7638 7644 7650 7656 7662 7668 7674 7680 7686 7692 7698 7704 7710 7716 7722 7728 7734 7740 7746 7752 7758 7764 7770 7776 7782 7788 7794 7800 7806 7812 7818 7824 7830 7836 7842 7848 7854 7860 7866 7872 7878 7884 7890 7896 7902 7908 7914 7920 7926 7932 7938 7944 7950 7956 7962 7968 7974 7980 7986 7992 7998 8004 8010 8016 8022 8028 8034 8040 8046 8052 8058 8064 8070 8076 8082 8088 8094 8100 8106 8112 8118 8124 8130 8136 8142 8148 8154 8160 8166 8172 8178 8184 8190 8196 8202 8208 8214 8220 8226 8232 8238 8244 8250 8256 8262 8268 8274 8280 8286 8292 8298 8304 8310 8316 8322 8328 8334 8340 8346 8352 8358 8364 8370 8376 8382 8388 8394 8400 8406 8412 8418 8424 8430 8436 8442 8448 8454 8460 8466 8472 8478 8484 8490 8496 8502 8508 8514 8520 8526 8532 8538 8544 8550 8556 8562 8568 8574 8580 8586 8592 8598 8604 8610 8616 8622 8628 8634 8640 8646 8652 8658 8664 8670 8676 8682 8688 8694 8700 8706 8712 8718 8724 8730 8736 8742 8748 8754 8760 8766 8772 8778 8784 8790 8796 8802 8808 8814 8820 8826 8832 8838 8844 8850 8856 8862 8868 8874 8880 8886 8892 8898 8904 8910 8916 8922 8928 8934 8940 8946 8952 8958 8964 8970 8976 8982 8988 8994 9000 9006 9012 9018 9024 9030 9036 9042 9048 9054 9060 9066 9072 9078 9084 9090 9096 9102 9108 9114 9120 9126 9132 9138 9144 9150 9156 9162 9168 9174 9180 9186 9192 9198 9204 9210 9216 9222 9228 9234 9240 9246 9252 9258 9264 9270 9276 9282 9288 9294 9300 9306 9312 9318 9324 9330 9336 9342 9348 9354 9360 9366 9372 9378 9384 9390 9396 9402 9408 9414 9420 9426 9432 9438 9444 9450 9456 9462 9468 9474 9480 9486 9492 9498 9504 9510 9516 9522 9528 9534 9540 9546 9552 9558 9564 9570 9576 9582 9588 9594 9600 9606 9612 9618 9624 9630 9636 9642 9648 9654 9660 9666 9672 9678 9684 9690 9696 9702 9708 9714 9720 9726 9732 9738 9744 9750 9756 9762 9768 9774 9780 9786 9792 9798 9804 9810 9816 9822 9828 9834 9840 9846 9852 9858 9864 9870 9876 9882 9888 9894 9900 9906 9912 9918 9924 9930 9936 9942 9948 9954 9960 9966 9972 9978 9984 9990 9996 2 9 16 23 31 38 45 52 59 67 74 81 88 95 103 110 117 124 131 139 146 153 160 167 175 182 189 196 203 211 218 225 232 239 247 254 261 268 275 283 290 297 304 311 319 326 333 340 347 355 362 369 376 383 391 398 405 412 419 427 434 441 448 455 463 470 477 484 491 499 506 513 520 527 535 542 549 556 563 571 578 585 592 599 607 614 621 628 635 643 650 657 664 671 679 686 693 700 707 715 722 729 736 743 751 758 765 772 779 787 794 801 808 815 823 830 837 844 851 859 866 873 880 887 895 902 909 916 923 931 938 945 952 959 967 974 981 988 995 1003 1010 1017 1024 1031 1039 1046 1053 1060 1067 1075 1082 1089 1096 1103 1111 1118 1125 1132 1139 1147 1154 1161 1168 1175 1183 1190 1197 1204 1211 1219 1226 1233 1240 1247 1255 1262 1269 1276 1283 1291 1298 1305 1312 1319 1327 1334 1341 1348 1355 1363 1370 1377 1384 1391 1399 1406 1413 1420 1427 1435 1442 1449 1456 1463 1471 1478 1485 1492 1499 1507 1514 1521 1528 1535 1543 1550 1557 1564 1571 1579 1586 1593 1600 1607 1615 1622 1629 1636 1643 1651 1658 1665 1672 1679 1687 1694 1701 1708 1715 1723 1730 1737 1744 1751 1759 1766 1773 1780 1787 1795 1802 1809 1816 1823 1831 1838 1845 1852 1859 1867 1874 1881 1888 1895 1903 1910 1917 1924 1931 1939 1946 1953 1960 1967 1975 1982 1989 1996 2003 2011 2018 2025 2032 2039 2047 2054 2061 2068 2075 2083 2090 2097 2104 2111 2119 2126 2133 2140 2147 2155 2162 2169 2176 2183 2191 2198 2205 2212 2219 2227 2234 2241 2248 2255 2263 2270 2277 2284 2291 2299 2306 2313 2320 2327 2335 2342 2349 2356 2363 2371 2378 2385 2392 2399 2407 2414 2421 2428 2435 2443 2450 2457 2464 2471 2479 2486 2493 2500 2507 2515 2522 2529 2536 2543 2551 2558 2565 2572 2579 2587 2594 2601 2608 2615 2623 2630 2637 2644 2651 2659 2666 2673 2680 2687 2695 2702 2709 2716 2723 2731 2738 2745 2752 2759 2767 2774 2781 2788 2795 2803 2810 2817 2824 2831 2839 2846 2853 2860 2867 2875 2882 2889 2896 2903 2911 2918 2925 2932 2939 2947 2954 2961 2968 2975 2983 2990 2997 3004 3011 3019 3026 3033 3040 3047 3055 3062 3069 3076 3083 3091 3098 3105 3112 3119 3127 3134 3141 3148 3155 3163 3170 3177 3184 3191 3199 3206 3213 3220 3227 3235 3242 3249 3256 3263 3271 3278 3285 3292 3299 3307 3314 3321 3328 3335 3343 3350 3357 3364 3371 3379 3386 3393 3400 3407 3415 3422 3429 3436 3443 3451 3458 3465 3472 3479 3487 3494 3501 3508 3515 3523 3530 3537 3544 3551 3559 3566 3573 3580 3587 3595 3602 3609 3616 3623 3631 3638 3645 3652 3659 3667 3674 3681 3688 3695 3703 3710 3717 3724 3731 3739 3746 3753 3760 3767 3775 3782 3789 3796 3803 3811 3818 3825 3832 3839 3847 3854 3861 3868 3875 3883 3890 3897 3904 3911 3919 3926 3933 3940 3947 3955 3962 3969 3976 3983 3991 3998 4005 4012 4019 4027 4034 4041 4048 4055 4063 4070 4077 4084 4091 4099 4106 4113 4120 4127 4135 4142 4149 4156 4163 4171 4178 4185 4192 4199 4207 4214 4221 4228 4235 4243 4250 4257 4264 4271 4279 4286 4293 4300 4307 4315 4322 4329 4336 4343 4351 4358 4365 4372 4379 4387 4394 4401 4408 4415 4423 4430 4437 4444 4451 4459 4466 4473 4480 4487 4495 4502 4509 4516 4523 4531 4538 4545 4552 4559 4567 4574 4581 4588 4595 4603 4610 4617 4624 4631 4639 4646 4653 4660 4667 4675 4682 4689 4696 4703 4711 4718 4725 4732 4739 4747 4754 4761 4768 4775 4783 4790 4797 4804 4811 4819 4826 4833 4840 4847 4855 4862 4869 4876 4883 4891 4898 4905 4912 4919 4927 4934 4941 4948 4955 4963 4970 4977 4984 4991 4999 5006 5013 5020 5027 5035 5042 5049 5056 5063 5071 5078 5085 5092 5099 5107 5114 5121 5128 5135 5143 5150 5157 5164 5171 5179 5186 5193 5200 5207 5215 5222 5229 5236 5243 5251 5258 5265 5272 5279 5287 5294 5301 5308 5315 5323 5330 5337 5344 5351 5359 5366 5373 5380 5387 5395 5402 5409 5416 5423 5431 5438 5445 5452 5459 5467 5474 5481 5488 5495 5503 5510 5517 5524 5531 5539 5546 5553 5560 5567 5575 5582 5589 5596 5603 5611 5618 5625 5632 5639 5647 5654 5661 5668 5675 5683 5690 5697 5704 5711 5719 5726 5733 5740 5747 5755 5762 5769 5776 5783 5791 5798 5805 5812 5819 5827 5834 5841 5848 5855 5863 5870 5877 5884 5891 5899 5906 5913 5920 5927 5935 5942 5949 5956 5963 5971 5978 5985 5992 5999 6007 6014 6021 6028 6035 6043 6050 6057 6064 6071 6079 6086 6093 6100 6107 6115 6122 6129 6136 6143 6151 6158 6165 6172 6179 6187 6194 6201 6208 6215 6223 6230 6237 6244 6251 6259 6266 6273 6280 6287 6295 6302 6309 6316 6323 6331 6338 6345 6352 6359 6367 6374 6381 6388 6395 6403 6410 6417 6424 6431 6439 6446 6453 6460 6467 6475 6482 6489 6496 6503 6511 6518 6525 6532 6539 6547 6554 6561 6568 6575 6583 6590 6597 6604 6611 6619 6626 6633 6640 6647 6655 6662 6669 6676 6683 6691 6698 6705 6712 6719 6727 6734 6741 6748 6755 6763 6770 6777 6784 6791 6799 6806 6813 6820 6827 6835 6842 6849 6856 6863 6871 6878 6885 6892 6899 6907 6914 6921 6928 6935 6943 6950 6957 6964 6971 6979 6986 6993 7000 7007 7015 7022 7029 7036 7043 7051 7058 7065 7072 7079 7087 7094 7101 7108 7115 7123 7130 7137 7144 7151 7159 7166 7173 7180 7187 7195 7202 7209 7216 7223 7231 7238 7245 7252 7259 7267 7274 7281 7288 7295 7303 7310 7317 7324 7331 7339 7346 7353 7360 7367 7375 7382 7389 7396 7403 7411 7418 7425 7432 7439 7447 7454 7461 7468 7475 7483 7490 7497 7504 7511 7519 7526 7533 7540 7547 7555 7562 7569 7576 7583 7591 7598 7605 7612 7619 7627 7634 7641 7648 7655 7663 7670 7677 7684 7691 7699 7706 7713 7720 7727 7735 7742 7749 7756 7763 7771 7778 7785 7792 7799 7807 7814 7821 7828 7835 7843 7850 7857 7864 7871 7879 7886 7893 7900 7907 7915 7922 7929 7936 7943 7951 7958 7965 7972 7979 7987 7994 8001 8008 8015 8023 8030 8037 8044 8051 8059 8066 8073 8080 8087 8095 8102 8109 8116 8123 8131 8138 8145 8152 8159 8167 8174 8181 8188 8195 8203 8210 8217 8224 8231 8239 8246 8253 8260 8267 8275 8282 8289 8296 8303 8311 8318 8325 8332 8339 8347 8354 8361 8368 8375 8383 8390 8397 8404 8411 8419 8426 8433 8440 8447 8455 8462 8469 8476 8483 8491 8498 8505 8512 8519 8527 8534 8541 8548 8555 8563 8570 8577 8584 8591 8599 8606 8613 8620 8627 8635 8642 8649 8656 8663 8671 8678 8685 8692 8699 8707 8714 8721 8728 8735 8743 8750 8757 8764 8771 8779 8786 8793 8800 8807 8815 8822 8829 8836 8843 8851 8858 8865 8872 8879 8887 8894 8901 8908 8915 8923 8930 8937 8944 8951 8959 8966 8973 8980 8987 8995 9002 9009 9016 9023 9031 9038 9045 9052 9059 9067 9074 9081 9088 9095 9103 9110 9117 9124 9131 9139 9146 9153 9160 9167 9175 9182 9189 9196 9203 9211 9218 9225 9232 9239 9247 9254 9261 9268 9275 9283 9290 9297 9304 9311 9319 9326 9333 9340 9347 9355 9362 9369 9376 9383 9391 9398 9405 9412 9419 9427 9434 9441 9448 9455 9463 9470 9477 9484 9491 9499 9506 9513 9520 9527 9535 9542 9549 9556 9563 9571 9578 9585 9592 9599 9607 9614 9621 9628 9635 9643 9650 9657 9664 9671 9679 9686 9693 9700 9707 9715 9722 9729 9736 9743 9751 9758 9765 9772 9779 9787 9794 9801 9808 9815 9823 9830 9837 9844 9851 9859 9866 9873 9880 9887 9895 9902 9909 9916 9923 9931 9938 9945 9952 9959 9967 9974 9981 9988 9995 3 11 20 28 37 46 55 63 71 80 89 98 106 115 123 133 141 149 158 166 176 184 193 201 209 219 227 236 244 253 262 271 279 287 296 305 314 322 331339 349 357 365 374 382 392 400 409 417 425 435 443 452 460 469 478 487 495 503 512 521 530 538 547 555 565 573 581 590 598 608 616 625 633 641 651 659 668 676 685 694 703 711 719 728 737 746 754 763 771 781 789 797 806 814 824 832 841 849 857 867 875 884 892901 910 919 927 935 944 953 962 970 979 987 997 1005 1013 1022 1030 1040 1048 1057 1065 1073 1083 1091 1100 1108 1117 1126 1135 1143 1151 1160 1169 1178 1186 1195 1203 1213 1221 1229 1238 1246 1256 1264 1273 1281 1289 1299 1307 1316 1324 1333 1342 1351 1359 1367 1376 1385 1394 1402 1411 1419 1429 1437 1445 1454 1462 1472 1480 1489 1497 1505 1515 1523 1532 1540 1549 1558 1567 1575 1583 1592 1601 1610 1618 1627 1635 1645 1653 1661 1670 1678 1688 1696 1705 1713 1721 1731 1739 1748 1756 1765 1774 1783 1791 1799 1808 1817 1826 1834 1843 1851 1861 1869 1877 1886 1894 1904 1912 1921 1929 1937 1947 1955 1964 1972 1981 1990 1999 2007 2015 2024 2033 2042 2050 2059 2067 2077 2085 2093 2102 2110 2120 2128 2137 2145 2153 2163 2171 2180 2188 2197 2206 2215 2223 2231 2240 2249 2258 2266 2275 2283 2293 2301 2309 2318 2326 2336 2344 2353 2361 2369 2379 2387 2396 2404 2413 2422 2431 2439 2447 2456 2465 2474 2482 2491 2499 2509 2517 2525 2534 2542 2552 2560 2569 2577 2585 2595 2603 2612 2620 2629 2638 2647 2655 2663 2672 2681 2690 2698 2707 2715 2725 2733 2741 2750 2758 2768 2776 2785 2793 2801 2811 2819 2828 2836 2845 2854 2863 2871 2879 2888 2897 2906 2914 2923 2931 2941 2949 2957 2966 2974 2984 2992 3001 3009 3017 3027 3035 3044 3052 3061 3070 3079 3087 3095 3104 3113 3122 3130 3139 3147 3157 3165 3173 3182 3190 3200 3208 3217 3225 3233 3243 3251 3260 3268 3277 3286 3295 3303 3311 3320 3329 3338 3346 3355 3363 3373 3381 3389 3398 3406 3416 3424 3433 3441 3449 3459 3467 3476 3484 3493 3502 3511 3519 3527 3536 3545 3554 3562 3571 3579 3589 3597 3605 3614 3622 3632 3640 3649 3657 3665 3675 3683 3692 3700 3709 3718 3727 3735 3743 3752 3761 3770 3778 3787 3795 3805 3813 3821 3830 3838 3848 3856 3865 3873 3881 3891 3899 3908 3916 3925 3934 3943 3951 3959 3968 3977 3986 3994 4003 4011 4021 4029 4037 4046 4054 4064 4072 4081 4089 4097 4107 4115 4124 4132 4141 4150 4159 4167 4175 4184 4193 4202 4210 4219 4227 4237 4245 4253 4262 4270 4280 4288 4297 4305 4313 4323 4331 4340 4348 4357 4366 4375 4383 4391 4400 4409 4418 4426 4435 4443 4453 4461 4469 4478 4486 4496 4504 4513 4521 4529 4539 4547 4556 4564 4573 4582 4591 4599 4607 4616 4625 4634 4642 4651 4659 4669 4677 4685 4694 4702 4712 4720 4729 4737 4745 4755 4763 4772 4780 4789 4798 4807 4815 4823 4832 4841 4850 4858 4867 4875 4885 4893 4901 4910 4918 4928 4936 4945 4953 4961 4971 4979 4988 4996 5005 5014 5023 5031 5039 5048 5057 5066 5074 5083 5091 5101 5109 5117 5126 5134 5144 5152 5161 5169 5177 5187 5195 5204 5212 5221 5230 5239 5247 5255 5264 5273 5282 5290 5299 5307 5317 5325 5333 5342 5350 5360 5368 5377 5385 5393 5403 5411 5420 5428 5437 5446 5455 5463 5471 5480 5489 5498 5506 5515 5523 5533 5541 5549 5558 5566 5576 5584 5593 5601 5609 5619 5627 5636 5644 5653 5662 5671 5679 5687 5696 5705 5714 5722 5731 5739 5749 5757 5765 5774 5782 5792 5800 5809 5817 5825 5835 5843 5852 5860 5869 5878 5887 5895 5903 5912 5921 5930 5938 5947 5955 5965 5973 5981 5990 5998 6008 6016 6025 6033 6041 6051 6059 6068 6076 6085 6094 6103 6111 6119 6128 6137 6146 6154 6163 6171 6181 6189 6197 6206 6214 6224 6232 6241 6249 6257 6267 6275 6284 6292 6301 6310 6319 6327 6335 6344 6353 6362 6370 6379 6387 6397 6405 6413 6422 6430 6440 6448 6457 6465 6473 6483 6491 6500 6508 6517 6526 6535 6543 6551 6560 6569 6578 6586 6595 6603 6613 6621 6629 6638 6646 6656 6664 6673 6681 6689 6699 6707 6716 6724 6733 6742 6751 6759 6767 6776 6785 6794 6802 6811 6819 6829 6837 6845 6854 6862 6872 6880 6889 6897 6905 6915 6923 6932 6940 6949 6958 6967 6975 6983 6992 7001 7010 7018 7027 7035 7045 7053 7061 7070 7078 7088 7096 7105 7113 7121 7131 7139 7148 7156 7165 7174 7183 7191 7199 7208 7217 7226 7234 7243 7251 7261 7269 7277 7286 7294 7304 7312 7321 7329 7337 7347 7355 7364 7372 7381 7390 7399 7407 7415 7424 7433 7442 7450 7459 7467 7477 7485 7493 7502 7510 7520 7528 7537 7545 7553 7563 7571 7580 7588 7597 7606 7615 7623 7631 7640 7649 7658 7666 7675 7683 7693 7701 7709 7718 7726 7736 7744 7753 7761 7769 7779 7787 7796 7804 7813 7822 7831 7839 7847 7856 7865 7874 7882 7891 7899 7909 7917 7925 7934 7942 7952 7960 7969 7977 7985 7995 8003 8012 8020 8029 8038 8047 8055 8063 8072 8081 8090 8098 8107 8115 8125 8133 8141 8150 8158 8168 8176 8185 8193 8201 8211 8219 8228 8236 8245 8254 8263 8271 8279 8288 8297 8306 8314 8323 8331 8341 8349 8357 8366 8374 8384 8392 8401 8409 8417 8427 8435 8444 8452 8461 8470 8479 8487 8495 8504 8513 8522 8530 8539 8547 8557 8565 8573 8582 8590 8600 8608 8617 8625 8633 8643 8651 8660 8668 8677 8686 8695 8703 8711 8720 8729 8738 8746 8755 8763 8773 8781 8789 8798 8806 8816 8824 8833 8841 8849 8859 8867 8876 8884 8893 8902 8911 8919 8927 8936 8945 8954 8962 8971 8979 8989 8997 9005 9014 9022 9032 9040 9049 9057 9065 9075 9083 9092 9100 9109 9118 9127 9135 9143 9152 9161 9170 9178 9187 9195 9205 9213 9221 9230 9238 9248 9256 9265 9273 9281 9291 9299 9308 9316 9325 9334 9343 9351 9359 9368 9377 9386 9394 9403 9411 9421 9429 9437 9446 9454 9464 9472 9481 9489 9497 9507 9515 9524 9532 9541 9550 9559 9567 9575 9584 9593 9602 9610 9619 9627 9637 9645 9653 9662 9670 9680 9688 9697 9705 9713 9723 9731 9740 9748 9757 9766 9775 9783 9791 9800 9809 9818 9826 9835 9843 9853 9861 9869 9878 9886 9896 9904 9913 9921 9929 9939 9947 9956 9964 9973 9982 9991 9999 8 19 29 40 50 61 70 82 92 101 112 122 134 143 154 164 173 185 195 206 215 226 237 248 257 267 278 289 299 309 320 329 341 351 361 371 381 393 403 413 423 433 445 454 465 475 485 496 507 517 526 537 548559 568 579 589 601 610 620 631 640 652 662 673 682 692 704 713 724 734 745 755 766 776 785 796 807 818 827 838 848 860 869 879 890 899 911 921 932 941 951 963 973 983 993 1004 1015 1025 1035 1045 1055 1066 1077 1087 1097 1107 1119 1129 1138 1149 1159 1171 1180 1191 1201 1210 1222 1232 1243 1252 1263 1274 1285 1294 1304 1315 1325 1336 1346 1357 1366 1378 1388 1397 1408 1418 1430 1439 1450 1460 1469 1481 1491 1502 1511 1522 1533 1544 1553 1563 1574 1585 1595 1605 1616 1625 1637 1647 1657 1667 1677 1689 1699 1709 1719 1729 1741 1750 1761 1771 1781 1792 1803 1813 1822 1833 1844 1855 1864 1875 1885 1897 1906 1916 1927 1936 1948 1958 1969 1978 1988 2000 2009 2020 2030 2041 2051 2062 2072 2081 2092 2103 2114 2123 2134 2144 2156 2165 2175 2186 2195 2207 2217 2228 2237 2247 2259 2269 2279 2289 2300 2311 2321 2331 2341 2351 2362 2373 2383 2393 2403 2415 2425 2434 2445 2455 2467 2476 2487 2497 2506 2518 2528 2539 2548 2559 2570 2581 2590 2600 2611 2621 2632 2642 2653 2662 2674 2684 2693 2704 2714 2726 2735 2746 2756 2765 2777 2787 2798 2807 2818 2829 2840 2849 2859 2870 2881 2891 2901 2912 2921 2933 2943 2953 2963 2973 2985 2995 3005 3015 3025 3037 3046 3057 3067 3077 3088 3099 3109 3118 3129 3140 3151 3160 3171 3181 3193 3202 3212 3223 3232 3244 3254 3265 3274 3284 3296 3305 3316 3326 3337 3347 3358 3368 3377 3388 3399 3410 3419 3430 3440 3452 3461 3471 3482 3491 3503 3513 3524 3533 3543 3555 3565 3575 3585 3596 3607 3617 3627 3637 3647 3658 3669 3679 3689 3699 3711 3721 3730 3741 3751 3763 3772 3783 3793 3802 3814 3824 3835 3844 3855 3866 3877 3886 3896 3907 3917 3928 3938 3949 3958 3970 3980 3989 4000 4010 4022 4031 4042 4052 4061 4073 4083 4094 4103 4114 4125 4136 4145 4155 4166 4177 4187 4197 4208 4217 4229 4239 4249 4259 4269 4281 4291 4301 4311 4321 4333 4342 4353 4363 4373 4384 4395 4405 4414 4425 4436 4447 4456 4467 4477 4489 4498 4508 4519 4528 4540 4550 4561 4570 4580 4592 4601 4612 4622 4633 4643 4654 4664 4673 4684 4695 4706 4715 4726 4736 4748 4757 4767 4778 4787 4799 4809 4820 4829 4839 4851 4861 4871 4881 4892 4903 4913 4923 4933 4943 4954 4965 4975 4985 4995 5007 5017 5026 5037 5047 5059 5068 5079 5089 5098 5110 5120 5131 5140 5151 5162 5173 5182 5192 5203 5213 5224 5234 5245 5254 5266 5276 5285 5296 5306 5318 5327 5338 5348 5357 5369 5379 5390 5399 5410 5421 5432 5441 5451 5462 5473 5483 5493 5504 5513 5525 5535 5545 5555 5565 5577 5587 5597 5607 5617 5629 5638 5649 5659 5669 5680 5691 5701 5710 5721 5732 5743 5752 5763 5773 5785 5794 5804 5815 5824 5836 5846 5857 5866 5876 5888 5897 5908 5918 5929 5939 5950 5960 5969 5980 5991 6002 6011 6022 6032 6044 6053 6063 6074 6083 6095 6105 6116 6125 6135 6147 6157 6167 6177 6188 6199 6209 6219 6229 6239 6250 6261 6271 6281 6291 6303 6313 6322 6333 6343 6355 6364 6375 6385 6394 6406 6416 6427 6436 6447 6458 6469 6478 6488 6499 6509 6520 6530 6541 6550 6562 6572 6581 6592 6602 6614 6623 6634 6644 6653 6665 6675 6686 6695 6706 6717 6728 6737 6747 6758 6769 6779 6789 6800 6809 6821 6831 6841 6851 6861 6873 6883 6893 6903 6913 6925 6934 6945 6955 6965 6976 6987 6997 7006 7017 7028 7039 7048 7059 7069 7081 7090 7100 7111 7120 7132 7142 7153 7162 7172 7184 7193 7204 7214 7225 7235 7246 7256 7265 7276 7287 7298 7307 7318 7328 7340 7349 7359 7370 7379 7391 7401 7412 7421 7431 7443 7453 7463 7473 7484 7495 7505 7515 7525 7535 7546 7557 7567 7577 7587 7599 7609 7618 7629 7639 7651 7660 7671 7681 7690 7702 7712 7723 7732 7743 7754 7765 7774 7784 7795 7805 7816 7826 7837 7846 7858 7868 7877 7888 7898 7910 7919 7930 7940 7949 7961 7971 7982 7991 8002 8013 8024 8033 8043 8054 8065 8075 8085 8096 8105 8117 8127 8137 8147 8157 8169 8179 8189 8199 8209 8221 8230 8241 8251 8261 8272 8283 8293 8302 8313 8324 8335 8344 8355 8365 8377 8386 8396 8407 8416 8428 8438 8449 8458 8468 8480 8489 8500 8510 8521 8531 8542 8552 8561 8572 8583 8594 8603 8614 8624 8636 8645 8655 8666 8675 8687 8697 8708 8717 8727 8739 8749 8759 8769 8780 8791 8801 8811 8821 8831 8842 8853 8863 8873 8883 8895 8905 8914 8925 8935 8947 8956 8967 8977 8986 8998 9008 9019 9028 9039 9050 9061 9070 9080 9091 9101 9112 9122 9133 9142 9154 9164 9173 9184 9194 9206 9215 9226 9236 9245 9257 9267 9278 9287 9298 9309 9320 9329 9339 9350 9361 9371 9381 9392 9401 9413 9423 9433 9443 9453 9465 9475 9485 9495 9505 9517 9526 9537 9547 9557 9568 9579 9589 9598 9609 9620 9631 9640 9651 9661 9673 9682 9692 9703 9712 9724 9734 9745 9754 9764 9776 9785 9796 9806 9817 9827 9838 9848 9857 9868 9879 9890 9899 9910 9920 9932 9941 9951 9962 9971 9983 9993 4 15 27 41 53 65 77 91 104 116 128 140 152 165 178 190 202 214 229 241 251 265 277 291 302 315 327 338 352 364 377 388 401 415 428 439 451 464 476 489 501 514 525 539 551 562 575 587 602 613 626 638 649 663 675 688 699 712 725 739 749 761 775 788 800 812 825 836 850 862 874 886 898 913 925 937 949 961 975 986 999 1011 1023 1036 1049 1061 1072 1085 1099 1112 1123 1136 1148 1162 1173 1185 1198 1209 1223 1235 1249 1259 1271 1286 1297 1310 1322 1335 1347 1360 1372 1383 1396 1409 1423 1433 1447 1459 1473 1484 1496 1509 1520 1534 1546 1559 1570 1582 1597 1609 1621 1633 1646 1659 1671 1683 1695 1707 1720 1733 1745 1757 1769 1784 1796 1807 1820 1832 1846 1857 1870 1882 1893 1907 1919 1933 1943 1957 1970 1983 1994 2006 2019 2031 2044 2056 2069 2080 2095 2107 2117 2131 2143 2157 2168 2181 2193 2204 2218 2230 2243 2254 2267 2281 2294 2305 2317 2330 2343 2355 2367 2380 2391 2405 2417 2429 2441 2453 2468 2480 2492 2504 2516 2530 2541 2554 2566 2578 2591 2605 2617 2627 2641 2654 2667 2678 2691 2703 2717 2728 2740 2753 2764 2779 2791 2804 2815 2827 2841 2852 2865 2877 2890 2902 2915 2927 2938 2951 2965 2978 2989 3002 3014 3028 3039 3051 3064 3075 3089 3101 3115 3125 3137 3152 3164 3176 3188 3201 3214 3226 3238 3250 3262 3275 3289 3301 3313 3325 3339 3351 3362 3375 3387 3401 3412 3425 3437 3448 3463 3475 3488 3499 3512 3525 3538 3549 3561 3574 3586 3599 3611 3625 3635 3650 3662 3673 3686 3698 3712 3723 3736 3748 3759 3773 3785 3799 3809 3823 3836 3849 3860 3872 3885 3898 3910 3922 3935 3946 3961 3973 3985 3997 4009 4023 4035 4047 4059 4071 4085 4096 4109 4121 4133 4147 4160 4172 4183 4196 4209 4222 4233 4246 4258 4273 4283 4295 4309 4319 4334 4346 4359 4370 4382 4396 4407 4420 4432 4445 4457 4471 4483 4493 4507 4520 4533 4544 4557 4569 4583 4594 4606 4619 4630 4645 4657 4670 4681 4693 4707 4719 4731 4743 4756 4769 4781 4793 4805 4817 4831 4844 4856 4868 4880 4894 4906 4917 4930 4942 4957 4967 4981 4993 5003 5018 5030 5043 5054 5067 5080 5093 5104 5116 5129 5141 5155 5167 5180 5191 5205 5217 5228 5241 5253 5267 5278 5291 5303 5314 5329 5341 5354 5365 5378 5391 5404 5415 5427 5440 5453 5465 5477 5491 5501 5516 5528 5540 5552 5564 5578 5590 5602 5614 5626 5641 5651 5665 5677 5689 5702 5715 5727 5738 5751 5764 5777 5788 5801 5813 5828 5839 5851 5864 5875 5889 5901 5914 5925 5937 5951 5962 5975 5987 6001 6013 6026 6038 6049 6062 6075 6088 6099 6112 6124 6139 6149 6161 6175 6185 6200 6212 6225 6236 6248 6262 6274 6286 6298 6311 6325 6337 6349 6361 6373 6386 6399 6411 6423 6435 6449 6461 6472 6485 6497 6512 6523 6536 6548 6559 6573 6585 6598 6609 6622 6635 6649 6659 6671 6685 6697 6710 6722 6735 6746 6760 6772 6783 6796 6808 6823 6833 6847 6859 6869 6884 6896 6909 6920 6933 6946 6959 6970 6982 6995 7009 7021 7033 7046 7057 7071 7083 7095 7107 7119 7133 7145 7157 7169 7181 7196 7207 7220 7232 7244 7257 7270 7282 7293 7306 7319 7333 7343 7357 7369 7383 7394 7406 7419 7430 7444 7456 7469 7480 7492 7507 7517 7531 7543 7556 7568 7581 7593 7604 7617 7630 7643 7654 7667 7679 7694 7705 7717 7730 7741 7755 7767 7780 7791 7803 7817 7829 7841 7853 7867 7880 7892 7904 7916 7928 7941 7954 7966 7978 7990 8005 8017 8027 8041 8053 8067 8078 8091 8103 8114 8128 8140 8153 8164 8177 8191 8204 8215 8227 8240 8252 8265 8277 8290 8301 8315 8327 8338 8351 8363 8378 8389 8402 8414 8425 8439 8451 8464 8475 8488 8501 8515 8525 8537 8551 8564 8576 8588 8601 8612 8626 8638 8650 8662 8674 8689 8701 8713 8725 8737 8751 8762 8775 8787 8799 8812 8825 8837 8848 8861 8875 8888 8899 8912 8924 8938 8949 8961 8974 8985 8999 9011 9025 9035 9047 9062 9073 9086 9098 9111 9123 9136 9148 9159 9172 9185 9199 9209 9223 9235 9249 9260 9272 9285 9296 9310 9322 9335 9346 9358 9373 9385 9397 9409 9422 9435 9447 9459 9471 9483 9496 9509 9521 9533 9545 9560 9572 9583 9596 9608 9622 9633 9646 9658 9669 9683 9695 9709 9719 9733 9746 9759 9770 9782 9795 9807 9820 9832 9845 9856 9871 9883 9893 9907 9919 9933 9944 9957 9969 9980 9994 7 22 3551 68 83 97 111 127 142 157 171 187 200 217 231 245 260 274 292 307 321 335 350 367 380 395 410 424 440 457 471 483 500 515 531 544 560 574 591 604 619 634 647 665 680 695 709 723 740 753 769 783 799 813 829 843 856 872 889 904 917 933 947 964 977 992 1007 1021 1037 1052 1069 1081 1095 1113 1127 1142 1156 1172 1187 1202 1216 1231 1245 1261 1277 1292 1306 1321 1337 1352 1365 1381 1395 1412 1425 1441 1455 1468 1486 1501 1516 1529 1545 1561 1576 1589 1604 1619 1634 1649 1664 1681 1693 1711 1725 1738 1754 1768 1785 1798 1814 1828 1841 1858 1873 1889 1901 1918 1934 1949 1963 1977 1993 2008 2023 2037 2053 2066 2084 2098 2113 2127 2141 2158 2173 2187 2201 2216 2233 2246 2261 2276 2290 2307 2323 2337 2350 2366 2381 2397 2410 2426 2440 2458 2470 2485 2501 2513 2531 2546 2561 2575 2589 2606 2619 2635 2649 2665 2679 2696 2710 2722 2739 2755 2770 2783 2799 2813 2830 2843 2858 2873 2887 2905 2919 2935 2948 2962 2979 2993 3008 3022 3038 3053 3068 3082 3097 3111 3128 3143 3158 3172 3187 3203 3218 3231 3247 3261 3279 3291 3308 3322 3334 3352 3367 3382 3395 3411 3427 3442 3455 3470 3485 3500 3517 3531 3547 3560 3577 3591 3604 3620 3634 3651 3664 3680 3694 3707 3725 3740 3755 3769 3784 3800 3815 3829 3843 3859 3874 3889 3903 3920 3932 3950 3964 3979 3993 4007 4024 4039 4053 4067 4082 4100 4112 4129 4143 4157 4173 4189 4203 4216 4232 4247 4263 4276 4292 4306 4324 4337 4352 4367 4381 4397 4412 4427 4441 4455 4472 4485 4501 4515 4532 4546 4562 4576 4589 4605 4621 4636 4649 4665 4679 4697 4709 4724 4741 4753 4771 4785 4801 4814 4828 4845 4859 4874 4888 4904 4921 4935 4949 4964 4978 4994 5009 5024 5038 5053 5069 5084 5097 5113 5127 5145 5158 5174 5188 5201 5218 5233 5248 5261 5277 5293 5309 5321 5336 5353 5367 5383 5397 5413 5426 5443 5457 5470 5486 5500 5518 5530 5547 5561 5573 5591 5606 5621 5635 5650 5666 5681 5695 5709 5725 5741 5756 5770 5786 5799 5816 5830 5845 5859 5873 5890 5905 5919 5933 5948 5966 5979 5995 6009 6023 6039 6055 6069 6082 6098 6113 6130 6142 6159 6173 6190 6203 6218 6233 6247 6263 6278 6293 6307 6321 6339 6351 6368 6382 6398 6412 6428 6442 6455 6471 6487 6502 6515 6531 6545 6563 6577 6591 6607 6620 6637 6651 6667 6680 6694 6711 6725 6740 6754 6771 6787 6801 6815 6830 6844 6860 6875 6890 6904 6919 6937 6951 6963 6980 6994 7011 7024 7040 7054 7067 7084 7099 7114 7127 7143 7160 7175 7189 7203 7219 7233 7249 7263 7279 7292 7309 7323 7336 7352 7366 7384 7397 7413 7427 7441 7457 7472 7487 7501 7516 7532 7549 7561 7575 7592 7607 7622 7636 7652 7665 7682 7696 7711 7725 7739 7757 7772 7786 7801 7815 7832 7845 7861 7875 7889 7905 7921 7935 7948 7964 7981 7996 8009 8025 8039 8056 8069 8084 8099 8113 8129 8144 8161 8173 8187 8205 8218 8234 8248 8264 8278 8294 8308 8321 8337 8353 8369 8381 8398 8413 8429 8443 8457 8473 8486 8503 8517 8533 8546 8560 8578 8593 8607 8621 8637 8653 8667 8681 8696 8710 8726 8741 8756 8770 8785 8803 8817 8830 8846 8860 8877 8890 8906 8920 8933 8950 8965 8981 8993 9010 9026 9041 9055 9069 9085 9099 9115 9129 9145 9158 9176 9190 9202 9219 9233 9250 9263 9279 9293 9307 9323 9338 9353 9367 9382 9399 9415 9428 9442 9458 9473 9488 9502 9518 9531 9548 9562 9577 9591 9605 9623 9638 9652 9667 9681 9698 9711 9727 9741 9755 9771 9788 9802 9814 9831 9847 9862 9875 9891 9905 9922 9935 9950 9965 9979 9997 13 32 47 64 85 100 119 136 155 172 191 208 224 243 263 281 298 316 334 353 370 387 406 422 442 459 479 494 511 532 550 567 584 603 622 639 656 674 691 710 730 747 764 782 802 819 835 854 871 891 907 926 943 958 980 998 1016 1033 1051 1070 1088 1105 1121 1141 1157 1177 1193 1214 1228 1250 1267 1282 1301 1318 1339 1354 1373 1390 1407 1426 1444 1465 1479 1498 1517 1537 1552 1569 1588 1606 1624 1641 1660 1676 1697 1714 1732 1749 1767 1786 1804 1821 1839 1856 1876 1892 1911 1928 1945 1965 1984 2001 2017 2036 2055 2073 2089 2108 2125 2146 2161 2179 2199 2213 2235 2252 2271 2287 2303 2324 2339 2359 2375 2395 2411 2432 2449 2463 2483 2503 2521 2537 2555 2573 2593 2609 2626 2645 2661 2683 2699 2719 2734 2751 2771 2789 2806 2823 2842 2861 2878 2895 2913 2930 2950 2969 2986 3003 3021 3041 3058 3074 3093 3110 3131 3146 3166 3183 3197 3219 3237 3255 3272 3290 3309 3327 3344 3361 3380 3397 3417 3434 3453 3469 3489 3506 3521 3541 3557 3578 3593 3613 3629 3646 3668 3685 3704 3719 3737 3757 3776 3791 3808 3827 3845 3863 3880 3901 3915 3937 3953 3971 3988 4006 4025 4043 4060 4078 4095 4117 4131 4151 4168 4186 4204 4223 4240 4256 4275 4294 4312 4328 4347 4364 4385 4402 4419 4438 4454 4474 4491 4510 4526 4543 4563 4579 4598 4615 4635 4652 4671 4688 4705 4723 4742 4760 4777 4795 4813 4834 4849 4865 4886 4900 4922 4939 4958 4973 4990 5011 5029 5045 5062 5081 5102 5119 5137 5153 5170 5189 5209 5225 5242 5260 5281 5297 5313 5332 5349 5371 5386 5405 5422 5439 5458 5476 5494 5511 5529 5548 5569 5583 5600 5620 5637 5656 5673 5692 5708 5728 5745 5761 5780 5797 5818 5833 5853 5871 5885 5907 5924 5943 5959 5977 5996 6015 6031 6047 6067 6087 6104 6121 6140 6155 6176 6193 6211 6227 6245 6265 6283 6299 6317 6334 6356 6371 6391 6407 6425 6443 6463 6479 6495 6514 6533 6553 6567 6587 6605 6625 6641 6658 6677 6693 6713 6730 6749 6765 6782 6803 6818 6838 6855 6874 6891 6910 6927 6944 6962 6981 6999 7016 7034 7052 7073 7089 7106 7125 7141 7161 7178 7197 7213 7229 7250 7268 7285 7301 7322 7341 7358 7376 7393 7409 7429 7448 7465 7481 7499 7521 7538 7552 7573 7589 7610 7625 7645 7661 7678 7697 7715 7733 7750 7768 7789 7808 7823 7840 7859 7876 7895 7912 7931 7947 7967 7984 8000 8019 8036 8057 8074 8092 8110 8126 8146 8163 8182 8198 8216 8235 8255 8270 8287 8307 8326 8343 8360 8379 8395 8415 8432 8450 8467 8485 8506 8523 8540 8558 8575 8595 8611 8630 8647 8665 8683 8702 8719 8734 8753 8774 8792 8809 8827 8845 8864 8881 8897 8917 8932 8953 8969 8990 9004 9021 9043 9058 9077 9094 9113 9130 9149 9166 9183 9201 9220 9241 9255 9274 9292 9313 9328 9345 9364 9380 9400 9417 9436 9452 9469 9490 9508 9525 9543 9561 9580 9597 9615 9632 9649 9668 9687 9704 9721 9739 9760 9777 9793 9812 9829 9849 9865 9884 9901 9917 9937 9955 9975 9989 10 33 56 75 94 118 137 161 181 205 223 249 269 286 310 332 356 375 397 418 437 461 482 505 524 545 569 593 611 632 655 677 698 718 741 760 784 805 826 847 868 893 914 934 956 976 1000 1019 1042 1063 1084 1106 1130 1150 1167 1192 1215 1237 12571279 1300 1323 1343 1364 1387 1405 1431 1451 1474 1493 1513 1538 1556 1580 1599 1623 1642 1666 1685 1706 1727 1753 1775 1793 18151837 1862 1880 1900 1923 1942 1966 1987 2012 2029 2049 2074 2096 2116 2138 2159 2182 2203 2224 2245 2265 2288 2312 2332 2354 23742398 2419 2438 2461 2481 2505 2524 2547 2567 2588 2613 2633 2656 2675 2697 2720 2743 2762 2782 2805 2825 2848 2869 2893 2909 29362956 2977 2998 3020 3043 3063 3085 3106 3124 3149 3169 3194 3211 3236 3257 3280 3298 3319 3341 3365 3385 3405 3428 3447 3473 34953514 3535 3556 3581 3601 3621 3643 3663 3687 3706 3729 3749 3771 3794 3817 3837 3857 3879 3902 3923 3944 3965 3987 4013 4030 40514075 4093 4118 4138 4161 4180 4201 4225 4244 4267 4287 4310 4330 4354 4376 4393 4417 4439 4462 4481 4503 4525 4549 4568 4587 46114629 4655 4676 4699 4717 4738 4762 4784 4803 4825 4846 4870 4889 4911 4931 4952 4976 5000 5019 5041 5061 5086 5105 5125 5147 51685194 5211 5235 5257 5275 5300 5320 5343 5362 5384 5407 5429 5449 5469 5492 5512 5536 5557 5579 5599 5623 5643 5663 5685 5707 57295750 5771 5793 5811 5837 5858 5881 5900 5923 5944 5967 5986 6005 6029 6052 6073 6092 6117 6134 6160 6182 6202 6221 6243 6268 62896308 6329 6350 6376 6393 6418 6437 6459 6481 6505 6524 6544 6566 6589 6610 6631 6652 6674 6700 6718 6739 6761 6781 6805 6825 68486867 6887 6911 6931 6953 6974 6998 7019 7041 7063 7082 7103 7126 7149 7168 7190 7211 7237 7255 7275 7299 7316 7342 7363 7385 74057426 7449 7471 7491 7513 7534 7558 7579 7600 7621 7642 7664 7687 7707 7729 7748 7773 7793 7811 7834 7855 7881 7901 7923 7945 79637988 8007 8031 8049 8071 8093 8119 8135 8156 8180 8200 8223 8243 8266 8285 8309 8330 8350 8372 8393 8420 8437 8459 8481 8499 85248545 8567 8587 8609 8631 8654 8673 8693 8716 8740 8761 8782 8804 8823 8847 8869 8889 8909 8931 8955 8975 8996 9017 9037 9063 90829105 9125 9147 9169 9191 9212 9231 9253 9277 9301 9317 9341 9363 9387 9406 9425 9449 9467 9493 9512 9536 9554 9574 9601 9617 96419663 9685 9706 9728 9749 9769 9790 9813 9836 9855 9877 9898 9925 9943 9963 9986 5 34 58 86 109 135 163 188 213 238 266 293 317 344 368 394 421 447 472 497 523 553 577 597 627 653 681 705 731 757 778 809 833 861 883 908 939 965 989 1012 1041 1064 1093 1115 1144 1166 1196 1220 1244 1270 1295 1328 1349 1375 1401 1424 1453 1477 1504 1527 1555 1581 1611 1631 1655 1684 1712 1736 1762 1789 1811 1840 1865 1891 1915 1941 1971 1995 2021 2045 2071 2099 2122 2150 2174 2200 2225 2253 2278 2302 2329 2357 2384 2408 2433 2459 2488 2511 2535 2563 2584 2614 2639 2668 2689 2713 2744 2769 2794 2821 2847 2872 2899 2924 2945 2972 2999 3029 3050 3080 3103 3133 3154 3179 3207 3230 3259 3283 3310 3333 3359 3391 3413 3439 3464 3490 3518 3542 3568 3592 3619 3644 3671 3697 3722 3747 3777 3801 3826 3851 3878 3905 3929 3956 3981 4004 4033 4058 4087 4108 4137 4162 4190 4213 4238 4265 4289 4317 4341 4369 4390 4421 4448 4468 4497 4522 4551 4575 4600 4627 4648 4678 4701 4730 4751 4779 4808 4835 4857 4882 4909 4937 4960 4987 5012 5036 5065 5090 5115 5139 5165 5197 5219 5246 5270 5295 5324 5347 5374 5398 5425 5450 5479 5505 5527 5554 5581 5608 5631 5657 5684 5713 5735 5759 5787 5810 5840 5865 5893 5915 5941 5968 5993 6019 6045 6070 6097 6123 6148 6170 6196 6226 6254 6277 6304 6328 6357 6380 6404 6433 6454 6484 6507 6537 6557 6584 6615 6639 6663 6688 6715 6743 6766 6793 6817 6843 6868 6898 6922 6947 6973 7003 7025 7049 7076 7102 7129 7154 7179 7205 7228 7258 7283 7311 7334 7361 7387 7414 7437 7462 7489 7514 7541 7565 7594 7616 7646 7672 7695 7721 7747 7775 7798 7825 7851 7873 7903 7927 7955 7976 8006 8032 8060 8083 8108 8134 8162 8186 8212 8237 8259 8291 8317 8342 8367 8391 8421 8445 8471 8494 8518 8549 8571 8597 8623 8648 8679 8704 8731 8752 8777 8805 8834 8855 8882 8907 8939 8960 8984 9013 9034 9064 9089 9116 9140 9165 9193 9217 9243 9269 9295 9321 9349 9374 9395 9424 9451 9478 9501 9529 9553 9581 9604 9629 9656 9677 9710 9735 9761 9784 9811 9839 9863 9889 9914 9940 9968 9992 21 49 79 113 147 177 207 235 272 301 328 359 389 429 453 488 518 543 580 609 644 669 701 733 767 793 821 855 885 920 950 982 1009 1043 1076 1102 1133 1165 1199 1227 1258 1288 1317 1353 1382 1415 1443 1475 1508 1539 1568 1598 1630 1663 1691 1724 1755 1779 1819 1849 1879 1909 1940 1973 2002 2035 2063 2091 2129 2152 2189 2221 2251 2282 2314 2345 2372 2402 2437 2469 2495 2527 2557 2596 2624 2650 2685 2711 2747 2775 2809 2835 2866 2900 2929 2960 2991 3023 3056 3086 3117 3145 3178 3209 3241 3269 3302 3332 3369 3394 3423 3457 3483 3520 3550 3583 3610 3641 3676 3705 3734 3765 3797 3831 3862 3892 3921 3952 3982 4016 4045 4076 4105 4139 4169 4198 4231 4261 4298 4325 4355 4388 4413 4449 4479 4511 4537 4571 4604 4637 4663 4691 4727 4759 4791 4821 4852 4879 4915 4946 4972 5002 5033 5072 5096 5132 5159 5185 5223 5252 5284 5312 5345 5375 5408 5435 5468 5499 5534 5563 5594 5624 5655 5686 5717 5746 5779 5807 5842 5872 5902 5932 5961 5997 6027 6058 6089 6118 6152 6183 6213 6242 6272 6305 6340 6365 6400 6429 6464 6493 6521 6555 6580 6616 6645 6679 6704 6736 6773 6797 6832 6865 6895 6926 6956 6988 7013 7047 7077 7112 7138 7171 7201 7239 7264 7297 7327 7354 7388 7420 7451 7479 7509 7544 7574 7603 7635 7669 7700 7731 7760 7790 7820 7852 7885 7913 7946 7975 8011 8042 8068 8101 8132 8165 8194 8225 8257 8284 8319 8348 8380 8408 8441 8474 8507 8535 8566 8596 8629 8659 8690 8722 8747 8783 8813 8840 8871 8903 8941 8968 9001 9029 9056 9093 9121 9155 9181 9214 9244 9280 9305 9337 9370 9404 9431 9461 9494 9523 9555 9587 9616 9647 9676 9716 9742 9773 9803 9833 9867 9897 9927 9958 9987 25 62 99 130 170 212 250 284 323 358 399 431 467 508 541 583 617 658 689 727 770 803 842 878 915 955 991 1028 1059 1101 1137 1179 1208 1251 1287 1329 1361 1400 1436 1467 1510 1547 1587 1617 1654 1700 1735 1772 1805 1847 1883 1922 1954 1991 2027 2065 2105 2139 2177 2211 2257 2295 2325 2365 2401 2444 2475 2512 2549 2583 2625 2660 2701 2732 2773 2812 2851 2884 2920 2959 2996 3032 3071 3107 3142 3185 3221 3253 3293 3331 3370 3404 3445 3478 3509 3553 3590 3628 3661 3701 3742 3779 3812 3850 3887 3927 3963 3999 4036 4069 4111 4148 4181 4220 4255 4299 4335 4371 4406 4442 4484 4517 4555 4593 4628 4666 4708 4744 4774 4816 4853 4895 4925 4966 5001 5044 5075 5111 5149 5183 5227 5263 5302 5335 5372 5414 5447 5485 5521 5559 5595 5633 5672 5703 5744 5781 5822 5854 5894 5931 5972 6004 6040 6080 6110 6153 6191 6231 6260 6297 6341 6377 6415 6451 6490 6527 6565 6599 6632 6670 6709 6752 6788 6824 6857 6901 6938 6969 7005 7042 7085 7118 7155 7192 7227 7271 7305 7345 7377 7417 7455 7496 7527 7564 7601 7637 7676 7714 7751 7783 7827 7863 7897 7937 7973 8014 8048 8086 8121 8155 8197 8233 8273 8305 8345 8385 8422 8456 8493 8529 8569 8605 8641 8680 8715 8758 8794 8828 8866 8900 8942 8978 9015 9051 9087 9128 9163 9200 9237 9271 9314 9352 9388 9418 9460 9500 9538 9569 9611 9644 9689 9718 9753 9797 9825 9872 9908 9946 9977 17 69 107 151 197 242 285 337 379 416 466 509 557 596 645 687 735 777 820 865 905 957 1001 1047 1090 1131 1181 1225 1268 1311 1358 1403 1448 1490 1531 1577 1628 1673 1717 1760 1801 1850 1898 1935 1979 2026 2078 2115 2164 2209 2242 2296 2338 2386 2423 2473 2519 2564 2602 2648 2692 2737 2786 2833 2876 2917 2967 3010 3049 3094 3136 3189 3229 3273 3317 3356 3409 3454 3497 3539 3584 3633 3677 3716 3764 3807 3853 3895 3941 3992 4028 4079 4123 4165 4211 4252 4303 4345 4389 4431 4475 4527 4565 4613 4658 4700 4749 4792 4837 4877 4924 4969 5015 5055 5103 5146 5198 5237 5283 5326 5363 5417 5461 5507 5543 5588 5642 5678 5723 5768 5821 5861 5909 5953 5989 6037 6081 6131 6169 6217 6256 6314 6347 6392 6441 6477 6529 6574 6617 6661 6703 6753 6795 6839 6881 6929 6977 7023 7064 7109 7150 7198 7241 7289 7330 7373 7423 7466 7508 7551 7595 7647 7688 7737 7777 7819 7869 7911 7957 7997 8045 8089 8139 8175 8222 8269 8312 8359 8403 8446 8492 8536 8581 8619 8669 8709 8765 8797 8852 8891 8929 8983 9027 9071 9107 9157 9207 9251 9289 9332 9379 9430 9476 9514 9565 9603 9655 9694 9737 9781 9824 9874 9915 9961 1 57 121 169221 273 325 385 436 490 536 595 646 706 752 811 863 922 969 1027 1078 1124 1184 1239 1293 1340 1393 1457 1503 1562 1612 1669 17181777 1827 1871 1930 1985 2043 2087 2149 2194 2260 2308 2360 2416 2462 2523 2576 2631 2677 2729 2792 2837 2894 2944 3007 3059 31163161 3215 3267 3323 3376 3431 3481 3532 3598 3653 3693 3754 3806 3867 3913 3967 4017 4066 4126 4179 4234 4282 4339 4399 4450 44994553 4609 4661 4714 4766 4822 4873 4929 4983 5032 5087 5138 5199 5249 5305 5356 5401 5464 5519 5571 5615 5674 5734 5789 5831 58835945 6003 6056 6106 6164 6207 6269 6320 6369 6421 6476 6538 6593 6643 6692 6745 6807 6853 6908 6961 7012 7066 7124 7177 7222 72807335 7395 7438 7498 7550 7611 7657 7708 7762 7810 7870 7924 7983 8026 8079 8143 8192 8247 8299 8356 8405 8463 8511 8559 8618 86728732 8776 8835 8885 8943 8992 9046 9104 9151 9208 9262 9315 9365 9416 9479 9530 9586 9634 9691 9747 9799 9850 9903 9953 14 76 145199 259 343 404 458 529 586 661 717 790 845 903 971 1034 1109 1163 1234 1303 1369 1421 1487 1551 1613 1682 1743 1810 1868 1951 2005 2060 2132 2192 2264 2319 2389 2451 2510 2582 2643 2708 2763 2834 2907 2971 3031 3092 3159 3224 3287 3349 3418 3477 3548 3608 3670 3733 3790 3869 3931 3995 4057 4119 4191 4251 4316 4377 4433 4505 4577 4640 4690 4765 4827 4897 4951 5021 5077 5156 5210 5271 5339 5396 5475 5537 5605 5660 5720 5795 5849 5917 5983 6046 6109 6178 6238 6296 6363 6434 6501 6556 6627 6687 6757 6814 6879 6941 7004 7075 7136 7210 7262 7325 7400 7460 7523 7585 7653 7719 7781 7844 7906 7970 8035 8104 8170 8229 8295 8362 8423 8482 8553 8615 8684 8744 8810 8870 8926 9003 9068 9134 9188 9259 9327 9389 9445 9511 9573 9639 9701 9767 9841 9892 9970 39 105 183 256 345 411 493 566 637 721 795 881 946 1029 1114 1189 1265 1331 1417 1495 1573 1648 1726 1797 1887 1959 2038 2109 2185 2272 2347 2420 2494 2571 2657 2727 2800 2883 2955 3034 3121 3195 3266 3345 3421 3505 3569 3655 3728 3819 3884 3957 4040 4102 4195 4274 4349 4424 4492 4585 4647 4733 4802 4887 4959 5050 5122 5181 5269 5355 5433 5497 5572 5648 5737 5806 5882 5957 6034 6127 6195 6279 6346 6419 6506 6579 6657 6729 6812 6886 6968 7037 7117 7186 7273 7351 7435 7503 7582 7659 7738 7809 7887 7959 8050 8120 8206 8276 8336 8431 8509 8585 8657 8733 8818 8896 8963 9044 9119 9197 9284 9356 9439 9503 9590 9665 9730 9819 9885 9976 44 148 233 313 430 519 615 697 791 896 985 1071 1155 1253 1345 1438 1526 1639 1703 1825 1905 1997 2086 2170 2273 2368 2452 2545 2636 2749 2822 2926 3013 3100 3196 3297 3383 3466 3567 3656 3758 3841 3939 4018 4130 4215 4304 4403 4490 4586 4683 4773 4863 4947 5051 5133 5231 5319 5419 5509 5612 5698 5775 5879 5974 6065 6145 6253 6332 6445 6519 6608 6721 6790 6902 6989 7091 7167 7253 7365 7445 7539 7628 7724 7833 7918 7999 8097 8183 8281 8373 8465 8554 8644 8745 8839 8921 9020 9106 9224 9302 9393 9482 9566 9674 9763 9854 9934 43 159 280 373 481 605 716 831 929 1054 1153 1275 1379 1483 1594 1702 1829 1925 2048 2151 2239 2377 2489 2599 2705 2816 2937 3045 3153 3248 3374 3496 3603 3713 3820 3914 4049 4153 4268 4361 4465 4597 4713 4810 4916 5025 5163 5259 5381 5482 5585 5699 5823 5926 6020 6141 6255 6383 6470 6596 6701 6826 6917 7031 7147 7247 7371 7478 7586 7689 7802 7933 8021 8149 8249 8371 8477 8589 8698 8795 8918 9033 9141 9242 9357 9466 9595 9699 9805 9926 26 179 303 446 561 683 839 968 1094 1217 1371 1519 1640 1763 1899 2014 2167 2297 2427 2553 2686 2855 2980 3081 3239 3353 3507 3626 3766 3893 4015 4154 4285 4429 4541 4687 4838 4982 5095 5216 5361 5487 5630 5758 5896 6017 6166 6290 6409 6549 6682 6836 6952 7093 7221 7348 7486 7624 7759 7883 8018 8151 8300 8410 8543 8691 8819 8957 9079 9227 9344 9487 9625 9752 9881 10000 194 346 502 667 817 994 1145 1309 1461 1603 1778 1952 2101 2236 2409 2597 2757 2885 3065 3205 3392 3529 3691 3842 4001 4174 4327 4514 4641 4796 4989 5123 5289 5444 5613 5767 5936 6091 6235 6401 6571 6731 6877 7055 7215 7378 7529 7685 7849 7993 8171 8329 8497 8639 8788 8972 9137 9286 9440 9613 9778 9928 93 295 473 670 877 1058 1241 1432 1652 1835 2013 2222 2390 2607 2780 2981 3167 3340 3563 3745 3945 4101 4318 4534 4721 4899 5073 5288 5456 5667 5847 6061 6220 6452 6628 6778 6991 7185 7402 7570 7766 7953 8122 8333 8528 8723 8913 9097 9303 9519 9675 9860 87 308 554 759 1006 1207 1466 1690 1913 2135 2348 2618 2857 3073 3304 3526 3781 3975 4226 4460 4672 4907 5175 5389 5570 5829 6077 6315 6513 6764 6985 7240 7436 7673 7894 8111 8387 8602 8854 9053 9266 9539 9725 9985 230 533 773 1079 1330 1591 1863 2210 2477 2721 2987 3281 3572 3833 4090 4378 4623 4940 5206 5522 5753 6010 6326 6601 6866 7135 7408 7703 7989 8242 8516 8768 9076 9375 9626 9911 220 572 897 1205 1541 1853 2229 2533 2864 3175 3460 3871 4205 4535 4843 5176 5542 5867 61846494 6850 7163 7522 7838 8207 8453 8857 9177 9457 9821 129 623 940 1389 1747 2121 2540 2942 3403 3715 4144 4558 4997 5331 5716 6133 6542 6939 7313 7745 8077 8579 8948 9331 9717 125 629 1120 1565 2057 2498 3016 3446 3974 4411 4864 5392 5911 6358 6775 7300 77978258 8705 9179 9659 255 748 1313 1961 2446 3123 3639 4241 4750 5311 5954 6466 7060 7613 8213 8767 9407 9949 449 1280 1976 2671 3315 4065 4735 5434 6101 6723 7474 8062 8878 9544 363 1018 1790 2761 3615 4360 5108 5984 6916 7633 8434 9229 73 1174 2285 3135 4088 5060 6205 7097 8061 9007 9998 1414 2333 3682 4786 5803 7291 8399 9551 853 2315 3788 5240 6650 7939 9410 928 2797 4463 6285 7862 9789 1675 3435 5645 7559 9842 2079 4618 7030 9171 2669 5551 8632 1525 5008 8661 2908 6668 742 6389 1742 8320 4277 3245 407 3909 73155693 386--- THE LAST OF NODE ---8991请按任意键继续. . . 程序有很多地方可以优化哟,去尝试一下吧亲（づ￣3￣）づ╭❤～ More interesting algorithms : [go my repository ~](https://github.com/YUbuntu0109/Data-Structures-and-Algorithm-Analysis-in-C 摘自我的CSDN博客,这篇博客是：2018/101/03 写的,博客地址 : https://blog.csdn.net/qq_43313515","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Data Structures and Algorithms","slug":"Data-Structures-and-Algorithms","permalink":"http://yoursite.com/tags/Data-Structures-and-Algorithms/"}]},{"title":"电子邮箱应用程序","slug":"电子邮箱应用程序","date":"2019-03-11T15:19:47.000Z","updated":"2019-03-12T11:07:52.698Z","comments":true,"path":"2019/03/11/电子邮箱应用程序/","link":"","permalink":"http://yoursite.com/2019/03/11/电子邮箱应用程序/","excerpt":"","text":"电子邮箱应用程序2.0. 每个版本的功能详情见我的该项目仓库. 如下示例,代码注释写的超贴心哟 （づ￣3￣）づ╭❤～ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /** * Title MimeMessage * @Description Create a email. * @param session,sendMail and receiveMail. * @return MimeMessage * @throws MessagingException * @throws IOException * @date Feb 21, 2019-11:02:10 AM * */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws MessagingException, IOException &#123; // 1: Create a email. MimeMessage message = new MimeMessage(session); // 2: From : addresser. message.setFrom(new InternetAddress(sendMail, \"Java Program\", \"UTF-8\")); // 3: To : recipients. message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, \"Program\", \"UTF-8\")); // 4: Subject : The email theme. message.setSubject(MY_EMAIL_SUBJECT, \"UTF-8\"); /* * Create the content of the email as followed . */ // 5: Create the node of image. MimeBodyPart image = new MimeBodyPart(); DataHandler dataHandler = new DataHandler(new FileDataSource(\"resource/Cute_pig.jpg\"));// read the local file. image.setDataHandler(dataHandler);// Add the data of image to the node. image.setContentID(\"image_Cut_pig_id\");// Set a unique number for the node and his ID is referenced in the text \"node\". // 6: Create the node of text. MimeBodyPart text = new MimeBodyPart(); // You can actually add web images by HTTP links as well. text.setContent(MY_EMAIL_CONTENT, \"text/html;charset=UTF-8\"); // 7: Combine text and image \"nodes\" into a hybrid \"node\". MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(text); mm_text_image.addBodyPart(image); mm_text_image.setSubType(\"related\");// incidence relation. // 8: Encapsulate the text + image hybrid \"node\" as a normal \"node\". Attention: // The \"Content\" that is eventually added to the emailis a Multipart composed of \"bodyparts\". MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9: Create the node of attachment. MimeBodyPart attachment = new MimeBodyPart(); DataHandler dataHandler2 = new DataHandler(new FileDataSource(\"resource/Love_Yourself.mp3\")); attachment.setDataHandler(dataHandler2); // Set the file name of the attachment (encoding required). attachment.setFileName(MimeUtility.encodeText(dataHandler2.getName())); // 10: Set the relationship between ('text' + 'image') and the // 'attachment'.(compositing a large mixed \"node\"/Multipart). MimeMultipart mm_text_image_att = new MimeMultipart(); mm_text_image_att.addBodyPart(text_image);// reference: 8. mm_text_image_att.addBodyPart(attachment); mm_text_image_att.setSubType(\"mixed\");// mixed relations. // 11: Set the relationship for the entire email. (add the final mixed \"node\" as // the content of the email to the message object). message.setContent(mm_text_image_att); // 12: Set the date. message.setSentDate(new Date()); // 13: Save the setting. message.saveChanges(); return message;&#125; 程序运行效果截图 后期小哥哥我有时间会在版本2.0.上推出3.0.0 ：通过GUI设计简化用户操作,期待哟 ~ Download the source code : Try it now ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"水果贪吃蛇游戏","slug":"水果贪吃蛇游戏","date":"2019-03-10T14:34:41.000Z","updated":"2019-03-11T15:21:02.731Z","comments":true,"path":"2019/03/10/水果贪吃蛇游戏/","link":"","permalink":"http://yoursite.com/2019/03/10/水果贪吃蛇游戏/","excerpt":"","text":"Games-Gluttonous snack 2.1.0闲时写了一个贪吃蛇游戏,目前的版本是：2.1.0. 每个版本的功能详情见我的该游戏仓库 (源码注释写的很详细哟) 游戏截图 Download the source code , Have a good time to you ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"桌面应用程序：学生管理系统","slug":"学生管理系统-Java-swing","date":"2019-03-09T12:04:26.000Z","updated":"2019-03-10T16:24:14.269Z","comments":true,"path":"2019/03/09/学生管理系统-Java-swing/","link":"","permalink":"http://yoursite.com/2019/03/09/学生管理系统-Java-swing/","excerpt":"","text":"学生管理系统2.1.0. 每个版本的功能详情见我的该项目仓库. (文档注释写的非常详细哟) 登录界面 系统主界面 Download the source code , Look forward to your contribution ~","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-08T16:00:00.000Z","updated":"2019-03-09T13:08:42.551Z","comments":true,"path":"2019/03/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hi Hexo","slug":"Hi-Hexo","permalink":"http://yoursite.com/tags/Hi-Hexo/"}]}]}